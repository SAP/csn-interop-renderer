(self.webpackChunk_sap_csn_interop_renderer_website=self.webpackChunk_sap_csn_interop_renderer_website||[]).push([[201],{1594:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenError = void 0;\nclass TokenError extends Error {\n    constructor(message, token) {\n        super(message);\n        this.message = message;\n        this.token = token;\n        if (token && token.errors)\n            token.errors.push(this);\n        else\n            throw this;\n    }\n    inspect() {\n        return 'SyntaxError: ' + this.message;\n    }\n}\nexports.TokenError = TokenError;\n//# sourceMappingURL=TokenError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lYm5mL2Rpc3QvVG9rZW5FcnJvci5qcz8zOTUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlbkVycm9yID0gdm9pZCAwO1xuY2xhc3MgVG9rZW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0b2tlbikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4uZXJyb3JzKVxuICAgICAgICAgICAgdG9rZW4uZXJyb3JzLnB1c2godGhpcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IHRoaXM7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAnU3ludGF4RXJyb3I6ICcgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuZXhwb3J0cy5Ub2tlbkVycm9yID0gVG9rZW5FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1594\n")},2017:module=>{"use strict";eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2017\n")},2084:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// Generated automatically by nearley, version 2.20.1\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d) { return d[0]; }\nconst deepFlatten = (arr) => [].concat(...arr.map((v) => (Array.isArray(v) ? deepFlatten(v) : v)));\nfunction flat_string(d) {\n    if (d) {\n        if (Array.isArray(d))\n            return deepFlatten(d).join("");\n        return d;\n    }\n    return "";\n}\n;\n;\n;\n;\nconst grammar = {\n    Lexer: undefined,\n    ParserRules: [\n        { "name": "Reverse_path", "symbols": ["Path"] },\n        { "name": "Reverse_path$string$1", "symbols": [{ "literal": "<" }, { "literal": ">" }], "postprocess": (d) => d.join(\'\') },\n        { "name": "Reverse_path", "symbols": ["Reverse_path$string$1"] },\n        { "name": "Forward_path$subexpression$1$subexpression$1", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": "@" }], "postprocess": function (d) { return d.join(""); } },\n        { "name": "Forward_path$subexpression$1", "symbols": ["Forward_path$subexpression$1$subexpression$1", "Domain", { "literal": ">" }] },\n        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$1"] },\n        { "name": "Forward_path$subexpression$2", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": ">" }], "postprocess": function (d) { return d.join(""); } },\n        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$2"] },\n        { "name": "Forward_path", "symbols": ["Path"] },\n        { "name": "Path$ebnf$1$subexpression$1", "symbols": ["A_d_l", { "literal": ":" }] },\n        { "name": "Path$ebnf$1", "symbols": ["Path$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "Path$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "Path", "symbols": [{ "literal": "<" }, "Path$ebnf$1", "Mailbox", { "literal": ">" }] },\n        { "name": "A_d_l$ebnf$1", "symbols": [] },\n        { "name": "A_d_l$ebnf$1$subexpression$1", "symbols": [{ "literal": "," }, "At_domain"] },\n        { "name": "A_d_l$ebnf$1", "symbols": ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "A_d_l", "symbols": ["At_domain", "A_d_l$ebnf$1"] },\n        { "name": "At_domain", "symbols": [{ "literal": "@" }, "Domain"] },\n        { "name": "Domain$ebnf$1", "symbols": [] },\n        { "name": "Domain$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "sub_domain"] },\n        { "name": "Domain$ebnf$1", "symbols": ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Domain", "symbols": ["sub_domain", "Domain$ebnf$1"] },\n        { "name": "sub_domain", "symbols": ["U_label"] },\n        { "name": "Let_dig", "symbols": ["ALPHA_DIGIT"], "postprocess": id },\n        { "name": "Ldh_str$ebnf$1", "symbols": [] },\n        { "name": "Ldh_str$ebnf$1", "symbols": ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Ldh_str", "symbols": ["Ldh_str$ebnf$1", "Let_dig"] },\n        { "name": "U_Let_dig", "symbols": ["ALPHA_DIGIT_U"], "postprocess": id },\n        { "name": "U_Ldh_str$ebnf$1", "symbols": [] },\n        { "name": "U_Ldh_str$ebnf$1", "symbols": ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "U_Ldh_str", "symbols": ["U_Ldh_str$ebnf$1", "U_Let_dig"] },\n        { "name": "U_label$ebnf$1$subexpression$1", "symbols": ["U_Ldh_str"] },\n        { "name": "U_label$ebnf$1", "symbols": ["U_label$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "U_label$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "U_label", "symbols": ["U_Let_dig", "U_label$ebnf$1"] },\n        { "name": "address_literal$subexpression$1", "symbols": ["IPv4_address_literal"] },\n        { "name": "address_literal$subexpression$1", "symbols": ["IPv6_address_literal"] },\n        { "name": "address_literal$subexpression$1", "symbols": ["General_address_literal"] },\n        { "name": "address_literal", "symbols": [{ "literal": "[" }, "address_literal$subexpression$1", { "literal": "]" }] },\n        { "name": "non_local_part", "symbols": ["Domain"], "postprocess": function (d) {\n                return { DomainName: flat_string(d[0]) };\n            }\n        },\n        { "name": "non_local_part", "symbols": ["address_literal"], "postprocess": function (d) {\n                return { AddressLiteral: flat_string(d[0]) };\n            }\n        },\n        { "name": "Mailbox", "symbols": ["Local_part", { "literal": "@" }, "non_local_part"], "postprocess": function (d) {\n                return { localPart: flat_string(d[0]), domainPart: flat_string(d[2]) };\n            }\n        },\n        { "name": "Local_part", "symbols": ["Dot_string"], "postprocess": function (d) {\n                return { DotString: flat_string(d[0]) };\n            }\n        },\n        { "name": "Local_part", "symbols": ["Quoted_string"], "postprocess": function (d) {\n                return { QuotedString: flat_string(d[0]) };\n            }\n        },\n        { "name": "Dot_string$ebnf$1", "symbols": [] },\n        { "name": "Dot_string$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "Atom"] },\n        { "name": "Dot_string$ebnf$1", "symbols": ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Dot_string", "symbols": ["Atom", "Dot_string$ebnf$1"] },\n        { "name": "Atom$ebnf$1", "symbols": [/[0-9A-Za-z!#$%&\'*+\\-/=?^_`{|}~\\u0080-\\uFFFF/]/] },\n        { "name": "Atom$ebnf$1", "symbols": ["Atom$ebnf$1", /[0-9A-Za-z!#$%&\'*+\\-/=?^_`{|}~\\u0080-\\uFFFF/]/], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Atom", "symbols": ["Atom$ebnf$1"] },\n        { "name": "Quoted_string$ebnf$1", "symbols": [] },\n        { "name": "Quoted_string$ebnf$1", "symbols": ["Quoted_string$ebnf$1", "QcontentSMTP"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Quoted_string", "symbols": ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },\n        { "name": "QcontentSMTP", "symbols": ["qtextSMTP"] },\n        { "name": "QcontentSMTP", "symbols": ["quoted_pairSMTP"] },\n        { "name": "quoted_pairSMTP", "symbols": [{ "literal": "\\\\" }, /[\\x20-\\x7e]/] },\n        { "name": "qtextSMTP", "symbols": [/[\\x20-\\x21\\x23-\\x5b\\x5d-\\x7e\\u0080-\\uFFFF]/], "postprocess": id },\n        { "name": "IPv4_address_literal$macrocall$2", "symbols": [{ "literal": "." }, "Snum"] },\n        { "name": "IPv4_address_literal$macrocall$1", "symbols": ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },\n        { "name": "IPv4_address_literal", "symbols": ["Snum", "IPv4_address_literal$macrocall$1"] },\n        { "name": "IPv6_address_literal$subexpression$1", "symbols": [/[iI]/, /[pP]/, /[vV]/, { "literal": "6" }, { "literal": ":" }], "postprocess": function (d) { return d.join(""); } },\n        { "name": "IPv6_address_literal", "symbols": ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },\n        { "name": "General_address_literal$ebnf$1", "symbols": ["dcontent"] },\n        { "name": "General_address_literal$ebnf$1", "symbols": ["General_address_literal$ebnf$1", "dcontent"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "General_address_literal", "symbols": ["Standardized_tag", { "literal": ":" }, "General_address_literal$ebnf$1"] },\n        { "name": "Standardized_tag", "symbols": ["Ldh_str"] },\n        { "name": "dcontent", "symbols": [/[\\x21-\\x5a\\x5e-\\x7e]/], "postprocess": id },\n        { "name": "Snum", "symbols": ["DIGIT"] },\n        { "name": "Snum$subexpression$1", "symbols": [/[1-9]/, "DIGIT"] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$1"] },\n        { "name": "Snum$subexpression$2", "symbols": [{ "literal": "1" }, "DIGIT", "DIGIT"] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$2"] },\n        { "name": "Snum$subexpression$3", "symbols": [{ "literal": "2" }, /[0-4]/, "DIGIT"] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$3"] },\n        { "name": "Snum$subexpression$4", "symbols": [{ "literal": "2" }, { "literal": "5" }, /[0-5]/] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$4"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6_full"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6_comp"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6v4_full"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6v4_comp"] },\n        { "name": "IPv6_hex", "symbols": ["HEXDIG"] },\n        { "name": "IPv6_hex$subexpression$1", "symbols": ["HEXDIG", "HEXDIG"] },\n        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$1"] },\n        { "name": "IPv6_hex$subexpression$2", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG"] },\n        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$2"] },\n        { "name": "IPv6_hex$subexpression$3", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },\n        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$3"] },\n        { "name": "IPv6_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6_full$macrocall$1", "symbols": ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },\n        { "name": "IPv6_full", "symbols": ["IPv6_hex", "IPv6_full$macrocall$1"] },\n        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },\n        { "name": "IPv6_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },\n        { "name": "IPv6_comp$ebnf$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "IPv6_comp$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join(\'\') },\n        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },\n        { "name": "IPv6_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },\n        { "name": "IPv6_comp$ebnf$2", "symbols": ["IPv6_comp$ebnf$2$subexpression$1"], "postprocess": id },\n        { "name": "IPv6_comp$ebnf$2", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6_comp", "symbols": ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },\n        { "name": "IPv6v4_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6v4_full$macrocall$1", "symbols": ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },\n        { "name": "IPv6v4_full", "symbols": ["IPv6_hex", "IPv6v4_full$macrocall$1", { "literal": ":" }, "IPv4_address_literal"] },\n        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },\n        { "name": "IPv6v4_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },\n        { "name": "IPv6v4_comp$ebnf$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "IPv6v4_comp$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6v4_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join(\'\') },\n        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },\n        { "name": "IPv6v4_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { "literal": ":" }] },\n        { "name": "IPv6v4_comp$ebnf$2", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1"], "postprocess": id },\n        { "name": "IPv6v4_comp$ebnf$2", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6v4_comp", "symbols": ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },\n        { "name": "DIGIT", "symbols": [/[0-9]/], "postprocess": id },\n        { "name": "ALPHA_DIGIT_U", "symbols": [/[0-9A-Za-z\\u0080-\\uFFFF]/], "postprocess": id },\n        { "name": "ALPHA_DIGIT", "symbols": [/[0-9A-Za-z]/], "postprocess": id },\n        { "name": "ALPHA_DIG_DASH", "symbols": [/[-0-9A-Za-z]/], "postprocess": id },\n        { "name": "ALPHA_DIG_DASH_U", "symbols": [/[-0-9A-Za-z\\u0080-\\uFFFF]/], "postprocess": id },\n        { "name": "HEXDIG", "symbols": [/[0-9A-Fa-f]/], "postprocess": id },\n        { "name": "DQUOTE", "symbols": [{ "literal": "\\"" }], "postprocess": id }\n    ],\n    ParserStart: "Reverse_path",\n};\nexports["default"] = grammar;\n//# sourceMappingURL=grammar.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ2pILFVBQVUsNk5BQTZOO0FBQ3ZPLFVBQVUseUhBQXlIO0FBQ25JLFVBQVUsb0dBQW9HO0FBQzlHLFVBQVUsd0VBQXdFO0FBQ2xGLFVBQVUsOENBQThDLGdCQUFnQixJQUFJLGdCQUFnQixxQ0FBcUM7QUFDakksVUFBVSx3RUFBd0UsZ0JBQWdCLGVBQWU7QUFDakgsVUFBVSw2TkFBNk47QUFDdk8sVUFBVSwwSEFBMEgsZ0JBQWdCLEdBQUc7QUFDdkosVUFBVSxvR0FBb0c7QUFDOUcsVUFBVSx3RUFBd0U7QUFDbEYsVUFBVSxnSUFBZ0k7QUFDMUksVUFBVSwwREFBMEQ7QUFDcEUsVUFBVSxxRkFBcUY7QUFDL0YsVUFBVSxzRUFBc0U7QUFDaEYsVUFBVSwwRUFBMEU7QUFDcEYsVUFBVSx5RkFBeUY7QUFDbkcsVUFBVSxpRUFBaUU7QUFDM0UsVUFBVSxnQ0FBZ0MsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvc210cC1hZGRyZXNzLXBhcnNlci9kaXN0L2xpYi9ncmFtbWFyLmpzP2Y5NzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBuZWFybGV5LCB2ZXJzaW9uIDIuMjAuMVxuLy8gaHR0cDovL2dpdGh1Yi5jb20vSGFyZG1hdGgxMjMvbmVhcmxleVxuLy8gQnlwYXNzZXMgVFM2MTMzLiBBbGxvdyBkZWNsYXJlZCBidXQgdW51c2VkIGZ1bmN0aW9ucy5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGlkKGQpIHsgcmV0dXJuIGRbMF07IH1cbmNvbnN0IGRlZXBGbGF0dGVuID0gKGFycikgPT4gW10uY29uY2F0KC4uLmFyci5tYXAoKHYpID0+IChBcnJheS5pc0FycmF5KHYpID8gZGVlcEZsYXR0ZW4odikgOiB2KSkpO1xuZnVuY3Rpb24gZmxhdF9zdHJpbmcoZCkge1xuICAgIGlmIChkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlZXBGbGF0dGVuKGQpLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbjtcbjtcbjtcbjtcbmNvbnN0IGdyYW1tYXIgPSB7XG4gICAgTGV4ZXI6IHVuZGVmaW5lZCxcbiAgICBQYXJzZXJSdWxlczogW1xuICAgICAgICB7IFwibmFtZVwiOiBcIlJldmVyc2VfcGF0aFwiLCBcInN5bWJvbHNcIjogW1wiUGF0aFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlJldmVyc2VfcGF0aCRzdHJpbmckMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiPFwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiPlwiIH1dLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkLmpvaW4oJycpIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUmV2ZXJzZV9wYXRoXCIsIFwic3ltYm9sc1wiOiBbXCJSZXZlcnNlX3BhdGgkc3RyaW5nJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJGb3J3YXJkX3BhdGgkc3ViZXhwcmVzc2lvbiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiPFwiIH0sIC9bcFBdLywgL1tvT10vLCAvW3NTXS8sIC9bdFRdLywgL1ttTV0vLCAvW2FBXS8sIC9bc1NdLywgL1t0VF0vLCAvW2VFXS8sIC9bclJdLywgeyBcImxpdGVyYWxcIjogXCJAXCIgfV0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuam9pbihcIlwiKTsgfSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkZvcndhcmRfcGF0aCRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkZvcndhcmRfcGF0aCRzdWJleHByZXNzaW9uJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwiRG9tYWluXCIsIHsgXCJsaXRlcmFsXCI6IFwiPlwiIH1dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiRm9yd2FyZF9wYXRoXCIsIFwic3ltYm9sc1wiOiBbXCJGb3J3YXJkX3BhdGgkc3ViZXhwcmVzc2lvbiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiRm9yd2FyZF9wYXRoJHN1YmV4cHJlc3Npb24kMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiPFwiIH0sIC9bcFBdLywgL1tvT10vLCAvW3NTXS8sIC9bdFRdLywgL1ttTV0vLCAvW2FBXS8sIC9bc1NdLywgL1t0VF0vLCAvW2VFXS8sIC9bclJdLywgeyBcImxpdGVyYWxcIjogXCI+XCIgfV0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuam9pbihcIlwiKTsgfSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkZvcndhcmRfcGF0aFwiLCBcInN5bWJvbHNcIjogW1wiRm9yd2FyZF9wYXRoJHN1YmV4cHJlc3Npb24kMlwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkZvcndhcmRfcGF0aFwiLCBcInN5bWJvbHNcIjogW1wiUGF0aFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlBhdGgkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wiQV9kX2xcIiwgeyBcImxpdGVyYWxcIjogXCI6XCIgfV0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJQYXRoJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiUGF0aCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUGF0aCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJQYXRoXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI8XCIgfSwgXCJQYXRoJGVibmYkMVwiLCBcIk1haWxib3hcIiwgeyBcImxpdGVyYWxcIjogXCI+XCIgfV0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBX2RfbCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQV9kX2wkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiLFwiIH0sIFwiQXRfZG9tYWluXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQV9kX2wkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJBX2RfbCRlYm5mJDFcIiwgXCJBX2RfbCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkWzBdLmNvbmNhdChbZFsxXV0pIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQV9kX2xcIiwgXCJzeW1ib2xzXCI6IFtcIkF0X2RvbWFpblwiLCBcIkFfZF9sJGVibmYkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkF0X2RvbWFpblwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiQFwiIH0sIFwiRG9tYWluXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiRG9tYWluJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJEb21haW4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiLlwiIH0sIFwic3ViX2RvbWFpblwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvbWFpbiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkRvbWFpbiRlYm5mJDFcIiwgXCJEb21haW4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvbWFpblwiLCBcInN5bWJvbHNcIjogW1wic3ViX2RvbWFpblwiLCBcIkRvbWFpbiRlYm5mJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJzdWJfZG9tYWluXCIsIFwic3ltYm9sc1wiOiBbXCJVX2xhYmVsXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiTGV0X2RpZ1wiLCBcInN5bWJvbHNcIjogW1wiQUxQSEFfRElHSVRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJMZGhfc3RyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJMZGhfc3RyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiTGRoX3N0ciRlYm5mJDFcIiwgXCJBTFBIQV9ESUdfREFTSFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkxkaF9zdHJcIiwgXCJzeW1ib2xzXCI6IFtcIkxkaF9zdHIkZWJuZiQxXCIsIFwiTGV0X2RpZ1wiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfTGV0X2RpZ1wiLCBcInN5bWJvbHNcIjogW1wiQUxQSEFfRElHSVRfVVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfTGRoX3N0ciRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiVV9MZGhfc3RyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiVV9MZGhfc3RyJGVibmYkMVwiLCBcIkFMUEhBX0RJR19EQVNIX1VcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSkgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJVX0xkaF9zdHJcIiwgXCJzeW1ib2xzXCI6IFtcIlVfTGRoX3N0ciRlYm5mJDFcIiwgXCJVX0xldF9kaWdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJVX2xhYmVsJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIlVfTGRoX3N0clwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfbGFiZWwkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJVX2xhYmVsJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJVX2xhYmVsJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gbnVsbCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfbGFiZWxcIiwgXCJzeW1ib2xzXCI6IFtcIlVfTGV0X2RpZ1wiLCBcIlVfbGFiZWwkZWJuZiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiYWRkcmVzc19saXRlcmFsJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wiSVB2NF9hZGRyZXNzX2xpdGVyYWxcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJhZGRyZXNzX2xpdGVyYWwkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2FkZHJlc3NfbGl0ZXJhbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcImFkZHJlc3NfbGl0ZXJhbCRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkdlbmVyYWxfYWRkcmVzc19saXRlcmFsXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiYWRkcmVzc19saXRlcmFsXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCJbXCIgfSwgXCJhZGRyZXNzX2xpdGVyYWwkc3ViZXhwcmVzc2lvbiQxXCIsIHsgXCJsaXRlcmFsXCI6IFwiXVwiIH1dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwibm9uX2xvY2FsX3BhcnRcIiwgXCJzeW1ib2xzXCI6IFtcIkRvbWFpblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IERvbWFpbk5hbWU6IGZsYXRfc3RyaW5nKGRbMF0pIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwibm9uX2xvY2FsX3BhcnRcIiwgXCJzeW1ib2xzXCI6IFtcImFkZHJlc3NfbGl0ZXJhbFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IEFkZHJlc3NMaXRlcmFsOiBmbGF0X3N0cmluZyhkWzBdKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIk1haWxib3hcIiwgXCJzeW1ib2xzXCI6IFtcIkxvY2FsX3BhcnRcIiwgeyBcImxpdGVyYWxcIjogXCJAXCIgfSwgXCJub25fbG9jYWxfcGFydFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGxvY2FsUGFydDogZmxhdF9zdHJpbmcoZFswXSksIGRvbWFpblBhcnQ6IGZsYXRfc3RyaW5nKGRbMl0pIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiTG9jYWxfcGFydFwiLCBcInN5bWJvbHNcIjogW1wiRG90X3N0cmluZ1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IERvdFN0cmluZzogZmxhdF9zdHJpbmcoZFswXSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJMb2NhbF9wYXJ0XCIsIFwic3ltYm9sc1wiOiBbXCJRdW90ZWRfc3RyaW5nXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgUXVvdGVkU3RyaW5nOiBmbGF0X3N0cmluZyhkWzBdKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmckZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmckZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiLlwiIH0sIFwiQXRvbVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmckZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJEb3Rfc3RyaW5nJGVibmYkMVwiLCBcIkRvdF9zdHJpbmckZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmdcIiwgXCJzeW1ib2xzXCI6IFtcIkF0b21cIiwgXCJEb3Rfc3RyaW5nJGVibmYkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkF0b20kZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbL1swLTlBLVphLXohIyQlJicqK1xcLS89P15fYHt8fX5cXHUwMDgwLVxcdUZGRkYvXS9dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQXRvbSRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkF0b20kZWJuZiQxXCIsIC9bMC05QS1aYS16ISMkJSYnKitcXC0vPT9eX2B7fH1+XFx1MDA4MC1cXHVGRkZGL10vXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkF0b21cIiwgXCJzeW1ib2xzXCI6IFtcIkF0b20kZWJuZiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUXVvdGVkX3N0cmluZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUXVvdGVkX3N0cmluZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIlF1b3RlZF9zdHJpbmckZWJuZiQxXCIsIFwiUWNvbnRlbnRTTVRQXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkWzBdLmNvbmNhdChbZFsxXV0pIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUXVvdGVkX3N0cmluZ1wiLCBcInN5bWJvbHNcIjogW1wiRFFVT1RFXCIsIFwiUXVvdGVkX3N0cmluZyRlYm5mJDFcIiwgXCJEUVVPVEVcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJRY29udGVudFNNVFBcIiwgXCJzeW1ib2xzXCI6IFtcInF0ZXh0U01UUFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlFjb250ZW50U01UUFwiLCBcInN5bWJvbHNcIjogW1wicXVvdGVkX3BhaXJTTVRQXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwicXVvdGVkX3BhaXJTTVRQXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCJcXFxcXCIgfSwgL1tcXHgyMC1cXHg3ZV0vXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcInF0ZXh0U01UUFwiLCBcInN5bWJvbHNcIjogWy9bXFx4MjAtXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXFx1MDA4MC1cXHVGRkZGXS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NF9hZGRyZXNzX2xpdGVyYWwkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIi5cIiB9LCBcIlNudW1cIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiSVB2NF9hZGRyZXNzX2xpdGVyYWwkbWFjcm9jYWxsJDJcIiwgXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbCRtYWNyb2NhbGwkMlwiLCBcIklQdjRfYWRkcmVzc19saXRlcmFsJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NF9hZGRyZXNzX2xpdGVyYWxcIiwgXCJzeW1ib2xzXCI6IFtcIlNudW1cIiwgXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbCRtYWNyb2NhbGwkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfYWRkcmVzc19saXRlcmFsJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogWy9baUldLywgL1twUF0vLCAvW3ZWXS8sIHsgXCJsaXRlcmFsXCI6IFwiNlwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiOlwiIH1dLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmpvaW4oXCJcIik7IH0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2FkZHJlc3NfbGl0ZXJhbFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9hZGRyZXNzX2xpdGVyYWwkc3ViZXhwcmVzc2lvbiQxXCIsIFwiSVB2Nl9hZGRyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiR2VuZXJhbF9hZGRyZXNzX2xpdGVyYWwkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJkY29udGVudFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkdlbmVyYWxfYWRkcmVzc19saXRlcmFsJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiR2VuZXJhbF9hZGRyZXNzX2xpdGVyYWwkZWJuZiQxXCIsIFwiZGNvbnRlbnRcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSkgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJHZW5lcmFsX2FkZHJlc3NfbGl0ZXJhbFwiLCBcInN5bWJvbHNcIjogW1wiU3RhbmRhcmRpemVkX3RhZ1wiLCB7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCBcIkdlbmVyYWxfYWRkcmVzc19saXRlcmFsJGVibmYkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlN0YW5kYXJkaXplZF90YWdcIiwgXCJzeW1ib2xzXCI6IFtcIkxkaF9zdHJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJkY29udGVudFwiLCBcInN5bWJvbHNcIjogWy9bXFx4MjEtXFx4NWFcXHg1ZS1cXHg3ZV0vXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlNudW1cIiwgXCJzeW1ib2xzXCI6IFtcIkRJR0lUXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFsvWzEtOV0vLCBcIkRJR0lUXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bVwiLCBcInN5bWJvbHNcIjogW1wiU251bSRzdWJleHByZXNzaW9uJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJTbnVtJHN1YmV4cHJlc3Npb24kMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiMVwiIH0sIFwiRElHSVRcIiwgXCJESUdJVFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlNudW1cIiwgXCJzeW1ib2xzXCI6IFtcIlNudW0kc3ViZXhwcmVzc2lvbiQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bSRzdWJleHByZXNzaW9uJDNcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIjJcIiB9LCAvWzAtNF0vLCBcIkRJR0lUXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bVwiLCBcInN5bWJvbHNcIjogW1wiU251bSRzdWJleHByZXNzaW9uJDNcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJTbnVtJHN1YmV4cHJlc3Npb24kNFwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiMlwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiNVwiIH0sIC9bMC01XS9dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bVwiLCBcInN5bWJvbHNcIjogW1wiU251bSRzdWJleHByZXNzaW9uJDRcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2FkZHJcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfZnVsbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfYWRkclwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9jb21wXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9hZGRyXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2djRfZnVsbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfYWRkclwiLCBcInN5bWJvbHNcIjogW1wiSVB2NnY0X2NvbXBcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSEVYRElHXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJIRVhESUdcIiwgXCJIRVhESUdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQyXCIsIFwic3ltYm9sc1wiOiBbXCJIRVhESUdcIiwgXCJIRVhESUdcIiwgXCJIRVhESUdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQzXCIsIFwic3ltYm9sc1wiOiBbXCJIRVhESUdcIiwgXCJIRVhESUdcIiwgXCJIRVhESUdcIiwgXCJIRVhESUdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQzXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI6XCIgfSwgXCJJUHY2X2hleFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfZnVsbCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9mdWxsXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2hleFwiLCBcIklQdjZfZnVsbCRtYWNyb2NhbGwkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI6XCIgfSwgXCJJUHY2X2hleFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJJUHY2X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfaGV4XCIsIFwiSVB2Nl9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXAkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXAkc3RyaW5nJDFcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCB7IFwibGl0ZXJhbFwiOiBcIjpcIiB9XSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZC5qb2luKCcnKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI6XCIgfSwgXCJJUHY2X2hleFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJJUHY2X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfaGV4XCIsIFwiSVB2Nl9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXAkZWJuZiQyXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXBcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfY29tcCRlYm5mJDFcIiwgXCJJUHY2X2NvbXAkc3RyaW5nJDFcIiwgXCJJUHY2X2NvbXAkZWJuZiQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCBcIklQdjZfaGV4XCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZ2NF9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDJcIiwgXCJJUHY2djRfZnVsbCRtYWNyb2NhbGwkMlwiLCBcIklQdjZ2NF9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfZnVsbFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXhcIiwgXCJJUHY2djRfZnVsbCRtYWNyb2NhbGwkMVwiLCB7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCBcIklQdjRfYWRkcmVzc19saXRlcmFsXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiOlwiIH0sIFwiSVB2Nl9oZXhcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2djRfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZ2NF9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2hleFwiLCBcIklQdjZ2NF9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZ2NF9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRzdHJpbmckMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiOlwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiOlwiIH1dLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkLmpvaW4oJycpIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiOlwiIH0sIFwiSVB2Nl9oZXhcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2djRfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZ2NF9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2hleFwiLCBcIklQdjZ2NF9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgeyBcImxpdGVyYWxcIjogXCI6XCIgfV0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZ2NF9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcFwiLCBcInN5bWJvbHNcIjogW1wiSVB2NnY0X2NvbXAkZWJuZiQxXCIsIFwiSVB2NnY0X2NvbXAkc3RyaW5nJDFcIiwgXCJJUHY2djRfY29tcCRlYm5mJDJcIiwgXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRJR0lUXCIsIFwic3ltYm9sc1wiOiBbL1swLTldL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9ESUdJVF9VXCIsIFwic3ltYm9sc1wiOiBbL1swLTlBLVphLXpcXHUwMDgwLVxcdUZGRkZdL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9ESUdJVFwiLCBcInN5bWJvbHNcIjogWy9bMC05QS1aYS16XS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQUxQSEFfRElHX0RBU0hcIiwgXCJzeW1ib2xzXCI6IFsvWy0wLTlBLVphLXpdL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9ESUdfREFTSF9VXCIsIFwic3ltYm9sc1wiOiBbL1stMC05QS1aYS16XFx1MDA4MC1cXHVGRkZGXS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSEVYRElHXCIsIFwic3ltYm9sc1wiOiBbL1swLTlBLUZhLWZdL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJEUVVPVEVcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIlxcXCJcIiB9XSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9XG4gICAgXSxcbiAgICBQYXJzZXJTdGFydDogXCJSZXZlcnNlX3BhdGhcIixcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBncmFtbWFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhbW1hci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2084\n')},2546:function(module){eval('!function(e,t){ true?module.exports=t():0}("undefined"!=typeof self?self:this,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};function n(e){return"#"===e||""===e||Array.isArray(e)&&0===e.length||!1}e.r(t),e.d(t,{default:()=>S,get:()=>c,isRoot:()=>n,join:()=>_,remove:()=>j,removeUndefinedItems:()=>v,set:()=>y,split:()=>s,splitLast:()=>x});const r=/~1/g,o=/~0/g,i=/\\/+/g,l=/(^[#/]*|\\/+$)/g;function u(e){return e.replace(r,"/").replace(o,"~")}function f(e){return u(decodeURIComponent(e))}function s(e){if(null==e||"string"!=typeof e||n(e))return Array.isArray(e)?e:[];const t=e.indexOf("#")>=0?f:u,r=(e=(e=e.replace(i,"/")).replace(l,"")).split("/");for(let e=0,n=r.length;e<n;e+=1)r[e]=t(r[e]);return r}function c(e,t,r=void 0){if(null==t||null==e)return r;if(n(t))return e;const o=p(e,s(t));return void 0===o?r:o}function p(e,t){const n=t.shift();if(void 0!==e)return void 0!==n?p(e[n],t):e}const a=/^\\[.*\\]$/,d=/^\\[(.+)\\]$/;function g(e,t){return"__proto__"===e||"constructor"==e&&t.length>0&&"prototype"==t[0]}function y(e,t,n){if(null==t)return e;const r=s(t);if(0===r.length)return e;null==e&&(e=a.test(r[0])?[]:{});let o,i,l=e;for(;r.length>1;)o=r.shift(),i=a.test(r[0]),g(o,r)||(l=m(l,o,i));return o=r.pop(),h(l,o,n),e}function h(e,t,n){let r;const o=t.match(d);"[]"===t&&Array.isArray(e)?e.push(n):o?(r=o.pop(),e[r]=n):e[t]=n}function m(e,t,n){if(null!=e[t])return e[t];const r=n?[]:{};return h(e,t,r),r}function v(e){let t=0,n=0;for(;t+n<e.length;)void 0===e[t+n]&&(n+=1),e[t]=e[t+n],t+=1;return e.length=e.length-n,e}function j(e,t,n){const r=s(t),o=r.pop(),i=c(e,r);return i&&delete i[o],Array.isArray(i)&&!0!==n&&v(i),e}const b=/\\/+/g,A=/~/g,P=/\\//g;function O(e,t){if(0===e.length)return t?"#":"";for(let n=0,r=e.length;n<r;n+=1)e[n]=e[n].replace(A,"~0").replace(P,"~1"),t&&(e[n]=encodeURIComponent(e[n]));return((t?"#/":"/")+e.join("/")).replace(b,"/")}function _(e,...t){const n=[];if(Array.isArray(e))return O(e,!0===arguments[1]);const r=arguments[arguments.length-1],o="boolean"==typeof r?r:e&&"#"===e[0];for(let e=0,t=arguments.length;e<t;e+=1)n.push.apply(n,s(arguments[e]));const i=[];for(let e=0,t=n.length;e<t;e+=1)if(".."===n[e]){if(0===i.length)return o?"#":"";i.pop()}else i.push(n[e]);return O(i,o)}function x(e){const t=s(e);if(0===t.length)return"string"==typeof e&&"#"===e[0]?["#",t[0]]:["",void 0];if(1===t.length)return"#"===e[0]?["#",t[0]]:["",t[0]];const n=t.pop();return[_(t,"#"===e[0]),n]}const S={get:c,set:y,remove:j,join:_,split:s,splitLast:x,isRoot:n,removeUndefinedItems:v};return t})()));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU0Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUFtSSxDQUFDLCtDQUErQyxhQUFhLE9BQU8sVUFBVSwrREFBK0QsdUJBQXVCLEVBQUUsMERBQTBELDRGQUE0RixlQUFlLHdDQUF3QyxTQUFTLEdBQUcsTUFBTSxjQUFjLDBEQUEwRCxjQUFjLDhIQUE4SCxFQUFFLGtEQUFrRCxjQUFjLHVDQUF1QyxjQUFjLGdDQUFnQyxjQUFjLGtFQUFrRSxrRkFBa0YsdUJBQXVCLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLDZCQUE2QixpQkFBaUIsa0JBQWtCLHNCQUFzQixnQkFBZ0Isa0JBQWtCLDRDQUE0QyxrQ0FBa0MsZ0JBQWdCLHVFQUF1RSxrQkFBa0Isb0JBQW9CLGFBQWEseUJBQXlCLDhCQUE4QixFQUFFLFlBQVksS0FBSyxXQUFXLGlEQUFpRCw0QkFBNEIsa0JBQWtCLE1BQU0sbUJBQW1CLGlFQUFpRSxrQkFBa0IsMEJBQTBCLGdCQUFnQixrQkFBa0IsY0FBYyxZQUFZLEtBQUssYUFBYSwwQ0FBMEMsNkJBQTZCLGtCQUFrQixnQ0FBZ0MsdURBQXVELDhCQUE4QixnQkFBZ0IsZ0NBQWdDLHVCQUF1QixJQUFJLGtGQUFrRixnREFBZ0QsbUJBQW1CLFdBQVcsa0RBQWtELDRFQUE0RSwrQkFBK0IsSUFBSSxxQ0FBcUMsV0FBVyx1QkFBdUIsSUFBSSxxQkFBcUIsZ0NBQWdDLFFBQVEsa0JBQWtCLGNBQWMsY0FBYyxhQUFhLDRFQUE0RSxzREFBc0QsZ0JBQWdCLDBCQUEwQixTQUFTLGlGQUFpRixTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzYWdvbGQvanNvbi1wb2ludGVyL2Rpc3QvanNvblBvaW50ZXIuanM/MzZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImpzb25Qb2ludGVyXCIsW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5qc29uUG9pbnRlcj10KCk6ZS5qc29uUG9pbnRlcj10KCl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcywoKCk9PigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOih0LG4pPT57Zm9yKHZhciByIGluIG4pZS5vKG4scikmJiFlLm8odCxyKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscix7ZW51bWVyYWJsZTohMCxnZXQ6bltyXX0pfSxvOihlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sdD17fTtmdW5jdGlvbiBuKGUpe3JldHVyblwiI1wiPT09ZXx8XCJcIj09PWV8fEFycmF5LmlzQXJyYXkoZSkmJjA9PT1lLmxlbmd0aHx8ITF9ZS5yKHQpLGUuZCh0LHtkZWZhdWx0OigpPT5TLGdldDooKT0+Yyxpc1Jvb3Q6KCk9Pm4sam9pbjooKT0+XyxyZW1vdmU6KCk9PmoscmVtb3ZlVW5kZWZpbmVkSXRlbXM6KCk9PnYsc2V0OigpPT55LHNwbGl0OigpPT5zLHNwbGl0TGFzdDooKT0+eH0pO2NvbnN0IHI9L34xL2csbz0vfjAvZyxpPS9cXC8rL2csbD0vKF5bIy9dKnxcXC8rJCkvZztmdW5jdGlvbiB1KGUpe3JldHVybiBlLnJlcGxhY2UocixcIi9cIikucmVwbGFjZShvLFwiflwiKX1mdW5jdGlvbiBmKGUpe3JldHVybiB1KGRlY29kZVVSSUNvbXBvbmVudChlKSl9ZnVuY3Rpb24gcyhlKXtpZihudWxsPT1lfHxcInN0cmluZ1wiIT10eXBlb2YgZXx8bihlKSlyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lOltdO2NvbnN0IHQ9ZS5pbmRleE9mKFwiI1wiKT49MD9mOnUscj0oZT0oZT1lLnJlcGxhY2UoaSxcIi9cIikpLnJlcGxhY2UobCxcIlwiKSkuc3BsaXQoXCIvXCIpO2ZvcihsZXQgZT0wLG49ci5sZW5ndGg7ZTxuO2UrPTEpcltlXT10KHJbZV0pO3JldHVybiByfWZ1bmN0aW9uIGMoZSx0LHI9dm9pZCAwKXtpZihudWxsPT10fHxudWxsPT1lKXJldHVybiByO2lmKG4odCkpcmV0dXJuIGU7Y29uc3Qgbz1wKGUscyh0KSk7cmV0dXJuIHZvaWQgMD09PW8/cjpvfWZ1bmN0aW9uIHAoZSx0KXtjb25zdCBuPXQuc2hpZnQoKTtpZih2b2lkIDAhPT1lKXJldHVybiB2b2lkIDAhPT1uP3AoZVtuXSx0KTplfWNvbnN0IGE9L15cXFsuKlxcXSQvLGQ9L15cXFsoLispXFxdJC87ZnVuY3Rpb24gZyhlLHQpe3JldHVyblwiX19wcm90b19fXCI9PT1lfHxcImNvbnN0cnVjdG9yXCI9PWUmJnQubGVuZ3RoPjAmJlwicHJvdG90eXBlXCI9PXRbMF19ZnVuY3Rpb24geShlLHQsbil7aWYobnVsbD09dClyZXR1cm4gZTtjb25zdCByPXModCk7aWYoMD09PXIubGVuZ3RoKXJldHVybiBlO251bGw9PWUmJihlPWEudGVzdChyWzBdKT9bXTp7fSk7bGV0IG8saSxsPWU7Zm9yKDtyLmxlbmd0aD4xOylvPXIuc2hpZnQoKSxpPWEudGVzdChyWzBdKSxnKG8scil8fChsPW0obCxvLGkpKTtyZXR1cm4gbz1yLnBvcCgpLGgobCxvLG4pLGV9ZnVuY3Rpb24gaChlLHQsbil7bGV0IHI7Y29uc3Qgbz10Lm1hdGNoKGQpO1wiW11cIj09PXQmJkFycmF5LmlzQXJyYXkoZSk/ZS5wdXNoKG4pOm8/KHI9by5wb3AoKSxlW3JdPW4pOmVbdF09bn1mdW5jdGlvbiBtKGUsdCxuKXtpZihudWxsIT1lW3RdKXJldHVybiBlW3RdO2NvbnN0IHI9bj9bXTp7fTtyZXR1cm4gaChlLHQscikscn1mdW5jdGlvbiB2KGUpe2xldCB0PTAsbj0wO2Zvcig7dCtuPGUubGVuZ3RoOyl2b2lkIDA9PT1lW3Qrbl0mJihuKz0xKSxlW3RdPWVbdCtuXSx0Kz0xO3JldHVybiBlLmxlbmd0aD1lLmxlbmd0aC1uLGV9ZnVuY3Rpb24gaihlLHQsbil7Y29uc3Qgcj1zKHQpLG89ci5wb3AoKSxpPWMoZSxyKTtyZXR1cm4gaSYmZGVsZXRlIGlbb10sQXJyYXkuaXNBcnJheShpKSYmITAhPT1uJiZ2KGkpLGV9Y29uc3QgYj0vXFwvKy9nLEE9L34vZyxQPS9cXC8vZztmdW5jdGlvbiBPKGUsdCl7aWYoMD09PWUubGVuZ3RoKXJldHVybiB0P1wiI1wiOlwiXCI7Zm9yKGxldCBuPTAscj1lLmxlbmd0aDtuPHI7bis9MSllW25dPWVbbl0ucmVwbGFjZShBLFwifjBcIikucmVwbGFjZShQLFwifjFcIiksdCYmKGVbbl09ZW5jb2RlVVJJQ29tcG9uZW50KGVbbl0pKTtyZXR1cm4oKHQ/XCIjL1wiOlwiL1wiKStlLmpvaW4oXCIvXCIpKS5yZXBsYWNlKGIsXCIvXCIpfWZ1bmN0aW9uIF8oZSwuLi50KXtjb25zdCBuPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIE8oZSwhMD09PWFyZ3VtZW50c1sxXSk7Y29uc3Qgcj1hcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSxvPVwiYm9vbGVhblwiPT10eXBlb2Ygcj9yOmUmJlwiI1wiPT09ZVswXTtmb3IobGV0IGU9MCx0PWFyZ3VtZW50cy5sZW5ndGg7ZTx0O2UrPTEpbi5wdXNoLmFwcGx5KG4scyhhcmd1bWVudHNbZV0pKTtjb25zdCBpPVtdO2ZvcihsZXQgZT0wLHQ9bi5sZW5ndGg7ZTx0O2UrPTEpaWYoXCIuLlwiPT09bltlXSl7aWYoMD09PWkubGVuZ3RoKXJldHVybiBvP1wiI1wiOlwiXCI7aS5wb3AoKX1lbHNlIGkucHVzaChuW2VdKTtyZXR1cm4gTyhpLG8pfWZ1bmN0aW9uIHgoZSl7Y29uc3QgdD1zKGUpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmXCIjXCI9PT1lWzBdP1tcIiNcIix0WzBdXTpbXCJcIix2b2lkIDBdO2lmKDE9PT10Lmxlbmd0aClyZXR1cm5cIiNcIj09PWVbMF0/W1wiI1wiLHRbMF1dOltcIlwiLHRbMF1dO2NvbnN0IG49dC5wb3AoKTtyZXR1cm5bXyh0LFwiI1wiPT09ZVswXSksbl19Y29uc3QgUz17Z2V0OmMsc2V0OnkscmVtb3ZlOmosam9pbjpfLHNwbGl0OnMsc3BsaXRMYXN0OngsaXNSb290Om4scmVtb3ZlVW5kZWZpbmVkSXRlbXM6dn07cmV0dXJuIHR9KSgpKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2546\n')},4744:module=>{"use strict";eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc0NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanM/Njg2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4744\n")},6201:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Draft: () => (/* reexport */ Draft),\n  Draft04: () => (/* reexport */ Draft04),\n  Draft06: () => (/* reexport */ Draft06),\n  Draft07: () => (/* reexport */ Draft07),\n  JsonEditor: () => (/* reexport */ JsonEditor),\n  config: () => (/* binding */ config),\n  createCustomError: () => (/* reexport */ createCustomError),\n  createError: () => (/* reexport */ createError),\n  draft04Config: () => (/* reexport */ draft04Config),\n  draft06Config: () => (/* reexport */ draft06Config),\n  draft07Config: () => (/* reexport */ draft07Config),\n  draftJsonEditorConfig: () => (/* reexport */ draftJsonEditorConfig),\n  getTypeOf: () => (/* reexport */ getTypeOf),\n  isDynamicSchema: () => (/* reexport */ isDynamicSchema),\n  isJsonError: () => (/* reexport */ isJsonError),\n  mergeSchema: () => (/* reexport */ mergeSchema),\n  reduceSchema: () => (/* reexport */ reduceSchema),\n  render: () => (/* reexport */ render),\n  resolveAllOf: () => (/* reexport */ resolveAllOf),\n  resolveDynamicSchema: () => (/* reexport */ resolveDynamicSchema),\n  resolveOneOf: () => (/* reexport */ resolveOneOf),\n  resolveOneOfFuzzy: () => (/* reexport */ resolveOneOfFuzzy),\n  resolveRef: () => (/* reexport */ resolveRef),\n  resolveRefMerge: () => (/* reexport */ resolveRefMerge),\n  settings: () => (/* reexport */ settings),\n  validateAsync: () => (/* reexport */ validateAsync)\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/config/strings.js\n/* eslint max-len: 0 */\n/* harmony default export */ const strings = ({\n    // validation errors\n    AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",\n    AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",\n    AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",\n    AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",\n    ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",\n    containsAnyError: "The array at `{{pointer}}` must contain at least one item",\n    ContainsArrayError: "The property at `{{pointer}}` must not be an array",\n    ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",\n    EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",\n    ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",\n    FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",\n    FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",\n    FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",\n    FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",\n    FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",\n    FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",\n    FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",\n    FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",\n    FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",\n    FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",\n    FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",\n    FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",\n    FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",\n    FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",\n    FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",\n    InvalidDataError: "No value may be specified in `{{pointer}}`",\n    InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",\n    MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",\n    MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",\n    MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",\n    MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",\n    MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",\n    MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",\n    MinItemsOneError: "At least one item is required in `{{pointer}}`",\n    MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",\n    MinLengthOneError: "A value is required in `{{pointer}}`",\n    MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",\n    MissingDependencyError: "The required propery \'{{missingProperty}}\' in `{{pointer}}` is missing",\n    MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",\n    MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",\n    MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",\n    NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",\n    NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",\n    OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",\n    OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",\n    PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",\n    PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",\n    RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",\n    SchemaWarning: "Failed retrieving a schema from \'{{pointer}}\' to key \'{{key}}\'",\n    TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",\n    UndefinedValueError: "Value must not be undefined in `{{pointer}}`",\n    UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",\n    UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",\n    ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/getTypeOf.js\nconst getTypeOf_toString = Object.prototype.toString;\nfunction getTypeOf(value) {\n    const type = getTypeOf_toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === "file") {\n        return "object";\n    }\n    return type;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/render.js\n\nconst OBJECT_TYPE = "object";\nconst ARRAY_TYPE = "array";\n/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nfunction render(template, data = {}) {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, (match) => {\n        const key = match.replace(/[{}]/g, "");\n        const variable = data[key];\n        const variableType = getTypeOf(variable);\n        if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {\n            return JSON.stringify(variable);\n        }\n        return variable;\n    });\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/__.js\n\n\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nfunction __(keyword, data, fallback = keyword) {\n    var _a;\n    const template = (_a = strings[keyword]) !== null && _a !== void 0 ? _a : fallback;\n    return render(template, data);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js\n\nfunction dashCase(text) {\n    return text.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();\n}\nfunction createError(name, data) {\n    return {\n        type: "error",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n/**\n * Creates a custom Error Creator. Its messages are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nfunction createCustomError(name) {\n    return createError.bind(null, name);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js\nfunction flattenArray(list, result = []) {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/config/settings.js\n/* harmony default export */ const settings = ({\n    DECLARATOR_ONEOF: "oneOfProperty",\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    propertyBlacklist: ["_id"],\n    templateDefaultOptions: {\n        addOptionalProps: false,\n        removeInvalidData: false,\n        extendDefaults: true\n    }\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/schema/createOneOfSchemaResult.js\nfunction createOneOfSchemaResult(schema, oneOfSchema, oneOfIndex) {\n    const childSchema = { ...oneOfSchema };\n    Object.defineProperty(childSchema, "getOneOfOrigin", {\n        enumerable: false,\n        value: () => ({\n            index: oneOfIndex,\n            schema\n        })\n    });\n    return childSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/types.js\n/**\n * ts type guard for json error\n * @returns true if passed type is a JsonError\n */\nfunction isJsonError(error) {\n    return (error === null || error === void 0 ? void 0 : error.type) === "error";\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/filter.js\n\nfunction isPromise(obj) {\n    return obj instanceof Promise;\n}\nfunction errorOrPromise(error) {\n    return isJsonError(error) || isPromise(error);\n}\nfunction errorsOnly(error) {\n    return isJsonError(error);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/oneOf.js\n/**\n * @draft-04\n */\n\n\n\n\n\n\nconst { DECLARATOR_ONEOF } = settings;\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nfunction resolveOneOf(draft, data, schema = draft.rootSchema, pointer = "#") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);\n            if (isJsonError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return createOneOfSchemaResult(schema, one, i); // return resolved schema\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = draft.resolveRef(schema.oneOf[i]);\n        let result = flattenArray(draft.validate(data, one, pointer));\n        result = result.filter(errorOrPromise);\n        if (result.length > 0) {\n            errors.push(...result);\n        }\n        else {\n            matches.push({ index: i, schema: one });\n        }\n    }\n    if (matches.length === 1) {\n        return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index); // return resolved schema\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            schema,\n            matches\n        });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n/**\n * Returns a ranking for the data and given schema\n *\n * @param draft\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(draft, one, data, pointer) {\n    if (data == null || one.properties == null) {\n        return -1;\n    }\n    let value = 0;\n    const keys = Object.keys(one.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key] != null && draft.isValid(data[key], one.properties[key], pointer)) {\n            value += 1;\n        }\n    }\n    return value;\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nfunction resolveOneOfFuzzy(draft, data, schema = draft.rootSchema, pointer = "#") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);\n            if (isJsonError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return createOneOfSchemaResult(schema, one, i);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = draft.resolveRef(schema.oneOf[i]);\n        if (draft.isValid(data, one, pointer)) {\n            matches.push({ schema: one, index: i });\n        }\n    }\n    if (matches.length === 1) {\n        return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index);\n    }\n    // fuzzy match oneOf\n    if (getTypeOf(data) === "object") {\n        let schemaOfItem;\n        let schemaOfIndex = -1;\n        let fuzzyGreatest = 0;\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const fuzzyValue = fuzzyObjectValue(draft, one, data);\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = schema.oneOf[i];\n                schemaOfIndex = i;\n            }\n        }\n        if (schemaOfItem === undefined) {\n            return draft.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                schema,\n                oneOf: schema.oneOf\n            });\n        }\n        return createOneOfSchemaResult(schema, schemaOfItem, schemaOfIndex);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf\n    });\n}\n/**\n * validates oneOf definition for given input data\n */\nconst validateOneOf = (draft, schema, value, pointer) => {\n    if (Array.isArray(schema.oneOf)) {\n        const schemaOrError = draft.resolveOneOf(value, schema, pointer);\n        if (isJsonError(schemaOrError)) {\n            return schemaOrError;\n        }\n    }\n};\n\n\n// EXTERNAL MODULE: ./node_modules/deepmerge/dist/cjs.js\nvar cjs = __webpack_require__(4744);\nvar cjs_default = /*#__PURE__*/__webpack_require__.n(cjs);\n;// ./node_modules/json-schema-library/dist/module/lib/utils/merge.js\n\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\n/* harmony default export */ const merge = ((a, b) => cjs_default()(a, b, { arrayMerge: overwriteMerge }));\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nconst mergeArraysUnique = (a, b) => cjs_default()(a, b, { arrayMerge: mergeUniqueItems });\n\n;// ./node_modules/json-schema-library/dist/module/lib/mergeSchema.js\n\n\n/**\n * merges to two json schema. In case of conflicts, will use overwrite first\n * schema or directly return first json schema.\n */\nfunction mergeSchema(a, b) {\n    const aType = getTypeOf(a);\n    const bType = getTypeOf(b);\n    if (aType !== bType) {\n        return a;\n    }\n    const result = mergeArraysUnique(a, b);\n    if (a.getOneOfOrigin) {\n        Object.defineProperty(result, "getOneOfOrigin", {\n            enumerable: false,\n            value: a.getOneOfOrigin\n        });\n    }\n    else if (b.getOneOfOrigin) {\n        Object.defineProperty(result, "getOneOfOrigin", {\n            enumerable: false,\n            value: b.getOneOfOrigin\n        });\n    }\n    return result;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/omit.js\n/**\n * Omit properties from input object. Accepts any number of properties to\n * remove. Example:\n *\n * ```ts\n * omit(myObject, "if", "dependencies");\n * ```\n *\n * @returns shallow copy of input object without specified properties\n */\nfunction omit(object, ...keysToOmit) {\n    const result = {};\n    Object.keys(object).forEach((key) => {\n        if (!keysToOmit.includes(key)) {\n            result[key] = object[key];\n        }\n    });\n    if (object.getOneOfOrigin) {\n        Object.defineProperty(result, "getOneOfOrigin", {\n            enumerable: false,\n            value: object.getOneOfOrigin\n        });\n    }\n    return result;\n}\n\n;// ./node_modules/fast-copy/dist/esm/index.mjs\nvar toStringFunction = Function.prototype.toString;\nvar create = Object.create;\nvar toStringObject = Object.prototype.toString;\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nvar LegacyCache = /** @class */ (function () {\n    function LegacyCache() {\n        this._keys = [];\n        this._values = [];\n    }\n    LegacyCache.prototype.has = function (key) {\n        return !!~this._keys.indexOf(key);\n    };\n    LegacyCache.prototype.get = function (key) {\n        return this._values[this._keys.indexOf(key)];\n    };\n    LegacyCache.prototype.set = function (key, value) {\n        this._keys.push(key);\n        this._values.push(value);\n    };\n    return LegacyCache;\n}());\nfunction createCacheLegacy() {\n    return new LegacyCache();\n}\nfunction createCacheModern() {\n    return new WeakMap();\n}\n/**\n * Get a new cache object to prevent circular references.\n */\nvar createCache = typeof WeakMap !== \'undefined\' ? createCacheModern : createCacheLegacy;\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nfunction getCleanClone(prototype) {\n    if (!prototype) {\n        return create(null);\n    }\n    var Constructor = prototype.constructor;\n    if (Constructor === Object) {\n        return prototype === Object.prototype ? {} : create(prototype);\n    }\n    if (Constructor &&\n        ~toStringFunction.call(Constructor).indexOf(\'[native code]\')) {\n        try {\n            return new Constructor();\n        }\n        catch (_a) { }\n    }\n    return create(prototype);\n}\nfunction getRegExpFlagsLegacy(regExp) {\n    var flags = \'\';\n    if (regExp.global) {\n        flags += \'g\';\n    }\n    if (regExp.ignoreCase) {\n        flags += \'i\';\n    }\n    if (regExp.multiline) {\n        flags += \'m\';\n    }\n    if (regExp.unicode) {\n        flags += \'u\';\n    }\n    if (regExp.sticky) {\n        flags += \'y\';\n    }\n    return flags;\n}\nfunction getRegExpFlagsModern(regExp) {\n    return regExp.flags;\n}\n/**\n * Get the flags to apply to the copied regexp.\n */\nvar getRegExpFlags = /test/g.flags === \'g\' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\nfunction getTagLegacy(value) {\n    var type = toStringObject.call(value);\n    return type.substring(8, type.length - 1);\n}\nfunction getTagModern(value) {\n    return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nvar getTag = typeof Symbol !== \'undefined\' ? getTagModern : getTagLegacy;\n\nvar defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar _a = Object.prototype, esm_hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;\nvar SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === \'function\';\nfunction getStrictPropertiesModern(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nvar getStrictProperties = SUPPORTS_SYMBOL\n    ? getStrictPropertiesModern\n    : getOwnPropertyNames;\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict(value, clone, state) {\n    var properties = getStrictProperties(value);\n    for (var index = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index < length_1; ++index) {\n        property = properties[index];\n        if (property === \'callee\' || property === \'caller\') {\n            continue;\n        }\n        descriptor = getOwnPropertyDescriptor(value, property);\n        if (!descriptor) {\n            // In extra edge cases where the property descriptor cannot be retrived, fall back to\n            // the loose assignment.\n            clone[property] = state.copier(value[property], state);\n            continue;\n        }\n        // Only clone the value if actually a value, not a getter / setter.\n        if (!descriptor.get && !descriptor.set) {\n            descriptor.value = state.copier(descriptor.value, state);\n        }\n        try {\n            defineProperty(clone, property, descriptor);\n        }\n        catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array.\n */\nfunction copyArrayLoose(array, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    for (var index = 0, length_2 = array.length; index < length_2; ++index) {\n        clone[index] = state.copier(array[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nfunction copyArrayStrict(array, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    return copyOwnPropertiesStrict(array, clone, state);\n}\n/**\n * Copy the contents of the ArrayBuffer.\n */\nfunction copyArrayBuffer(arrayBuffer, _state) {\n    return arrayBuffer.slice(0);\n}\n/**\n * Create a new Blob with the contents of the original.\n */\nfunction copyBlob(blob, _state) {\n    return blob.slice(0, blob.size, blob.type);\n}\n/**\n * Create a new DataView with the contents of the original.\n */\nfunction copyDataView(dataView, state) {\n    return new state.Constructor(copyArrayBuffer(dataView.buffer));\n}\n/**\n * Create a new Date based on the time of the original.\n */\nfunction copyDate(date, state) {\n    return new state.Constructor(date.getTime());\n}\n/**\n * Deeply copy the keys and values of the original.\n */\nfunction copyMapLoose(map, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(map, clone);\n    map.forEach(function (value, key) {\n        clone.set(key, state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nfunction copyMapStrict(map, state) {\n    return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\nfunction copyObjectLooseLegacy(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (var key in object) {\n        if (esm_hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    return clone;\n}\nfunction copyObjectLooseModern(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (var key in object) {\n        if (esm_hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    var symbols = getOwnPropertySymbols(object);\n    for (var index = 0, length_3 = symbols.length, symbol = void 0; index < length_3; ++index) {\n        symbol = symbols[index];\n        if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = state.copier(object[symbol], state);\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nvar copyObjectLoose = SUPPORTS_SYMBOL\n    ? copyObjectLooseModern\n    : copyObjectLooseLegacy;\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nfunction copyObjectStrict(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    return copyOwnPropertiesStrict(object, clone, state);\n}\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nfunction copyPrimitiveWrapper(primitiveObject, state) {\n    return new state.Constructor(primitiveObject.valueOf());\n}\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nfunction copyRegExp(regExp, state) {\n    var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));\n    clone.lastIndex = regExp.lastIndex;\n    return clone;\n}\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nfunction copySelf(value, _state) {\n    return value;\n}\n/**\n * Deeply copy the values of the original.\n */\nfunction copySetLoose(set, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(set, clone);\n    set.forEach(function (value) {\n        clone.add(state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nfunction copySetStrict(set, state) {\n    return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n\nvar isArray = Array.isArray;\nvar esm_assign = Object.assign;\nvar getPrototypeOf = Object.getPrototypeOf || (function (obj) { return obj.__proto__; });\nvar DEFAULT_LOOSE_OPTIONS = {\n    array: copyArrayLoose,\n    arrayBuffer: copyArrayBuffer,\n    blob: copyBlob,\n    dataView: copyDataView,\n    date: copyDate,\n    error: copySelf,\n    map: copyMapLoose,\n    object: copyObjectLoose,\n    regExp: copyRegExp,\n    set: copySetLoose,\n};\nvar DEFAULT_STRICT_OPTIONS = esm_assign({}, DEFAULT_LOOSE_OPTIONS, {\n    array: copyArrayStrict,\n    map: copyMapStrict,\n    object: copyObjectStrict,\n    set: copySetStrict,\n});\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(options) {\n    return {\n        Arguments: options.object,\n        Array: options.array,\n        ArrayBuffer: options.arrayBuffer,\n        Blob: options.blob,\n        Boolean: copyPrimitiveWrapper,\n        DataView: options.dataView,\n        Date: options.date,\n        Error: options.error,\n        Float32Array: options.arrayBuffer,\n        Float64Array: options.arrayBuffer,\n        Int8Array: options.arrayBuffer,\n        Int16Array: options.arrayBuffer,\n        Int32Array: options.arrayBuffer,\n        Map: options.map,\n        Number: copyPrimitiveWrapper,\n        Object: options.object,\n        Promise: copySelf,\n        RegExp: options.regExp,\n        Set: options.set,\n        String: copyPrimitiveWrapper,\n        WeakMap: copySelf,\n        WeakSet: copySelf,\n        Uint8Array: options.arrayBuffer,\n        Uint8ClampedArray: options.arrayBuffer,\n        Uint16Array: options.arrayBuffer,\n        Uint32Array: options.arrayBuffer,\n        Uint64Array: options.arrayBuffer,\n    };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nfunction createCopier(options) {\n    var normalizedOptions = esm_assign({}, DEFAULT_LOOSE_OPTIONS, options);\n    var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n    var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;\n    function copier(value, state) {\n        state.prototype = state.Constructor = undefined;\n        if (!value || typeof value !== \'object\') {\n            return value;\n        }\n        if (state.cache.has(value)) {\n            return state.cache.get(value);\n        }\n        state.prototype = getPrototypeOf(value);\n        state.Constructor = state.prototype && state.prototype.constructor;\n        // plain objects\n        if (!state.Constructor || state.Constructor === Object) {\n            return object(value, state);\n        }\n        // arrays\n        if (isArray(value)) {\n            return array(value, state);\n        }\n        var tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n        if (tagSpecificCopier) {\n            return tagSpecificCopier(value, state);\n        }\n        return typeof value.then === \'function\' ? value : object(value, state);\n    }\n    return function copy(value) {\n        return copier(value, {\n            Constructor: undefined,\n            cache: createCache(),\n            copier: copier,\n            prototype: undefined,\n        });\n    };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nfunction createStrictCopier(options) {\n    return createCopier(esm_assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nvar copyStrict = createStrictCopier({});\n/**\n * Copy an value deeply as much as possible.\n */\nvar index = createCopier({});\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/copy.js\n\n/* harmony default export */ const copy = (index);\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/if.js\n/**\n * returns if-then-else as a json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns json schema defined by if-then-else or undefined\n */\nfunction resolveIfSchema(draft, schema, data) {\n    if (schema.if == null) {\n        return undefined;\n    }\n    if (schema.if === false) {\n        return schema.else;\n    }\n    if (schema.if && (schema.then || schema.else)) {\n        const ifErrors = draft.validate(data, draft.resolveRef(schema.if));\n        if (ifErrors.length === 0 && schema.then) {\n            return draft.resolveRef(schema.then);\n        }\n        if (ifErrors.length !== 0 && schema.else) {\n            return draft.resolveRef(schema.else);\n        }\n    }\n}\n/**\n * @returns validation result of it-then-else schema\n */\nconst validateIf = (draft, schema, value, pointer) => {\n    const resolvedSchema = resolveIfSchema(draft, schema, value);\n    if (resolvedSchema) {\n        return draft.validate(value, resolvedSchema, pointer);\n    }\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/allOf.js\n\n\n\n\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nfunction resolveSchema(draft, schemaToResolve, data) {\n    var _a;\n    const schema = { ...((_a = draft.resolveRef(schemaToResolve)) !== null && _a !== void 0 ? _a : {}) };\n    const ifSchema = resolveIfSchema(draft, schema, data);\n    if (ifSchema) {\n        return ifSchema;\n    }\n    return omit(schema, "if", "then", "else");\n}\nfunction resolveAllOf(draft, data, schema = draft.rootSchema) {\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        // @todo introduce draft.resolveSchema to iteratively resolve\n        const allOfSchema = resolveSchema(draft, schema.allOf[i], data);\n        mergedSchema = mergeSchema(mergedSchema, allOfSchema);\n        data = draft.getTemplate(data, mergedSchema);\n    }\n    delete mergedSchema.allOf;\n    return mergedSchema;\n}\n/**\n * @attention: subschemas have to be resolved upfront (e.g. if-else that do not apply)\n * Merge all allOf sub schema into a single schema. Returns undefined for\n * missing allOf definition.\n *\n * @returns json schema defined by allOf or undefined\n */\nfunction mergeAllOfSchema(draft, schema) {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    let resolvedSchema = {};\n    allOf.forEach((subschema) => {\n        resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(subschema));\n    });\n    return resolvedSchema;\n}\n/**\n * validate allOf definition for given input data\n */\nconst validateAllOf = (draft, schema, value, pointer) => {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    const errors = [];\n    schema.allOf.forEach((subSchema) => {\n        errors.push(...draft.validate(value, subSchema, pointer));\n    });\n    return errors;\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js\nfunction resolveRef(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    if (schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = schema.getRoot().getRef(schema);\n        // console.log(schema.$ref, "=>", resolvedSchema);\n        return resolvedSchema;\n    }\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = rootSchema.getRef(schema);\n    return resolvedSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/resolveRef.merge.js\nfunction resolveRefMerge(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    const resolvedSchema = rootSchema.getRef(schema);\n    const mergedSchema = Object.assign({}, resolvedSchema, schema);\n    delete mergedSchema.$ref;\n    // @todo the following might not be safe nor incomplete\n    Object.defineProperty(mergedSchema, "__ref", { enumerable: false, value: schema.__ref });\n    Object.defineProperty(mergedSchema, "getRoot", { enumerable: false, value: schema.getRoot });\n    return mergedSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/validateAsync.js\n\n\n\nfunction createErrorNotification(onError) {\n    return function notifyError(error) {\n        if (Array.isArray(error)) {\n            error = flattenArray(error);\n            error.forEach(notifyError);\n            return error;\n        }\n        if (isJsonError(error)) {\n            onError(error);\n        }\n        return error;\n    };\n}\n/**\n * @async\n * Validate data by a json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param options\n * @param options.schema - json schema to use, defaults to draft.rootSchema\n * @param options.pointer - json pointer pointing to current value. Used in error reports\n * @param options.onError   - will be called for each error as soon as it is resolved\n * @return list of errors or empty\n */\nfunction validateAsync(draft, value, options) {\n    const { schema, pointer, onError } = { schema: draft.rootSchema, pointer: "#", ...options };\n    let errors = draft.validate(value, schema, pointer);\n    if (onError) {\n        errors = flattenArray(errors);\n        const notifyError = createErrorNotification(onError);\n        for (let i = 0; i < errors.length; i += 1) {\n            const error = errors[i];\n            if (error instanceof Promise) {\n                error.then(notifyError);\n            }\n            else if (isJsonError(error)) {\n                onError(error);\n            }\n        }\n    }\n    return Promise.all(errors)\n        .then(flattenArray)\n        .then((resolvedErrors) => resolvedErrors.filter(errorsOnly))\n        .catch((e) => {\n        console.log("Failed resolving promises", e.message);\n        console.log(e.stack);\n        throw e;\n    });\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js\n/**\n * @returns list with unique values only\n */\nfunction uniqueItems(list) {\n    return list.filter((item, index) => list.indexOf(item) === index);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/isObject.js\n\nfunction isObject(v) {\n    return getTypeOf(v) === "object";\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/dependencies.js\n\n\n\n\n/**\n * returns dependencies as an object json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns merged json schema defined by dependencies or undefined\n */\nfunction resolveDependencies(draft, schema, data) {\n    const { dependencies } = schema;\n    if (!isObject(dependencies) || !isObject(data)) {\n        return;\n    }\n    let updated = false;\n    let resolvedSchema = { required: [] };\n    Object.keys(dependencies).forEach((prop) => {\n        var _a, _b;\n        if (data[prop] == null &&\n            !(((_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {\n            return;\n        }\n        const dependency = dependencies[prop];\n        // dependency array\n        if (Array.isArray(dependency)) {\n            updated = true;\n            resolvedSchema.required.push(...dependency);\n            return;\n        }\n        // dependency schema\n        if (isObject(dependency)) {\n            updated = true;\n            resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(dependency));\n            return;\n        }\n    });\n    if (updated) {\n        resolvedSchema.required = uniqueItems(resolvedSchema.required);\n        return resolvedSchema;\n    }\n}\n/**\n * validate dependencies definition for given input data\n */\nconst validateDependencies = (draft, schema, value, pointer) => {\n    if (getTypeOf(schema.dependencies) !== "object") {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        if (schema.dependencies[property] === undefined) {\n            return;\n        }\n        // @draft >= 6 boolean schema\n        if (schema.dependencies[property] === true) {\n            return;\n        }\n        if (schema.dependencies[property] === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        let dependencyErrors;\n        const type = getTypeOf(schema.dependencies[property]);\n        if (type === "array") {\n            dependencyErrors = schema.dependencies[property]\n                .filter((dependency) => value[dependency] === undefined)\n                .map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));\n        }\n        else if (type === "object") {\n            dependencyErrors = draft.validate(value, schema.dependencies[property], pointer);\n        }\n        else {\n            throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);\n        }\n        errors.push(...dependencyErrors);\n    });\n    return errors.length > 0 ? errors : undefined;\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/anyOf.js\n/**\n * @draft-04\n */\n\n\n/**\n * returns merged schema of all valid anyOf subschemas for the given input data.\n * Does not merge with rest input schema.\n *\n * @returns merged anyOf subschemas which are valid to the given input data.\n */\nfunction mergeValidAnyOfSchema(draft, schema, data) {\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return;\n    }\n    let resolvedSchema;\n    schema.anyOf.forEach((anySchema) => {\n        anySchema = draft.resolveRef(anySchema);\n        if (draft.isValid(data, anySchema)) {\n            resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anySchema) : anySchema;\n        }\n    });\n    return resolvedSchema;\n}\n/**\n * @returns extended input schema with valid anyOf subschemas or JsonError if\n * no anyOf schema matches input data\n */\nfunction resolveAnyOf(draft, data, schema = draft.rootSchema, pointer = "#") {\n    const { anyOf } = schema;\n    if (!Array.isArray(anyOf) || anyOf.length === 0) {\n        return schema;\n    }\n    const resolvedSchema = mergeValidAnyOfSchema(draft, schema, data);\n    if (resolvedSchema == null) {\n        return draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });\n    }\n    const mergedSchema = mergeSchema(schema, resolvedSchema);\n    return omit(mergedSchema, "anyOf");\n}\n/**\n * validate anyOf definition for given input data\n */\nconst validateAnyOf = (draft, schema, value, pointer) => {\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return undefined;\n    }\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        if (draft.isValid(value, schema.anyOf[i])) {\n            return undefined;\n        }\n    }\n    return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js\n\n\n\n\n\n\n\n\nconst toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];\nconst dynamicProperties = ["allOf", "anyOf", "oneOf", "dependencies", "if"];\nfunction isDynamicSchema(schema) {\n    const givenProps = Object.keys(schema);\n    return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;\n}\n/**\n * @note this utility does not reference draft methods for resolution\n * @todo consider using draft methods\n *\n * Resolves all dynamic schema definitions for the given input data and returns\n * the resulting json-schema without any dynamic schema definitions. The result\n * is not merged with the original input schema, thus static definitions of the\n * input schema are untouched and missing. For a full schema definition of this\n * input data you have to merge the result with the original schema\n * (@see reduceSchema)\n *\n * dynamic schema definitions: dependencies, allOf, anyOf, oneOf, if\n *\n * @returns static schema from resolved dynamic schema definitions for this\n *  specific input data\n */\nfunction resolveDynamicSchema(draft, schema, data, pointer) {\n    let resolvedSchema;\n    let error;\n    schema = draft.resolveRef(schema);\n    // @feature oneOf\n    if (schema.oneOf) {\n        const oneOfSchema = resolveOneOfFuzzy(draft, data, schema, pointer);\n        if (isJsonError(oneOfSchema)) {\n            error = oneOfSchema;\n        }\n        else if (oneOfSchema) {\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema);\n        }\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const allOf = schema.allOf.map((s) => {\n            // before merging allOf schema we need to resolve all subschemas\n            // if not, we would wrongly merge oneOf, if-then statements, etc\n            if (isDynamicSchema(s)) {\n                // copy of reduceSchema\n                let result = resolveDynamicSchema(draft, s, data, pointer);\n                if (result) {\n                    result = mergeSchema(s, result);\n                    return omit(result, ...toOmit);\n                }\n                return undefined;\n            }\n            return s;\n        });\n        if (allOf.length > 0) {\n            const allOfSchema = mergeAllOfSchema(draft, { allOf });\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);\n        }\n    }\n    // @feature anyOf\n    const anyOfSchema = mergeValidAnyOfSchema(draft, schema, data);\n    if (anyOfSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyOfSchema);\n    }\n    // @feature dependencies\n    const dependenciesSchema = resolveDependencies(draft, schema, data);\n    if (dependenciesSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);\n    }\n    // @feature if-then-else\n    const ifSchema = resolveIfSchema(draft, schema, data);\n    if (ifSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifSchema);\n    }\n    if (resolvedSchema == null) {\n        return error;\n    }\n    const nestedSchema = resolveDynamicSchema(draft, resolvedSchema, data, pointer);\n    if (nestedSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema, nestedSchema);\n    }\n    return omit(resolvedSchema, ...toOmit);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/reduceSchema.js\n\n\n\nconst reduceSchema_toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];\n/**\n * reduces json schema by merging dynamic constructs like if-then-else,\n * dependencies, allOf, anyOf, oneOf, etc into a static json schema\n * omitting those properties.\n *\n * @returns input schema reduced by dynamic schema definitions for the given\n * input data\n */\nfunction reduceSchema(draft, schema, data, pointer) {\n    let resolvedSchema = resolveDynamicSchema(draft, schema, data, pointer);\n    if (resolvedSchema) {\n        resolvedSchema = mergeSchema(schema, resolvedSchema);\n        return omit(resolvedSchema, ...reduceSchema_toOmit);\n    }\n    return schema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft/index.js\n\nclass Draft {\n    constructor(config, schema) {\n        /** cache for remote schemas */\n        this.remotes = {};\n        /** error creators by id */\n        this.errors = {};\n        /** map for valid keywords of a type  */\n        this.typeKeywords = {};\n        /** keyword validators  */\n        this.validateKeyword = {};\n        /** type validators  */\n        this.validateType = {};\n        /** format validators  */\n        this.validateFormat = {};\n        this.config = config;\n        this.typeKeywords = copy(config.typeKeywords);\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n    set rootSchema(rootSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url, schema) {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n    compileSchema(schema) {\n        var _a;\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\n    }\n    createSchemaOf(data) {\n        return this.config.createSchemaOf(data);\n    }\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data, callback, schema, pointer) {\n        return this.config.each(this, data, callback, schema, pointer);\n    }\n    eachSchema(callback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n    getChildSchemaSelection(property, schema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     *\n     * To resolve dynamic schema where the type of json-schema is evaluated by\n     * its value, a data object has to be passed in options.\n     *\n     * Per default this function will return `undefined` for valid properties that\n     * do not have a defined schema. Use the option `withSchemaWarning: true` to\n     * receive an error with `code: schema-warning` containing the location of its\n     * last evaluated json-schema.\n     *\n     * Notes\n     *      - uses draft.step to walk through data and schema\n     *\n     * @param draft\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n     * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n     * @return resolved json-schema object of requested json-pointer location\n     */\n    getSchema(options) {\n        return this.config.getSchema(this, options);\n    }\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data, schema, opts = this.config.templateDefaultOptions) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n    isValid(data, schema, pointer) {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n    resolveAnyOf(data, schema, pointer) {\n        return this.config.resolveAnyOf(this, data, schema, pointer);\n    }\n    resolveAllOf(data, schema) {\n        return this.config.resolveAllOf(this, data, schema);\n    }\n    resolveRef(schema) {\n        return this.config.resolveRef(schema, this.rootSchema);\n    }\n    resolveOneOf(data, schema, pointer) {\n        return this.config.resolveOneOf(this, data, schema, pointer);\n    }\n    setSchema(schema) {\n        this.rootSchema = schema;\n    }\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     *  returns the correct schema.\n     *\n     * @param  key       - property-name or array-index\n     * @param  schema    - json schema of current data\n     * @param  data      - parent of key\n     * @param  [pointer] - pointer to schema and data (parent of key)\n     * @return Schema or Error if failed resolving key\n     */\n    step(key, schema, data, pointer) {\n        return this.config.step(this, key, schema, data, pointer);\n    }\n    /**\n     * Validate data by a json schema\n     *\n     * @param value - value to validate\n     * @param [schema] - json schema, defaults to rootSchema\n     * @param [pointer] - json pointer pointing to value (used for error-messages only)\n     * @return list of errors or empty\n     */\n    validate(data, schema, pointer) {\n        return this.config.validate(this, data, schema, pointer);\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js\n/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nfunction addRemoteSchema(draft, url, schema) {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n\n// EXTERNAL MODULE: ./node_modules/@sagold/json-pointer/dist/jsonPointer.js\nvar jsonPointer = __webpack_require__(2546);\nvar jsonPointer_default = /*#__PURE__*/__webpack_require__.n(jsonPointer);\n// EXTERNAL MODULE: ./node_modules/ebnf/dist/Grammars/W3CEBNF.js\nvar W3CEBNF = __webpack_require__(6782);\n;// ./node_modules/@sagold/json-query/dist/module/lib/parser/jsonQueryGrammar.js\nconst propertyRegex = "[^?/{}*,()#]+";\n// W3C ENBF grammar\n// https://github.com/lys-lang/node-ebnf/blob/master/test/W3CEBNF.spec.ts\n// https://www.w3.org/TR/xml/#sec-notation\nconst jsonQueryGrammar = `\nroot ::= ("#" recursion | recursion | (query | pattern) recursion* | "#" SEP? | SEP)\nrecursion ::= (SEP query | pattern)*\n\nquery ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?\nproperty ::= ${propertyRegex}\nregex ::= "{" [^}]+ "}"\nSEP ::= "/"\nall ::= "**"\nany ::= "*"\n\ntypecheck ::= "?:" ("value" | "boolean" | "string" | "number" | "object" | "array")\nlookahead ::= "?" expression ((andExpr | orExpr) expression)*\nandExpr ::= S? "&&" S?\norExpr ::= S? "||" S?\n\nexpression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*\nexprProperty ::= [a-zA-Z0-9-_ $]+\nescaped ::= [^"]+\nis ::= ":"\nisnot ::= ":!"\nESC ::= \'"\'\n\npattern ::= S? "(" (SEP query | pattern (orPattern? pattern)*)* ")" quantifier? S? lookahead?\nquantifier ::= "+" | "*" | [0-9]+\norPattern ::= S? "," S?\n\nS ::= [ ]*\n`;\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/parser/index.js\n\n\nconst valid = /(children|text|type|start|end|rest|errors|fullText|\\d+)/;\nconst subset = /(children|text|type|\\d+)/;\nconst toJSON = (ast) => JSON.stringify(ast, (key, value) => (key === "" || valid.test(key) ? value : undefined), 2);\nconst toSmallJSON = (ast) => JSON.stringify(ast, (key, value) => key === "" || (key === "rest" && value !== "") || subset.test(key)\n    ? value\n    : undefined, 2);\nconst parser = new W3CEBNF/* default */.A.Parser(jsonQueryGrammar);\nconst parse = (query) => parser.getAST(query);\nconst reduce = (ast) => JSON.parse(toSmallJSON(ast));\n\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/interpreter/keys.js\nconst VALUE_INDEX = 0;\nconst KEY_INDEX = 1;\nconst PARENT_INDEX = 2;\nconst POINTER_INDEX = 3;\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/interpreter/nodes.js\nconst join = (a, b) => `${a}/${b}`;\n\nconst nodes_toString = Object.prototype.toString;\nconst rContainer = /Object|Array/;\nconst isContainer = (v) => rContainer.test(nodes_toString.call(v));\nconst nodes_getTypeOf = (v) => nodes_toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nfunction nodeAsRegex(node) {\n    return new RegExp(node.text.replace(/(^{|}$)/g, ""));\n}\n/**\n * Iterates over object or array, passing each key, value and parentObject to the callback\n * @param value - to iterate\n * @param callback - receiving key on given input value\n */\nfunction forEach(parent, callback) {\n    if (Array.isArray(parent)) {\n        parent.forEach(callback);\n    }\n    else if (Object.prototype.toString.call(parent) === "[object Object]") {\n        Object.keys(parent).forEach(function (key) {\n            callback(parent[key], key, parent);\n        });\n    }\n}\n/**\n * Returns all keys of the given input data\n * @param  value\n * @return {Array} containing keys of given value\n */\nfunction getKeys(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (value, index) {\n            return `${index}`;\n        });\n    }\n    if (Object.prototype.toString.call(value) === "[object Object]") {\n        return Object.keys(value);\n    }\n    return [];\n}\nconst cache = {\n    mem: [],\n    get(entry, prop) {\n        const v = entry[VALUE_INDEX][prop];\n        if (cache.mem.includes(v)) {\n            return undefined;\n        }\n        if (isContainer(v)) {\n            cache.mem.push(v);\n        }\n        return [v, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n    },\n    reset() {\n        cache.mem.length = 0;\n    },\n};\nconst expand = {\n    any(node, entry) {\n        const value = entry[VALUE_INDEX];\n        return (getKeys(value)\n            // .map(prop => cache.get(entry, prop));\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]));\n    },\n    all(node, entry) {\n        const result = [entry];\n        forEach(entry[VALUE_INDEX], (value, prop) => {\n            const childEntry = cache.get(entry, prop);\n            // const childEntry = [value, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n            childEntry && result.push(...expand.all(node, childEntry));\n        });\n        return result;\n    },\n    regex(node, entry) {\n        const regex = nodeAsRegex(node);\n        const value = entry[VALUE_INDEX];\n        return getKeys(value)\n            .filter((prop) => regex.test(prop))\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]);\n    },\n};\nconst nodes_select = {\n    // alias to property (but escaped)\n    escaped: (node, entry) => nodes_select.property(node, entry),\n    property: (node, entry) => {\n        const prop = node.text;\n        if (entry[VALUE_INDEX] && entry[VALUE_INDEX][prop] !== undefined) {\n            return [\n                entry[VALUE_INDEX][prop],\n                prop,\n                entry[VALUE_INDEX],\n                join(entry[POINTER_INDEX], prop),\n            ];\n        }\n    },\n    typecheck: (node, entry) => {\n        const checkedTyped = node.text.replace(/^\\?:/, "");\n        if (checkedTyped === "value") {\n            return isContainer(entry[VALUE_INDEX]) ? undefined : entry;\n        }\n        const type = nodes_getTypeOf(entry[VALUE_INDEX]);\n        if (type === checkedTyped) {\n            return entry;\n        }\n    },\n    lookahead: (node, entry) => {\n        let valid = true;\n        let or = false;\n        node.children.forEach((expr) => {\n            if (expr.type === "expression") {\n                const isValid = nodes_select.expression(expr, entry) !== undefined;\n                valid = or === true ? valid || isValid : valid && isValid;\n            }\n            else {\n                or = expr.type === "orExpr";\n            }\n        });\n        return valid ? entry : undefined;\n    },\n    expression: (node, entry) => {\n        const prop = node.children[0].text;\n        const cmp = node.children[1];\n        const test = node.children[2];\n        const value = entry[VALUE_INDEX];\n        if (isContainer(value) === false) {\n            return undefined;\n        }\n        return expressionMatches(value[prop], cmp, test) ? entry : undefined;\n    },\n};\nfunction expressionMatches(value, cmp, test) {\n    if (cmp === undefined) {\n        return value !== undefined;\n    }\n    let valid;\n    const valueString = `${value}`;\n    if (test.type === "regex") {\n        const regex = nodeAsRegex(test);\n        valid = regex.test(valueString);\n    }\n    else {\n        valid = valueString === test.text;\n    }\n    if (cmp.type === "isnot") {\n        valid = valid === false && value !== undefined;\n    }\n    return valid;\n}\n\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/interpreter/index.js\n\n\nfunction collect(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        result.push(...func(node, input[i], node, pointer));\n    }\n    return result;\n}\nfunction interpreter_reduce(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        const output = func(node, input[i], pointer);\n        if (output) {\n            result.push(output);\n        }\n    }\n    return result;\n}\nfunction query(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((node) => {\n        if (expand[node.type]) {\n            result = collect(expand[node.type], result, node, pointer);\n        }\n        else if (nodes_select[node.type]) {\n            result = interpreter_reduce(nodes_select[node.type], result, node, pointer);\n        }\n        else {\n            throw new Error(`Unknown filter ${node.type}`);\n        }\n    });\n    return result;\n}\nfunction runPatternOnce(inputSet, ast, pointer) {\n    const resultingSet = [];\n    let workingSet = inputSet;\n    ast.children.forEach((node) => {\n        if (node.type === "orPattern") {\n            resultingSet.push(...workingSet);\n            workingSet = inputSet;\n            return;\n        }\n        workingSet = runNode(workingSet, node, pointer);\n    });\n    resultingSet.push(...workingSet);\n    return resultingSet;\n}\nfunction getIterationCount(quantifier) {\n    if (quantifier == null) {\n        return 1; // default, simple group\n    }\n    if (quantifier === "*" || quantifier === "+") {\n        return Infinity;\n    }\n    const count = parseInt(quantifier);\n    return isNaN(count) ? 1 : count;\n}\nfunction pattern(data, ast, pointer) {\n    const result = [];\n    const quantifier = ast.children.find((node) => node.type === "quantifier");\n    const iterationCount = getIterationCount(quantifier && quantifier.text);\n    let workingSet = data;\n    if (quantifier && quantifier.text === "*") {\n        result.push(...workingSet);\n    }\n    let count = 0;\n    while (workingSet.length > 0 && count < iterationCount) {\n        workingSet = runPatternOnce(workingSet, ast, pointer);\n        result.push(...workingSet);\n        count += 1;\n    }\n    return result;\n}\nfunction skip(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((n) => (result = runNode(result, n, pointer)));\n    return result;\n}\nfunction runNode(data, ast, pointer) {\n    let result;\n    if (ast.type === "query") {\n        result = query(data, ast, pointer);\n    }\n    else if (ast.type === "pattern") {\n        result = pattern(data, ast, pointer);\n    }\n    else {\n        result = skip(data, ast, pointer);\n    }\n    // after each query or pattern, reset the cache, to (re)enable nested queries\n    cache.reset();\n    cache.mem.push(data);\n    return result;\n}\nfunction run(data, ast) {\n    cache.reset();\n    cache.mem.push(data);\n    return runNode([[data, null, null, "#"]], ast);\n}\n\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/get.js\n\n\nconst returnTypes = {\n    value: (r) => r.map((e) => e[VALUE_INDEX]),\n    pointer: (r) => r.map((e) => e[POINTER_INDEX]),\n    all: (r) => r,\n    map: (r) => {\n        const map = {};\n        r.forEach((e) => (map[e[POINTER_INDEX]] = e[VALUE_INDEX]));\n        return map;\n    },\n};\nvar ReturnType;\n(function (ReturnType) {\n    ReturnType["POINTER"] = "pointer";\n    ReturnType["VALUE"] = "value";\n    ReturnType["ALL"] = "all";\n    ReturnType["MAP"] = "map";\n})(ReturnType || (ReturnType = {}));\n// export return types on function\nget.POINTER = ReturnType.POINTER;\nget.VALUE = ReturnType.VALUE;\nget.ALL = ReturnType.ALL;\nget.MAP = ReturnType.MAP;\n/**\n * Runs query on input data and returns the results\n * @param data - input data\n * @param queryString - json-query string\n * @param returnType - result format or a custom callback\n */\nfunction get(data, queryString, returnType = ReturnType.VALUE) {\n    if (queryString == null) {\n        return [];\n    }\n    queryString = queryString.replace(/(\\/$)/g, "");\n    if (queryString === "") {\n        queryString = "#";\n    }\n    const ast = parse(queryString);\n    if (ast == null) {\n        throw new Error(`empty ast for \'${queryString}\'`);\n    }\n    if (ast.rest !== "") {\n        throw new Error(`Failed parsing queryString from: \'${ast.rest}\'`);\n    }\n    const result = run(data, ast);\n    if (typeof returnType === "function") {\n        return result.map((r) => returnType(...r));\n    }\n    else if (returnTypes[returnType]) {\n        return returnTypes[returnType](result);\n    }\n    return result;\n}\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/split.js\n\nconst split_skip = ["root", "recursion"];\nfunction buildPath(node, path = []) {\n    if (split_skip.includes(node.type)) {\n        node.children.forEach((n) => buildPath(n, path));\n        return path;\n    }\n    // remove escaped property quotes?\n    path.push(node.text);\n    return path;\n}\n/**\n * Returns queryString as a list of property-queries\n */\nfunction split(queryString) {\n    if (queryString == null || queryString === "") {\n        return [];\n    }\n    const ast = parse(queryString);\n    // console.log(toJSON(ast, null, 2));\n    return buildPath(ast);\n}\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/set.js\n\n\n\nconst cp = (v) => JSON.parse(JSON.stringify(v));\nconst set_toString = Object.prototype.toString;\nconst getType = (v) => set_toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nconst isProperty = new RegExp(`^("[^"]+"|${propertyRegex})$`);\nconst ignoreTypes = ["string", "number", "boolean", "null"];\nconst set_isArray = /^\\[\\d*\\]$/;\nconst arrayHasIndex = /^\\[(\\d+)\\]$/;\nconst isEscaped = /^".+"$/;\nconst isArrayProp = /(^\\[\\d*\\]$|^\\d+$)/;\nfunction convertToIndex(index) {\n    return parseInt(index.replace(/^(\\[|\\]$)/, ""));\n}\nfunction removeEscape(property) {\n    return isEscaped.test(property)\n        ? property.replace(/(^"|"$)/g, "")\n        : property;\n}\nfunction insert(array, index, value) {\n    if (array.length <= index) {\n        array[index] = value;\n    }\n    else {\n        array.splice(index, 0, value);\n    }\n}\nfunction set_select(workingSet, query) {\n    const nextSet = [];\n    workingSet.forEach((d) => nextSet.push(...get(d[0], query, ReturnType.ALL)));\n    return nextSet;\n}\nfunction addToArray(result, index, value, force) {\n    const target = result[0];\n    // append item?\n    if (/^\\[\\]$/.test(index)) {\n        target.push(value);\n        const i = target.length - 1;\n        return [target[i], i, target, `${result[3]}/${i}}`];\n    }\n    // merge array item?\n    if (force == null &&\n        getType(target[index]) === "object" &&\n        getType(value) === "object") {\n        Object.assign(target[index], value);\n        return [target[index], index, target, `${result[3]}/${index}}`];\n    }\n    if (force === set.INSERT_ITEMS ||\n        (force == null && arrayHasIndex.test(index))) {\n        const arrayIndex = convertToIndex(index);\n        insert(target, arrayIndex, value);\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    if (force === set.REPLACE_ITEMS || force == null) {\n        const arrayIndex = convertToIndex(index);\n        target[arrayIndex] = value;\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    throw new Error(`Unknown array index \'${index}\' with force-option \'${force}\'`);\n}\nfunction set_create(workingSet, query, keyIsArray, force) {\n    query = removeEscape(query);\n    return workingSet\n        .filter((o) => {\n        // replacing or inserting array\n        if (Array.isArray(o[0]) && isArrayProp.test(query)) {\n            return true;\n        }\n        return ignoreTypes.includes(getType(o[0][query])) === false;\n    })\n        .map((r) => {\n        const container = keyIsArray ? [] : {};\n        const o = r[0];\n        const containerType = getType(container);\n        const itemType = getType(o[query]);\n        if (Array.isArray(o) && itemType !== containerType) {\n            return addToArray(r, query, container, force);\n        }\n        o[query] = o[query] || container;\n        return [o[query], query, o, `${r[3]}/${query}`];\n    });\n}\nvar InsertMode;\n(function (InsertMode) {\n    InsertMode["REPLACE_ITEMS"] = "replace";\n    InsertMode["INSERT_ITEMS"] = "insert";\n})(InsertMode || (InsertMode = {}));\n// for all array-indices within path, replace the values, ignoring insertion syntax /[1]/\nset.REPLACE_ITEMS = InsertMode.REPLACE_ITEMS;\n// for all array-indices within path, insert the values, ignoring replace syntax /1/\nset.INSERT_ITEMS = InsertMode.INSERT_ITEMS;\n// set.MERGE_ITEMS = "merge";\n/**\n * Runs query on input data and assigns a value to query-results.\n * @param data - input data\n * @param queryString - json-query string\n * @param value - value to assign\n * @param [force] - whether to replace or insert into arrays\n */\nfunction set(data, queryString, value, force) {\n    if (queryString == null) {\n        return cp(data);\n    }\n    queryString = queryString.replace(/(\\/$)/g, "");\n    if (queryString === "") {\n        return cp(value);\n    }\n    const result = cp(data);\n    let workingSet = [[result, null, null, "#"]];\n    const path = split(queryString);\n    const property = path.pop();\n    const arrayWithoutIndex = set_isArray.test(property) && arrayHasIndex.test(property) === false;\n    if (isProperty.test(property) === false || arrayWithoutIndex) {\n        throw new Error(`Unsupported query \'${queryString}\' ending with non-property`);\n    }\n    path.forEach((query, index) => {\n        if ("__proto__" === query ||\n            "prototyped" === query ||\n            "constructor" === query) {\n            return;\n        }\n        if (isProperty.test(query) === false) {\n            workingSet = set_select(workingSet, query);\n            return;\n        }\n        // process property & missing data-structure\n        const nextKey = index >= path.length - 1 ? property : path[index + 1];\n        const insertArray = isArrayProp.test(nextKey);\n        workingSet = set_create(workingSet, query, insertArray, force);\n    });\n    workingSet.forEach((r) => {\n        let targetValue = value;\n        if (getType(value) === "function") {\n            targetValue = value(r[3], property, r[0], `${r[3]}/${property}`);\n        }\n        const d = r[0];\n        if (Array.isArray(d)) {\n            addToArray(r, property, targetValue, force);\n        }\n        else {\n            const unescapedProp = removeEscape(property);\n            if ("__proto__" === unescapedProp ||\n                "prototyped" === unescapedProp ||\n                "constructor" === unescapedProp) {\n                return;\n            }\n            d[unescapedProp] = targetValue;\n        }\n    });\n    return result;\n}\n\n;// ./node_modules/@sagold/json-query/dist/module/lib/remove.js\n\n\n\n/**\n * Runs query on input data and removes matching properties from results\n * @param data - input data\n * @param queryString - json-query string\n * @param [returnRemoved] - if true, will returned removed properties, else input-data is removed\n */\nfunction remove(data, queryString, returnRemoved = false) {\n    const removed = [];\n    const matches = get(data, queryString, ReturnType.ALL);\n    matches.forEach(function (match) {\n        removed.push(match[0]);\n        (0,jsonPointer.remove)(data, match[POINTER_INDEX], true);\n    });\n    matches.forEach(function (match) {\n        if (Array.isArray(match[PARENT_INDEX])) {\n            (0,jsonPointer.removeUndefinedItems)(match[PARENT_INDEX]);\n        }\n    });\n    return returnRemoved ? removed : data;\n}\n\n;// ./node_modules/@sagold/json-query/dist/module/index.js\n\n\n\n\n\n/* harmony default export */ const dist_module = ({ get: get, set: set, split: split, remove: remove, ReturnType: ReturnType });\n\n;// ./node_modules/json-schema-library/dist/module/lib/schema/types.js\nconst Types = {\n    $ref: {\n        type: false\n    },\n    allOf: {\n        type: false,\n        definitions: ["allOf/*"]\n    },\n    anyOf: {\n        type: false,\n        definitions: ["anyOf/*"]\n    },\n    array: {\n        type: true,\n        // ignore additionalItems:TypeDef, when items:TypeDef\n        definitions: [\n            "allOf/*",\n            "anyOf/*",\n            "oneOf/*",\n            "not",\n            "items",\n            "items/*",\n            "additionalItems"\n        ],\n        validationKeywords: ["minItems", "maxItems", "uniqueItems"],\n        keywords: ["items", "additionalItems", "minItems", "maxItems", "uniqueItems"]\n    },\n    boolean: {\n        type: true\n    },\n    enum: {\n        type: false\n    },\n    integer: {\n        type: true,\n        definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],\n        validationKeywords: ["minimum", "maximum", "multipleOf"]\n    },\n    not: {\n        type: false,\n        definitions: ["not"]\n    },\n    number: {\n        type: true,\n        definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],\n        validationKeywords: ["minimum", "maximum", "multipleOf"]\n    },\n    null: {\n        type: true\n    },\n    object: {\n        type: true,\n        // patternProperties also validate properties\n        // dependencies:(string, TypeDef) extend current TypeDef\n        // additional Properties validate only remaining properties (after properties & pattern)\n        definitions: [\n            "allOf/*",\n            "anyOf/*",\n            "oneOf/*",\n            "not",\n            "properties/*",\n            "additionalProperties",\n            "patternProperties/*",\n            "dependencies/*"\n        ],\n        validationKeywords: ["minProperties", "maxProperties", "required"],\n        keywords: [\n            "properties",\n            "additionalProperties",\n            "patternProperties",\n            "dependencies",\n            "minProperties",\n            "maxProperties",\n            "required"\n        ]\n    },\n    oneOf: {\n        type: false,\n        definitions: ["oneOf/*"]\n    },\n    string: {\n        type: true,\n        definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],\n        validationKeywords: ["minLength", "maxLength", "pattern"]\n    }\n};\n/* harmony default export */ const types = (Types);\n\n;// ./node_modules/json-schema-library/dist/module/lib/schema/getTypeId.js\n\n\nconst typeKeywords = Object.keys(types).filter((id) => types[id].type === false);\nconst getTypeId_hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @throws Error    on multiple matches (invalid schema)\n *\n * Returns the type id of a schema object\n * @param schema\n * @return type id, if found\n */\nfunction getTypeId(schema) {\n    if (isObject(schema) === false) {\n        return undefined;\n    }\n    if (schema.enum) {\n        return "enum";\n    }\n    const type = schema.type;\n    if (Array.isArray(type) || types[type]) {\n        return type;\n    }\n    const ids = typeKeywords.filter((type) => schema[type]);\n    if (ids.length === 1) {\n        return ids[0];\n    }\n    if (ids.length === 0) {\n        // @expensive, guess type object\n        for (let i = 0, l = types.object.keywords.length; i < l; i += 1) {\n            const keyword = types.object.keywords[i];\n            if (getTypeId_hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return "object";\n            }\n        }\n        // @expensive, guess type array\n        for (let i = 0, l = types.array.keywords.length; i < l; i += 1) {\n            const keyword = types.array.keywords[i];\n            if (getTypeId_hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return "array";\n            }\n        }\n        return undefined;\n    }\n    throw new Error(`Mutiple typeIds [${ids.join(", ")}] matched in ${JSON.stringify(schema)}`);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/schema/getTypeDefs.js\n\n\n\n\n\n/**\n * Returns a list of all (direct) type definitions from the given schema\n * @param schema\n * @return list of type definition, given as { pointer, def }\n */\nfunction getTypeDefs(schema) {\n    const defs = [];\n    const id = getTypeId(schema);\n    if (id == null) {\n        return defs;\n    }\n    let type;\n    if (Array.isArray(id)) {\n        // since types can also be declared as a set of types, merge the definitions\n        // maybe this will require a more sophisticated approach\n        type = {};\n        for (let i = 0, l = id.length; i < l; i += 1) {\n            Object.assign(type, types[id[i]]);\n        }\n    }\n    else {\n        type = types[id];\n    }\n    if (type.definitions == null) {\n        return defs;\n    }\n    type.definitions.forEach((query) => {\n        get(schema, query, (value, key, parent, pointer) => {\n            if (isObject(value) && getTypeId(value)) {\n                defs.push({ pointer: jsonPointer_default().join(jsonPointer_default().split(pointer), false), def: value });\n            }\n        });\n    });\n    return defs;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/eachSchema.js\n\n\n\nfunction nextTypeDefs(schema, pointer) {\n    if (this.callback(schema, pointer) === true) {\n        // eslint-disable-line no-invalid-this\n        return; // stop iteration\n    }\n    const defs = getTypeDefs(schema);\n    // eslint-disable-next-line no-invalid-this\n    defs.forEach((next) => this.nextTypeDefs(next.def, jsonPointer_default().join(pointer, next.pointer, false)));\n}\nfunction eachDefinition(walk, schema, pointer, key = "definitions") {\n    const defs = schema[key];\n    Object.keys(defs).forEach((defId) => {\n        if (defs[defId] === false || isObject(defs[defId])) {\n            walk.nextTypeDefs(defs[defId], jsonPointer_default().join(pointer, key, defId, false));\n            return;\n        }\n        // console.log(`Invalid schema in ${pointer}/${key}/${defId}`);\n    });\n}\nfunction eachSchema(schema, callback, pointer = "#") {\n    const walk = { callback, nextTypeDefs };\n    walk.nextTypeDefs(schema, pointer);\n    if (schema.definitions != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer);\n    }\n    if (schema.$defs != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer, "$defs");\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/joinScope.js\n/* eslint max-statements-per-line: ["error", { "max": 2 }] */\nconst suffixes = /(#|\\/)+$/;\nconst trailingHash = /#$/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\nfunction joinScope(previous, id) {\n    if (previous == null && id == null) {\n        return "#";\n    }\n    if (id == null) {\n        return previous.replace(trailingHash, "");\n    }\n    if (previous == null) {\n        return id.replace(trailingHash, "");\n    }\n    if (id[0] === "#") {\n        return `${previous.replace(idAndPointer, "")}${id.replace(suffixes, "")}`;\n    }\n    if (isDomain.test(id)) {\n        return id.replace(trailingHash, "");\n    }\n    return `${previous.replace(trailingFragments, "")}/${id.replace(trailingHash, "")}`;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/splitRef.js\nconst splitRef_suffixes = /(#|\\/)+$/g;\nconst emptyValues = ["", null, "#"];\nfunction splitRef($ref) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n    $ref = $ref.replace(splitRef_suffixes, "");\n    if ($ref.indexOf("#") === -1) {\n        return [$ref.replace(splitRef_suffixes, "")];\n    }\n    if ($ref.indexOf("#") === 0) {\n        return [$ref.replace(splitRef_suffixes, "")];\n    }\n    const result = $ref.split("#");\n    result[0] = result[0].replace(splitRef_suffixes, "");\n    result[1] = `#${result[1].replace(splitRef_suffixes, "")}`;\n    return result;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/getRef.js\n\n\n\nconst getRef_suffixes = /(#|\\/)+$/g;\nconst getRef_isObject = (val) => getTypeOf(val) === "object";\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nfunction getRef(context, rootSchema, $ref) {\n    if (getRef_isObject($ref)) {\n        $ref = $ref.__ref || $ref.$ref;\n    }\n    if ($ref == null) {\n        return rootSchema;\n    }\n    let schema;\n    // is it a known $ref?\n    const $remote = $ref.replace(getRef_suffixes, "");\n    if (context.remotes[$remote]) {\n        schema = context.remotes[$remote];\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    if (context.ids[$ref]) {\n        schema = (0,jsonPointer.get)(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n    if (fragments.length === 1) {\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            schema = context.remotes[$ref];\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        if (context.ids[$ref]) {\n            schema = (0,jsonPointer.get)(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema.$ref);\n            }\n            return schema;\n        }\n    }\n    if (fragments.length === 2) {\n        const base = fragments[0];\n        $ref = fragments[1];\n        if (context.remotes[base]) {\n            if (context.remotes[base].getRef) {\n                return context.remotes[base].getRef($ref);\n            }\n            // console.log("warning: uncompiled remote - context may be wrong", base);\n            return getRef(context, context.remotes[base], $ref);\n        }\n        if (context.ids[base]) {\n            return getRef(context, (0,jsonPointer.get)(rootSchema, context.ids[base]), $ref);\n        }\n    }\n    schema = (0,jsonPointer.get)(rootSchema, context.ids[$ref] || $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema.$ref);\n    }\n    return schema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/index.js\n/* eslint max-statements-per-line: ["error", { "max": 2 }] */\n\n\n\n\nconst COMPILED = "__compiled";\nconst COMPILED_REF = "__ref";\nconst GET_REF = "getRef";\nconst GET_ROOT = "getRoot";\nconst compile_suffixes = /(#|\\/)+$/g;\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nfunction compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    // flag this schema as compiled\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    // add getRef-helper to this object\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes("$ref") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, "definitions", {\n            enumerable: false,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith("http") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, "");\n                const parentSchema = (0,jsonPointer.get)(compiledSchema, parentPointer);\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\n            }\n            context.ids[schema.id.replace(compile_suffixes, "")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, "#");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, "");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, "");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log("compiled ref", scope, schema.$ref, "=>", joinScope(scope, schema.$ref));\n        }\n    });\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compileSchema.js\n\n/* harmony default export */ const lib_compileSchema = (compileSchema);\n\n;// ./node_modules/json-schema-library/dist/module/lib/each.js\n\n/**\n * Iterates over data, retrieving its schema\n *\n * @param draft - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nfunction each(draft, data, callback, schema = draft.rootSchema, pointer = "#") {\n    schema = draft.resolveRef(schema);\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n    if (dataType === "object") {\n        Object.keys(data).forEach((key) => {\n            const nextSchema = draft.step(key, schema, data, pointer); // not save\n            const next = data[key]; // save\n            draft.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n    else if (dataType === "array") {\n        data.forEach((next, key) => {\n            const nextSchema = draft.step(key, schema, data, pointer);\n            draft.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/validation/errors.js\n/* eslint no-invalid-this: 0 */\n\nconst errors = {\n    additionalItemsError: createCustomError("AdditionalItemsError"),\n    additionalPropertiesError: createCustomError("AdditionalPropertiesError"),\n    anyOfError: createCustomError("AnyOfError"),\n    allOfError: createCustomError("AllOfError"),\n    constError: createCustomError("ConstError"),\n    containsError: createCustomError("ContainsError"),\n    containsArrayError: createCustomError("ContainsArrayError"),\n    containsAnyError: createCustomError("ContainsAnyError"),\n    enumError: createCustomError("EnumError"),\n    forbiddenPropertyError: createCustomError("ForbiddenPropertyError"),\n    formatURLError: createCustomError("FormatURLError"),\n    formatURIError: createCustomError("FormatURIError"),\n    formatURIReferenceError: createCustomError("FormatURIReferenceError"),\n    formatURITemplateError: createCustomError("FormatURITemplateError"),\n    formatDateError: createCustomError("FormatDateError"),\n    formatDateTimeError: createCustomError("FormatDateTimeError"),\n    formatEmailError: createCustomError("FormatEmailError"),\n    formatHostnameError: createCustomError("FormatHostnameError"),\n    formatIPV4Error: createCustomError("FormatIPV4Error"),\n    formatIPV4LeadingZeroError: createCustomError("FormatIPV4LeadingZeroError"),\n    formatIPV6Error: createCustomError("FormatIPV6Error"),\n    formatIPV6LeadingZeroError: createCustomError("FormatIPV6LeadingZeroError"),\n    formatJsonPointerError: createCustomError("FormatJsonPointerError"),\n    formatRegExError: createCustomError("FormatRegExError"),\n    formatTimeError: createCustomError("FormatTimeError"),\n    invalidSchemaError: createCustomError("InvalidSchemaError"),\n    invalidDataError: createCustomError("InvalidDataError"),\n    invalidTypeError: createCustomError("InvalidTypeError"),\n    invalidPropertyNameError: createCustomError("InvalidPropertyNameError"),\n    maximumError: createCustomError("MaximumError"),\n    maxItemsError: createCustomError("MaxItemsError"),\n    maxLengthError: createCustomError("MaxLengthError"),\n    maxPropertiesError: createCustomError("MaxPropertiesError"),\n    minimumError: createCustomError("MinimumError"),\n    minItemsError: createCustomError("MinItemsError"),\n    minItemsOneError: createCustomError("MinItemsOneError"),\n    minLengthError: createCustomError("MinLengthError"),\n    minLengthOneError: createCustomError("MinLengthOneError"),\n    minPropertiesError: createCustomError("MinPropertiesError"),\n    missingDependencyError: createCustomError("MissingDependencyError"),\n    missingOneOfPropertyError: createCustomError("MissingOneOfPropertyError"),\n    multipleOfError: createCustomError("MultipleOfError"),\n    multipleOneOfError: createCustomError("MultipleOneOfError"),\n    noAdditionalPropertiesError: createCustomError("NoAdditionalPropertiesError"),\n    notError: createCustomError("NotError"),\n    oneOfError: createCustomError("OneOfError"),\n    oneOfPropertyError: createCustomError("OneOfPropertyError"),\n    patternError: createCustomError("PatternError"),\n    patternPropertiesError: createCustomError("PatternPropertiesError"),\n    requiredPropertyError: createCustomError("RequiredPropertyError"),\n    schemaWarning: createCustomError("SchemaWarning"),\n    typeError: createCustomError("TypeError"),\n    undefinedValueError: createCustomError("UndefinedValueError"),\n    uniqueItemsError: createCustomError("UniqueItemsError"),\n    unknownPropertyError: createCustomError("UnknownPropertyError"),\n    valueNotEmptyError: createCustomError("ValueNotEmptyError")\n};\n/* harmony default export */ const validation_errors = (errors);\n\n// EXTERNAL MODULE: ./node_modules/valid-url/index.js\nvar valid_url = __webpack_require__(7853);\nvar valid_url_default = /*#__PURE__*/__webpack_require__.n(valid_url);\n// EXTERNAL MODULE: ./node_modules/smtp-address-parser/dist/lib/index.js\nvar lib = __webpack_require__(8506);\n;// ./node_modules/json-schema-library/dist/module/lib/validation/format.js\n\n\n// referenced\n// https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n// https://gist.github.com/marcelotmelo/b67f58a08bee6c2468f8\nconst isValidDateTime = new RegExp("^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\\\.[0-9]+)?(([Zz])|([\\\\+|\\\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$");\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n// const matchTime = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst matchTime = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst isValidJsonPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&\'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&\'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&\'"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&\'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&\'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20"\'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// Default Json-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators = {\n    date: (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\n            return undefined;\n        }\n        return draft.errors.formatDateError({ value, pointer, schema });\n    },\n    "date-time": (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (value === "" || isValidDateTime.test(value)) {\n            if (new Date(value).toString() === "Invalid Date") {\n                return draft.errors.formatDateTimeError({ value, pointer, schema });\n            }\n            return undefined;\n        }\n        return draft.errors.formatDateTimeError({ value, pointer, schema });\n    },\n    email: (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (value[0] === \'"\') {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        const [name, host, ...rest] = value.split("@");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (name[0] === "." || name.endsWith(".") || name.includes("..")) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&\'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    /**\n     * @draft 7\n     * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531\n     */\n    "idn-email": (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        try {\n            (0,lib.parse)(value);\n            return undefined;\n        }\n        catch (e) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n    },\n    hostname: (draft, schema, value, pointer) => {\n        if (typeof value !== "string") {\n            return undefined;\n        }\n        if (value === "" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatHostnameError({ value, pointer, schema });\n    },\n    ipv4: (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (value && value[0] === "0") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV4Error({ value, pointer, schema });\n    },\n    ipv6: (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (value && value[0] === "0") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV6Error({ value, pointer, schema });\n    },\n    "json-pointer": (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    "relative-json-pointer": (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidRelativeJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    regex: (draft, schema, value, pointer) => {\n        if (typeof value === "string" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            }\n            catch (e) { } // eslint-disable-line no-empty\n            return draft.errors.formatRegExError({ value, pointer, schema });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === "object" || typeof value === "number" || Array.isArray(value)) {\n            return undefined;\n        }\n        return draft.errors.formatRegExError({ value, pointer, schema });\n    },\n    // hh:mm:ss.sTZD\n    // https://opis.io/json-schema/2.x/formats.html\n    // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html\n    time: (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        return matches ? undefined : draft.errors.formatDateTimeError({ value, pointer, schema });\n        // if (!matches) {\n        //     return errors.formatDateTimeError({ value, pointer, schema });\n        // }\n        // const hour = +matches[1];\n        // const minute = +matches[2];\n        // const second = +matches[3];\n        // const timeZone = !!matches[5];\n        // if (\n        //     ((hour <= 23 && minute <= 59 && second <= 59) ||\n        //         (hour == 23 && minute == 59 && second == 60)) &&\n        //     timeZone\n        // ) {\n        //     return undefined;\n        // }\n        // return errors.formatTimeError({ value, pointer, schema });\n    },\n    uri: (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (valid_url_default().isUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIError({ value, pointer, schema });\n    },\n    "uri-reference": (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIReferenceError({ value, pointer, schema });\n    },\n    "uri-template": (draft, schema, value, pointer) => {\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURITemplateError({ value, pointer, schema });\n    },\n    url: (draft, schema, value, pointer) => {\n        if (value === "" || valid_url_default().isWebUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURLError({ value, pointer, schema });\n    }\n};\n/* harmony default export */ const format = (formatValidators);\n\n;// ./node_modules/json-schema-library/dist/module/lib/getSchema.js\n\n\nconst emptyObject = {};\n/**\n * Returns the json-schema of a data-json-pointer.\n *\n * To resolve dynamic schema where the type of json-schema is evaluated by\n * its value, a data object has to be passed in options.\n *\n * Per default this function will return `undefined` for valid properties that\n * do not have a defined schema. Use the option `withSchemaWarning: true` to\n * receive an error with `code: schema-warning` containing the location of its\n * last evaluated json-schema.\n *\n * Notes\n *      - uses draft.step to walk through data and schema\n *\n * @param draft\n * @param pointer - json pointer in data to get the json schema for\n * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n * @return resolved json-schema object of requested json-pointer location or json-error\n */\nfunction getSchema(draft, options = emptyObject) {\n    const { pointer = "#", data, schema = draft.rootSchema, withSchemaWarning = false } = options;\n    const path = jsonPointer_default().split(pointer);\n    const result = _getSchema(draft, draft.resolveRef(schema), path, "#", data);\n    if (!withSchemaWarning && (result === null || result === void 0 ? void 0 : result.code) === "schema-warning") {\n        return undefined;\n    }\n    return result;\n}\nfunction _getSchema(draft, schema, path, pointer, data = emptyObject) {\n    if (path.length === 0) {\n        return draft.resolveRef(schema);\n    }\n    const key = path.shift(); // step key\n    schema = draft.step(key, schema, data, pointer); // step schema\n    if (isJsonError(schema)) {\n        return schema;\n    }\n    // @ts-expect-error data\n    data = data[key]; // step data\n    return _getSchema(draft, schema, path, `${pointer}/${key}`, data);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js\n\nfunction isEmpty(v) {\n    const type = getTypeOf(v);\n    switch (type) {\n        case "string":\n        case "array":\n            // @ts-expect-error tested as array - could use ts type guard\n            return (v === null || v === void 0 ? void 0 : v.length) === 0;\n        case "null":\n        case "undefined":\n            return true;\n        case "object":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/getTemplate.js\n/* eslint quote-props: 0, max-statements-per-line: ["error", { "max": 2 }] */\n\n\n\n\n\n\n\n\n\n\n\nconst defaultOptions = settings.templateDefaultOptions;\nlet getTemplate_cache;\nfunction shouldResolveRef(schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n    const value = getTemplate_cache[pointer] == null || getTemplate_cache[pointer][$ref] == null ? 0 : getTemplate_cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\nfunction getTemplate_resolveRef(draft, schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n    // @todo pointer + ref is redundant?\n    getTemplate_cache[pointer] = getTemplate_cache[pointer] || {};\n    getTemplate_cache[pointer][$ref] = getTemplate_cache[pointer][$ref] || 0;\n    getTemplate_cache[pointer][$ref] += 1;\n    return draft.resolveRef(schema);\n}\nfunction convertValue(type, value) {\n    if (type === "string") {\n        return JSON.stringify(value);\n    }\n    else if (typeof value !== "string") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    }\n    catch (e) { } // eslint-disable-line no-empty\n    return null;\n}\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n *\n * @param draft\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(draft, schema, data, pointer) {\n    // invalid schema\n    if (getTypeOf(schema) !== "object") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n    // resolve $ref and copy schema\n    let templateSchema = copy(getTemplate_resolveRef(draft, schema, pointer));\n    // @feature anyOf\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = getTemplate_resolveRef(draft, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const mayResolve = schema.allOf\n            .map((allOf, index) => shouldResolveRef(allOf, `${pointer}/allOf/${index}`))\n            .reduceRight((next, before) => next && before, true);\n        if (mayResolve) {\n            const resolvedSchema = mergeAllOfSchema(draft, schema);\n            if (resolvedSchema) {\n                templateSchema = mergeSchema(templateSchema, resolvedSchema);\n            }\n        }\n    }\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\nconst isJsonSchema = (template) => template && typeof template === "object";\n/**\n * Create data object matching the given schema\n *\n * @param draft - json schema draft\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(draft, data, _schema, pointer, opts) {\n    var _a;\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error("Missing pointer");\n    }\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(draft, _schema, data, pointer);\n    if (!isJsonSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\n        return schema.const;\n    }\n    // @feature oneOf\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type = schema.oneOf[0].type ||\n                schema.type ||\n                (schema.const && typeof schema.const) ||\n                getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        }\n        else {\n            // find correct schema for data\n            const resolvedSchema = resolveOneOfFuzzy(draft, data, schema);\n            if (isJsonError(resolvedSchema)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            }\n            else {\n                resolvedSchema.type = (_a = resolvedSchema.type) !== null && _a !== void 0 ? _a : schema.type;\n                schema = resolvedSchema;\n            }\n        }\n    }\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n    if (!isJsonSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n    const type = Array.isArray(schema.type)\n        ? selectType(schema.type, data, schema.default)\n        : schema.type;\n    // reset invalid type\n    const javascriptTypeOfData = getTypeOf(data);\n    if (data != null &&\n        javascriptTypeOfData !== type &&\n        !(javascriptTypeOfData === "number" && type === "integer")) {\n        data = convertValue(type, data);\n    }\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n    const templateData = TYPE[type](draft, schema, data, pointer, opts);\n    return templateData;\n}\nfunction selectType(types, data, defaultValue) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\nconst TYPE = {\n    null: (draft, schema, data) => getDefault(schema, data, null),\n    string: (draft, schema, data) => getDefault(schema, data, ""),\n    number: (draft, schema, data) => getDefault(schema, data, 0),\n    integer: (draft, schema, data) => getDefault(schema, data, 0),\n    boolean: (draft, schema, data) => getDefault(schema, data, false),\n    object: (draft, schema, data, pointer, opts) => {\n        var _a;\n        const template = schema.default === undefined ? {} : schema.default;\n        const d = {}; // do not assign data here, to keep ordering from json-schema\n        const required = (opts.extendDefaults === false && schema.default !== undefined) ? [] : ((_a = schema.required) !== null && _a !== void 0 ? _a : []);\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\n                }\n            });\n        }\n        // @feature dependencies\n        // has to be done after resolving properties so dependency may trigger\n        let dependenciesSchema = resolveDependencies(draft, schema, d);\n        if (dependenciesSchema) {\n            dependenciesSchema = mergeSchema(schema, dependenciesSchema);\n            delete dependenciesSchema.dependencies;\n            const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);\n            Object.assign(d, dependencyData);\n        }\n        if (data) {\n            if (opts.removeInvalidData === true &&\n                (schema.additionalProperties === false ||\n                    getTypeOf(schema.additionalProperties) === "object")) {\n                if (getTypeOf(schema.additionalProperties) === "object") {\n                    Object.keys(data).forEach((key) => {\n                        if (d[key] == null) {\n                            // merge valid missing data (additionals) to resulting object\n                            if (draft.isValid(data[key], schema.additionalProperties)) {\n                                d[key] = data[key];\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                // merge any missing data (additionals) to resulting object\n                Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n            }\n        }\n        // @feature if-then-else\n        const ifSchema = resolveIfSchema(draft, schema, d);\n        if (ifSchema) {\n            const additionalData = getTemplate(draft, d, { type: "object", ...ifSchema }, pointer, opts);\n            Object.assign(d, additionalData);\n        }\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (draft, schema, data, pointer, opts) => {\n        var _a, _b;\n        if (schema.items == null) {\n            return data || []; // items are undefined\n        }\n        const template = schema.default === undefined ? [] : schema.default;\n        const d = data || template;\n        const minItems = (opts.extendDefaults === false && schema.default !== undefined) ? 0 : (schema.minItems || 0);\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            for (let i = 0, l = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_b = (_a = schema.items) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\n            }\n            return d;\n        }\n        // abort if the schema is invalid\n        if (getTypeOf(schema.items) !== "object") {\n            return d;\n        }\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(draft, schema.items, data, pointer);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n        // build data for first oneOf-schema\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < minItems; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\n            }\n            return d;\n        }\n        // complete data selecting correct oneOf-schema\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                let one = resolveOneOfFuzzy(draft, value, templateSchema);\n                if (one == null || isJsonError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    }\n                    else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                }\n                else {\n                    // schema is valid\n                    d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n        // build data from items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\n            }\n            return d;\n        }\n        return d;\n    }\n};\nfunction getDefault(schema, templateValue, initValue) {\n    if (templateValue != null) {\n        return templateValue;\n    }\n    else if (schema.const) {\n        return schema.const;\n    }\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    }\n    else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\n/* harmony default export */ const lib_getTemplate = ((draft, data, schema = draft.rootSchema, opts) => {\n    getTemplate_cache = {};\n    if (opts) {\n        return getTemplate(draft, data, schema, "#", { ...defaultOptions, ...opts });\n    }\n    return getTemplate(draft, data, schema, "#", defaultOptions);\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/isValid.js\n/**\n * Test if the data is valid according to the given schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nfunction isValid(draft, value, schema = draft.rootSchema, pointer = "#") {\n    return draft.validate(value, schema, pointer).length === 0;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js\n/* eslint no-bitwise: 0 */\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nfunction ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It\'s a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It\'s an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js\n/**\n * returns the floating point precision of a decimal number or 0\n */\nfunction getPrecision(value) {\n    const string = `${value}`;\n    const index = string.indexOf(".");\n    return index === -1 ? 0 : string.length - (index + 1);\n}\n\n// EXTERNAL MODULE: ./node_modules/fast-deep-equal/index.js\nvar fast_deep_equal = __webpack_require__(2017);\nvar fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);\n;// ./node_modules/json-schema-library/dist/module/lib/validation/keyword.js\n\n\n\n\n\n\n\n\n\n\n\nconst keyword_hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value, property) => !(value[property] === undefined || !keyword_hasOwnProperty.call(value, property));\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation = {\n    additionalProperties: (draft, schema, value, pointer) => {\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n        if (getTypeOf(schema.patternProperties) === "object" &&\n            schema.additionalProperties === false) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n        const errors = [];\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\n        const expectedProperties = Object.keys(schema.properties || {});\n        if (getTypeOf(schema.patternProperties) === "object") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const additionalIsObject = isObject(schema.additionalProperties);\n                // additionalProperties { oneOf: [] }\n                if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = draft.resolveOneOf(value[property], schema.additionalProperties, `${pointer}/${property}`);\n                    if (isJsonError(result)) {\n                        errors.push(draft.errors.additionalPropertiesError({\n                            pointer,\n                            schema: schema.additionalProperties,\n                            value,\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            // pass all validation errors\n                            errors: result.data.errors\n                        }));\n                    }\n                    else {\n                        errors.push(...draft.validate(value[property], result, pointer));\n                    }\n                    // additionalProperties {}\n                }\n                else if (additionalIsObject) {\n                    errors.push(...draft.validate(value[property], schema.additionalProperties, `${pointer}/${property}`));\n                }\n                else {\n                    errors.push(draft.errors.noAdditionalPropertiesError({\n                        pointer,\n                        schema,\n                        value,\n                        property: receivedProperties[i],\n                        properties: expectedProperties\n                    }));\n                }\n            }\n        }\n        return errors;\n    },\n    allOf: validateAllOf,\n    anyOf: validateAnyOf,\n    dependencies: validateDependencies,\n    enum: (draft, schema, value, pointer) => {\n        const type = getTypeOf(value);\n        if (type === "object" || type === "array") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        }\n        else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return draft.errors.enumError({ pointer, schema, value, values: schema.enum });\n    },\n    format: (draft, schema, value, pointer) => {\n        if (draft.validateFormat[schema.format]) {\n            const errors = draft.validateFormat[schema.format](draft, schema, value, pointer);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (draft, schema, value, pointer) => {\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidDataError({ pointer, value, schema });\n        }\n        const errors = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemSchema = draft.step(i, schema, value, pointer);\n            if (isJsonError(itemSchema)) {\n                return [itemSchema];\n            }\n            const itemErrors = draft.validate(itemData, itemSchema, `${pointer}/${i}`);\n            errors.push(...itemErrors);\n        }\n        return errors;\n    },\n    maximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                value,\n                pointer,\n                schema\n            });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxItems: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return draft.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return draft.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (draft, schema, value, pointer) => {\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return draft.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minLength: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return draft.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minItems: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return draft.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minProperties: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return draft.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (draft, schema, value, pointer) => {\n        if (isNaN(schema.multipleOf) || typeof value !== "number") {\n            return undefined;\n        }\n        const valuePrecision = getPrecision(value);\n        const multiplePrecision = getPrecision(schema.multipleOf);\n        if (valuePrecision > multiplePrecision) {\n            // value with higher precision then multipleOf-precision can never be multiple\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        const precision = Math.pow(10, multiplePrecision);\n        const val = Math.round(value * precision);\n        const multiple = Math.round(schema.multipleOf * precision);\n        if ((val % multiple) / precision !== 0) {\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        // maybe also check overflow\n        // https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (draft, schema, value, pointer) => {\n        const errors = [];\n        if (draft.validate(value, schema.not, pointer).length === 0) {\n            errors.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));\n        }\n        return errors;\n    },\n    oneOf: validateOneOf,\n    pattern: (draft, schema, value, pointer) => {\n        const pattern = new RegExp(schema.pattern, "u");\n        if (pattern.test(value) === false) {\n            return draft.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (draft, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== "object") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    schema,\n                    value,\n                    patterns: Object.keys(pp).join(",")\n                }));\n            }\n        });\n        return errors;\n    },\n    properties: (draft, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemSchema = draft.step(key, schema, value, pointer);\n                const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (draft, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));\n            }\n            else {\n                const itemSchema = draft.step(key, schema, value, pointer);\n                const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (draft, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (!hasProperty(value, property)) {\n                return draft.errors.requiredPropertyError({\n                    key: property,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (draft, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (value[property] == null || value[property] === "") {\n                return draft.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (draft, schema, value, pointer) => {\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n        const duplicates = [];\n        const errors = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (fast_deep_equal_default()(item, value[i]) && !duplicates.includes(i)) {\n                    errors.push(draft.errors.uniqueItemsError({\n                        pointer: `${pointer}/${i}`,\n                        duplicatePointer: `${pointer}/${index}`,\n                        arrayPointer: pointer,\n                        value: JSON.stringify(item),\n                        schema\n                    }));\n                    duplicates.push(i);\n                }\n            }\n        });\n        return errors;\n    }\n};\n/* harmony default export */ const keyword = (KeywordValidation);\n\n;// ./node_modules/json-schema-library/dist/module/lib/createSchemaOf.js\n\n\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n */\nfunction createSchemaOf(data) {\n    if (data === undefined) {\n        return undefined;\n    }\n    const schema = {\n        type: getTypeOf(data)\n    };\n    if (schema.type === "object" && isObject(data)) {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n    if (schema.type === "array" && Array.isArray(data)) {\n        if (data.length === 1) {\n            schema.items = createSchemaOf(data[0]);\n        }\n        else {\n            schema.items = data.map(createSchemaOf);\n        }\n    }\n    return schema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/step.js\n\n\n\n\nconst stepType = {\n    array: (draft, key, schema, data, pointer) => {\n        const itemValue = data === null || data === void 0 ? void 0 : data[key];\n        const itemsType = getTypeOf(schema.items);\n        if (itemsType === "object") {\n            // @spec: ignore additionalItems, when items is schema-object\n            return (reduceSchema(draft, schema.items, itemValue, `${pointer}/${key}`) ||\n                draft.resolveRef(schema.items));\n        }\n        if (itemsType === "array") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return createSchemaOf(itemValue);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return draft.errors.invalidDataError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.items[key]) {\n                return draft.resolveRef(schema.items[key]);\n            }\n            if (schema.additionalItems === false) {\n                return draft.errors.additionalItemsError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return createSchemaOf(itemValue);\n            }\n            if (getTypeOf(schema.additionalItems) === "object") {\n                return schema.additionalItems;\n            }\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);\n        }\n        if (schema.additionalItems !== false && itemValue) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return createSchemaOf(itemValue);\n        }\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\n    },\n    object: (draft, key, schema, data, pointer) => {\n        var _a;\n        schema = reduceSchema(draft, schema, data, pointer);\n        // @feature properties\n        const property = (_a = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _a === void 0 ? void 0 : _a[key];\n        if (property !== undefined) {\n            // @todo patternProperties also validate properties\n            // @feature boolean schema\n            if (property === false) {\n                return draft.errors.forbiddenPropertyError({\n                    property: key,\n                    value: data,\n                    pointer,\n                    schema\n                });\n            }\n            else if (property === true) {\n                return createSchemaOf(data === null || data === void 0 ? void 0 : data[key]);\n            }\n            const targetSchema = draft.resolveRef(property);\n            if (isJsonError(targetSchema)) {\n                return targetSchema;\n            }\n            // check if there is a oneOf selection, which must be resolved\n            if (targetSchema && Array.isArray(targetSchema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                return draft.resolveOneOf(data[key], targetSchema, `${pointer}/${key}`);\n            }\n            // resolved schema or error\n            if (targetSchema) {\n                return targetSchema;\n            }\n        }\n        // @feature patternProperties\n        const { patternProperties } = schema;\n        if (getTypeOf(patternProperties) === "object") {\n            // find matching property key\n            let regex;\n            const patterns = Object.keys(patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return patternProperties[patterns[i]];\n                }\n            }\n        }\n        // @feature additionalProperties\n        const { additionalProperties } = schema;\n        if (getTypeOf(additionalProperties) === "object") {\n            return schema.additionalProperties;\n        }\n        if (data && (additionalProperties === undefined || additionalProperties === true)) {\n            return createSchemaOf(data[key]);\n        }\n        return draft.errors.unknownPropertyError({\n            property: key,\n            value: data,\n            pointer: `${pointer}`,\n            schema\n        });\n    }\n};\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  draft      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nfunction step(draft, key, schema, data, pointer = "#") {\n    var _a;\n    const typeOfData = getTypeOf(data);\n    let schemaType = (_a = schema.type) !== null && _a !== void 0 ? _a : typeOfData;\n    // @draft >= 4 ?\n    if (Array.isArray(schemaType)) {\n        if (!schemaType.includes(typeOfData)) {\n            return draft.errors.typeError({\n                value: data,\n                pointer,\n                expected: schema.type,\n                received: typeOfData,\n                schema\n            });\n        }\n        schemaType = typeOfData;\n    }\n    const stepFunction = stepType[schemaType];\n    if (stepFunction) {\n        const schemaResult = stepFunction(draft, `${key}`, schema, data, pointer);\n        if (schemaResult === undefined) {\n            return draft.errors.schemaWarning({\n                pointer,\n                value: data,\n                schema,\n                key\n            });\n        }\n        return schemaResult;\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js\n\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param draft        - draft to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nfunction getChildSchemaSelection(draft, property, schema = draft.rootSchema) {\n    var _a;\n    if (schema.oneOf) {\n        return schema.oneOf.map((item) => draft.resolveRef(item));\n    }\n    if ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.oneOf) {\n        return schema.items.oneOf.map((item) => draft.resolveRef(item));\n    }\n    const result = draft.step(property, schema, {}, "#");\n    if (isJsonError(result)) {\n        return result;\n    }\n    return [result];\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/validation/type.js\n/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators = {\n    array: (draft, schema, value, pointer) => draft.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    object: (draft, schema, value, pointer) => draft.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    string: (draft, schema, value, pointer) => draft.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    integer: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    number: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    null: (draft, schema, value, pointer) => draft.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer))\n};\n/* harmony default export */ const type = (typeValidators);\n\n;// ./node_modules/json-schema-library/dist/module/lib/validate.js\n\n\n\n\n\nfunction getJsonSchemaType(value, expectedType) {\n    const jsType = getTypeOf(value);\n    if (jsType === "number" &&\n        (expectedType === "integer" ||\n            (Array.isArray(expectedType) && expectedType.includes("integer")))) {\n        return Number.isInteger(value) || isNaN(value) ? "integer" : "number";\n    }\n    return jsType;\n}\n/**\n * Validates data with json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nfunction validate(draft, value, schema = draft.rootSchema, pointer = "#") {\n    schema = draft.resolveRef(schema);\n    // @draft >= 07\n    if (getTypeOf(schema) === "boolean") {\n        if (schema) {\n            return [];\n        }\n        return [draft.errors.invalidDataError({ pointer, schema, value })];\n    }\n    if (isJsonError(schema)) {\n        return [schema];\n    }\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (fast_deep_equal_default()(schema.const, value)) {\n            return [];\n        }\n        return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];\n    }\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n    if (receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\n        return [\n            draft.errors.typeError({\n                pointer,\n                schema,\n                value,\n                received: receivedType,\n                expected: expectedType\n            })\n        ];\n    }\n    if (draft.validateType[receivedType] == null) {\n        return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];\n    }\n    // get type validation results\n    const errors = flattenArray(draft.validateType[receivedType](draft, schema, value, pointer));\n    return errors.filter(errorOrPromise); // ignore promises here\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft04/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft04Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "uniqueItems"\n        ],\n        boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],\n        object: [\n            "additionalProperties",\n            "dependencies",\n            "enum",\n            "format",\n            "minProperties",\n            "maxProperties",\n            "patternProperties",\n            "properties",\n            "required",\n            "not",\n            "oneOf",\n            "allOf",\n            "anyOf"\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    validateKeyword: keyword,\n    validateType: type,\n    validateFormat: format,\n    errors: validation_errors,\n    addRemoteSchema: addRemoteSchema,\n    compileSchema: lib_compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft04 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft04Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js\n\n// import remotes from "../../../remotes";\n\n\n\nconst compile_COMPILED = "__compiled";\nconst compile_COMPILED_REF = "__ref";\nconst compile_GET_REF = "getRef";\nconst compile_GET_ROOT = "getRoot";\nconst draft06_compile_suffixes = /(#|\\/)+$/g;\n/**\n * @draft starting with _draft 06_ keyword `id` has been renamed to `$id`\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nfunction compile_compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    // @ts-expect-error incomplete JsonSchema type\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[compile_COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperty(compiledSchema, compile_COMPILED, { enumerable: false, value: true });\n    Object.defineProperty(compiledSchema, compile_GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes("$ref") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, "$defs", {\n            enumerable: true,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith("http") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, "");\n                const parentSchema = (0,jsonPointer.get)(compiledSchema, parentPointer);\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\n            }\n            context.ids[schema.$id.replace(draft06_compile_suffixes, "")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, "#");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, "");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, "");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[compile_COMPILED_REF]) {\n            Object.defineProperty(schema, compile_COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, compile_GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log("compiled ref", scope, schema.$ref, "=>", joinScope(scope, schema.$ref));\n        }\n    });\n    return compiledSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js\n\n\n\nconst keyword_KeywordValidation = {\n    ...keyword,\n    // @draft >= 6\n    contains: (draft, schema, value, pointer) => {\n        if (schema.contains === false) {\n            return draft.errors.containsArrayError({ pointer, value, schema });\n        }\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return draft.errors.containsAnyError({ pointer, value, schema });\n            }\n            return undefined;\n        }\n        if (getTypeOf(schema.contains) !== "object") {\n            // ignore invalid schema\n            return undefined;\n        }\n        for (let i = 0; i < value.length; i += 1) {\n            if (draft.isValid(value[i], schema.contains)) {\n                return undefined;\n            }\n        }\n        return draft.errors.containsError({ pointer, schema, value });\n    },\n    exclusiveMaximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return draft.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return draft.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    // @feature if-then-else\n    if: validateIf,\n    maximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (draft, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== "object") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(draft.errors.patternPropertiesError({\n                            key,\n                            pointer,\n                            patterns: Object.keys(pp).join(","),\n                            schema,\n                            value\n                        }));\n                        return;\n                    }\n                    const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(","),\n                    schema,\n                    value\n                }));\n            }\n        });\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (draft, schema, value, pointer) => {\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value,\n                schema\n            });\n        }\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n        if (getTypeOf(schema.propertyNames) !== "object") {\n            // ignore invalid schema\n            return undefined;\n        }\n        const errors = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: "string" };\n        properties.forEach((prop) => {\n            const validationResult = draft.validate(prop, propertySchema, `${pointer}/${prop}`);\n            if (validationResult.length > 0) {\n                errors.push(draft.errors.invalidPropertyNameError({\n                    property: prop,\n                    pointer,\n                    validationError: validationResult[0],\n                    value: value[prop],\n                    schema\n                }));\n            }\n        });\n        return errors;\n    }\n};\n/* harmony default export */ const validation_keyword = (keyword_KeywordValidation);\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/validation/type.js\n/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst validationType = {\n    array: (draft, schema, value, pointer) => draft.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    object: (draft, schema, value, pointer) => draft.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    string: (draft, schema, value, pointer) => draft.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    integer: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    number: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    null: (draft, schema, value, pointer) => draft.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer))\n};\n/* harmony default export */ const validation_type = (validationType);\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft06Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "contains",\n            "enum",\n            "if",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "uniqueItems"\n        ],\n        boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],\n        object: [\n            "additionalProperties",\n            "allOf",\n            "anyOf",\n            "dependencies",\n            "enum",\n            "format",\n            "if",\n            "maxProperties",\n            "minProperties",\n            "not",\n            "oneOf",\n            "patternProperties",\n            "properties",\n            "propertyNames",\n            "required"\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "if",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "enum",\n            "exclusiveMaximum",\n            "exclusiveMinimum",\n            "format",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf",\n            "allOf",\n            "anyOf",\n            "if"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    validateKeyword: validation_keyword,\n    validateType: validation_type,\n    validateFormat: format,\n    errors: validation_errors,\n    addRemoteSchema: addRemoteSchema,\n    compileSchema: compile_compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft06 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft06Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft07/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft07Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "contains",\n            "enum",\n            "if",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "uniqueItems"\n        ],\n        boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],\n        object: [\n            "additionalProperties",\n            "allOf",\n            "anyOf",\n            "dependencies",\n            "enum",\n            "format",\n            "if",\n            "maxProperties",\n            "minProperties",\n            "not",\n            "oneOf",\n            "patternProperties",\n            "properties",\n            "propertyNames",\n            "required"\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "if",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "exclusiveMaximum",\n            "exclusiveMinimum",\n            "format",\n            "if",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    validateKeyword: validation_keyword,\n    validateType: validation_type,\n    validateFormat: format,\n    errors: validation_errors,\n    addRemoteSchema: addRemoteSchema,\n    compileSchema: compile_compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft07 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft07Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js\n\n\n\n\n\nconst draftJsonEditorConfig = {\n    ...draft07Config,\n    resolveOneOf: resolveOneOfFuzzy,\n    resolveRef: resolveRefMerge\n};\nclass JsonEditor extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draftJsonEditorConfig, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst config = { strings: strings };\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGtCQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixrQkFBa0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxrQkFBa0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksVUFBTTtBQUNWLGdFQUFnRSx1QkFBdUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQU0sR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtB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QUFRO0FBQzdCLGtCQUFrQixlQUFLO0FBQ3ZCLG9CQUFvQixNQUFPO0FBQzNCLFlBQVksaUJBQU07QUFDbEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsUUFBUTtBQUNSLGNBQWM7QUFDZCwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLGVBQWU7QUFDZixXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLFFBQVE7QUFDUixZQUFZO0FBQ1osNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSxzQkFBc0IsS0FBSztBQUMzQixtQ0FBbUM7QUFDbkMsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDa0M7OztBQzdHQztBQUNtQjtBQUNUO0FBQ1o7QUFDVTtBQUMzQztBQUNBLE9BQU8sYUFBYTtBQUNwQixrQkFBa0IsaUJBQWlCO0FBQ25DLGNBQWM7QUFDZDtBQUNBLHlCQUF5QixLQUFLO0FBQzlCLG1DQUFtQztBQUNuQyxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUM2Qzs7O0FDZmtDO0FBQ3ZDO0FBQytCO0FBQ25CO0FBQ0g7QUFDSTtBQUNSO0FBQ0Y7QUFDSztBQUNFO0FBQ2lDO0FBQ25DO0FBQ1I7QUFDSjtBQUNtQjtBQUNBO0FBQ0E7QUFDYztBQUMzQjtBQUMxQyxpQkFBaUIsT0FBTztBQWVyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9jb25maWcvc3RyaW5ncy5qcz82NDNjIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9nZXRUeXBlT2YuanM/ZDRlNyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvcmVuZGVyLmpzPzYyMzkiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL19fLmpzPzA4NWUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2NyZWF0ZUN1c3RvbUVycm9yLmpzPzg0YTgiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2ZsYXR0ZW5BcnJheS5qcz85M2NiIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9jb25maWcvc2V0dGluZ3MuanM/ZTg4NSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvc2NoZW1hL2NyZWF0ZU9uZU9mU2NoZW1hUmVzdWx0LmpzPzYwZTciLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzP2M0ZDQiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2ZpbHRlci5qcz8zNDUwIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9mZWF0dXJlcy9vbmVPZi5qcz8zNTIzIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9tZXJnZS5qcz81YjM2Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9tZXJnZVNjaGVtYS5qcz82Y2U2Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9vbWl0LmpzPzI1NDEiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY29weS9kaXN0L2VzbS9pbmRleC5tanM/NTM4NSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvY29weS5qcz84ZmVlIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9mZWF0dXJlcy9pZi5qcz8wZTc4Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9mZWF0dXJlcy9hbGxPZi5qcz84OTA1Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9yZXNvbHZlUmVmLnN0cmljdC5qcz84NTVmIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9yZXNvbHZlUmVmLm1lcmdlLmpzPzE1ZWQiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3ZhbGlkYXRlQXN5bmMuanM/MjVmNSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvdW5pcXVlSXRlbXMuanM/NDAwYiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvaXNPYmplY3QuanM/YTc0MiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZmVhdHVyZXMvZGVwZW5kZW5jaWVzLmpzP2RhNTAiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2ZlYXR1cmVzL2FueU9mLmpzPzczZDAiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3Jlc29sdmVEeW5hbWljU2NoZW1hLmpzPzQ1MWUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3JlZHVjZVNjaGVtYS5qcz9lYzkzIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9kcmFmdC9pbmRleC5qcz9kZTNmIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9hZGRSZW1vdGVTY2hlbWEuanM/N2YxNyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHNhZ29sZC9qc29uLXF1ZXJ5L2Rpc3QvbW9kdWxlL2xpYi9wYXJzZXIvanNvblF1ZXJ5R3JhbW1hci5qcz9lNDU0Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9Ac2Fnb2xkL2pzb24tcXVlcnkvZGlzdC9tb2R1bGUvbGliL3BhcnNlci9pbmRleC5qcz84ZjZjIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9Ac2Fnb2xkL2pzb24tcXVlcnkvZGlzdC9tb2R1bGUvbGliL2ludGVycHJldGVyL2tleXMuanM/MDYwZCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHNhZ29sZC9qc29uLXF1ZXJ5L2Rpc3QvbW9kdWxlL2xpYi9pbnRlcnByZXRlci9ub2Rlcy5qcz80NTk2Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9Ac2Fnb2xkL2pzb24tcXVlcnkvZGlzdC9tb2R1bGUvbGliL2ludGVycHJldGVyL2luZGV4LmpzP2NhN2MiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzYWdvbGQvanNvbi1xdWVyeS9kaXN0L21vZHVsZS9saWIvZ2V0LmpzPzA2NGYiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzYWdvbGQvanNvbi1xdWVyeS9kaXN0L21vZHVsZS9saWIvc3BsaXQuanM/ODQ5MiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHNhZ29sZC9qc29uLXF1ZXJ5L2Rpc3QvbW9kdWxlL2xpYi9zZXQuanM/OTc1ZSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHNhZ29sZC9qc29uLXF1ZXJ5L2Rpc3QvbW9kdWxlL2xpYi9yZW1vdmUuanM/MGNkNCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHNhZ29sZC9qc29uLXF1ZXJ5L2Rpc3QvbW9kdWxlL2luZGV4LmpzPzY4MmQiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3NjaGVtYS90eXBlcy5qcz81NmE2Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9zY2hlbWEvZ2V0VHlwZUlkLmpzPzczZTUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3NjaGVtYS9nZXRUeXBlRGVmcy5qcz84YzRhIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9lYWNoU2NoZW1hLmpzP2Q1MDIiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2NvbXBpbGUvam9pblNjb3BlLmpzPzIwMGUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2NvbXBpbGUvc3BsaXRSZWYuanM/NjQ5YSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvY29tcGlsZS9nZXRSZWYuanM/NzFjMiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvY29tcGlsZS9pbmRleC5qcz9mOTE4Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9jb21waWxlU2NoZW1hLmpzP2ZkOTUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2VhY2guanM/M2Q0MiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdmFsaWRhdGlvbi9lcnJvcnMuanM/Y2Q4NyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdmFsaWRhdGlvbi9mb3JtYXQuanM/ZmExOCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZ2V0U2NoZW1hLmpzP2MyMTciLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2lzRW1wdHkuanM/NjJmOSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZ2V0VGVtcGxhdGUuanM/MmY0MSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvaXNWYWxpZC5qcz9iNDY1Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9wdW55Y29kZS51Y3MyZGVjb2RlLmpzPzZjOGYiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2dldFByZWNpc2lvbi5qcz85ZjRmIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi92YWxpZGF0aW9uL2tleXdvcmQuanM/NWQyMCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvY3JlYXRlU2NoZW1hT2YuanM/MzIyMSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvc3RlcC5qcz85NWU1Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9nZXRDaGlsZFNjaGVtYVNlbGVjdGlvbi5qcz9iNWZhIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi92YWxpZGF0aW9uL3R5cGUuanM/MDBjZSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdmFsaWRhdGUuanM/Nzc0OSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNC9pbmRleC5qcz83N2E2Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9kcmFmdDA2L2NvbXBpbGUvaW5kZXguanM/ZDcwYSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNi92YWxpZGF0aW9uL2tleXdvcmQuanM/Nzk0NCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNi92YWxpZGF0aW9uL3R5cGUuanM/MmU4YyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNi9pbmRleC5qcz8xMzYwIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9kcmFmdDA3L2luZGV4LmpzPzAyMDkiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2pzb25lZGl0b3IvaW5kZXguanM/M2EzYyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9pbmRleC5qcz83MmRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBtYXgtbGVuOiAwICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLy8gdmFsaWRhdGlvbiBlcnJvcnNcbiAgICBBZGRpdGlvbmFsSXRlbXNFcnJvcjogXCJBcnJheSBhdCBge3twb2ludGVyfX1gIG1heSBub3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGl0ZW0gYHt7a2V5fX1gXCIsXG4gICAgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcjogXCJBZGRpdGlvbmFsIHByb3BlcnR5IGB7e3Byb3BlcnR5fX1gIG9uIGB7e3BvaW50ZXJ9fWAgZG9lcyBub3QgbWF0Y2ggc2NoZW1hIGB7e3NjaGVtYX19YFwiLFxuICAgIEFsbE9mRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBkb2VzIG5vdCBtYXRjaCBzY2hlbWEgb2YgYHt7YWxsT2Z9fWBcIixcbiAgICBBbnlPZkVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYSBvZiBge3thbnlPZn19YFwiLFxuICAgIENvbnN0RXJyb3I6IFwiRXhwZWN0ZWQgdmFsdWUgYXQgYHt7cG9pbnRlcn19YCB0byBiZSBge3tleHBlY3RlZH19YCwgYnV0IHZhbHVlIGdpdmVuIGlzIGB7e3ZhbHVlfX1gXCIsXG4gICAgY29udGFpbnNBbnlFcnJvcjogXCJUaGUgYXJyYXkgYXQgYHt7cG9pbnRlcn19YCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGl0ZW1cIixcbiAgICBDb250YWluc0FycmF5RXJyb3I6IFwiVGhlIHByb3BlcnR5IGF0IGB7e3BvaW50ZXJ9fWAgbXVzdCBub3QgYmUgYW4gYXJyYXlcIixcbiAgICBDb250YWluc0Vycm9yOiBcIlRoZSBhcnJheSBhdCBge3twb2ludGVyfX1gIG11c3QgY29udGFpbiBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyBge3tzY2hlbWF9fWBcIixcbiAgICBFbnVtRXJyb3I6IFwiRXhwZWN0ZWQgZ2l2ZW4gdmFsdWUgYHt7dmFsdWV9fWAgaW4gYHt7cG9pbnRlcn19YCB0byBiZSBvbmUgb2YgYHt7dmFsdWVzfX1gXCIsXG4gICAgRm9yYmlkZGVuUHJvcGVydHlFcnJvcjogXCJQcm9wZXJ0eSBuYW1lIGB7e3Byb3BlcnR5fX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGFsbG93ZWRcIixcbiAgICBGb3JtYXREYXRlRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCBkYXRlXCIsXG4gICAgRm9ybWF0RGF0ZVRpbWVFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIGRhdGUtdGltZVwiLFxuICAgIEZvcm1hdEVtYWlsRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCBlbWFpbFwiLFxuICAgIEZvcm1hdEhvc3RuYW1lRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCBob3N0bmFtZVwiLFxuICAgIEZvcm1hdElQVjRFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIElQdjQgYWRkcmVzc1wiLFxuICAgIEZvcm1hdElQVjRMZWFkaW5nWmVyb0Vycm9yOiBcIklQdjQgYWRkcmVzc2VzIHN0YXJ0aW5nIHdpdGggemVybyBhcmUgaW52YWxpZCwgc2luY2UgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWxzXCIsXG4gICAgRm9ybWF0SVBWNkVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgSVB2NiBhZGRyZXNzXCIsXG4gICAgRm9ybWF0SVBWNkxlYWRpbmdaZXJvRXJyb3I6IFwiSVB2NiBhZGRyZXNzZXMgc3RhcnRpbmcgd2l0aCB6ZXJvIGFyZSBpbnZhbGlkLCBzaW5jZSB0aGV5IGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbHNcIixcbiAgICBGb3JtYXRKc29uUG9pbnRlckVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQganNvbi1wb2ludGVyXCIsXG4gICAgRm9ybWF0UmVnRXhFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvblwiLFxuICAgIEZvcm1hdFRpbWVFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIHRpbWVcIixcbiAgICBGb3JtYXRVUklFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIHVyaVwiLFxuICAgIEZvcm1hdFVSSVJlZmVyZW5jZUVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgdXJpLXJlZmVyZW5jZVwiLFxuICAgIEZvcm1hdFVSSVRlbXBsYXRlRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCB1cmktdGVtcGxhdGVcIixcbiAgICBGb3JtYXRVUkxFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIHVybFwiLFxuICAgIEludmFsaWREYXRhRXJyb3I6IFwiTm8gdmFsdWUgbWF5IGJlIHNwZWNpZmllZCBpbiBge3twb2ludGVyfX1gXCIsXG4gICAgSW52YWxpZFByb3BlcnR5TmFtZUVycm9yOiBcIkludmFsaWQgcHJvcGVydHkgbmFtZSBge3twcm9wZXJ0eX19YCBhdCBge3twb2ludGVyfX1gXCIsXG4gICAgTWF4aW11bUVycm9yOiBcIlZhbHVlIGluIGB7e3BvaW50ZXJ9fWAgaXMgYHt7bGVuZ3RofX1gLCBidXQgc2hvdWxkIGJlIGB7e21heGltdW19fWAgYXQgbWF4aW11bVwiLFxuICAgIE1heEl0ZW1zRXJyb3I6IFwiVG9vIG1hbnkgaXRlbXMgaW4gYHt7cG9pbnRlcn19YCwgc2hvdWxkIGJlIGB7e21heGltdW19fWAgYXQgbW9zdCwgYnV0IGdvdCBge3tsZW5ndGh9fWBcIixcbiAgICBNYXhMZW5ndGhFcnJvcjogXCJWYWx1ZSBge3twb2ludGVyfX1gIHNob3VsZCBoYXZlIGEgbWF4aW11bSBsZW5ndGggb2YgYHt7bWF4TGVuZ3RofX1gLCBidXQgZ290IGB7e2xlbmd0aH19YC5cIixcbiAgICBNYXhQcm9wZXJ0aWVzRXJyb3I6IFwiVG9vIG1hbnkgcHJvcGVydGllcyBpbiBge3twb2ludGVyfX1gLCBzaG91bGQgYmUgYHt7bWF4aW11bX19YCBhdCBtb3N0LCBidXQgZ290IGB7e2xlbmd0aH19YFwiLFxuICAgIE1pbmltdW1FcnJvcjogXCJWYWx1ZSBpbiBge3twb2ludGVyfX1gIGlzIGB7e2xlbmd0aH19YCwgYnV0IHNob3VsZCBiZSBge3ttaW5pbXVtfX1gIGF0IG1pbmltdW1cIixcbiAgICBNaW5JdGVtc0Vycm9yOiBcIlRvbyBmZXcgaXRlbXMgaW4gYHt7cG9pbnRlcn19YCwgc2hvdWxkIGJlIGF0IGxlYXN0IGB7e21pbmltdW19fWAsIGJ1dCBnb3QgYHt7bGVuZ3RofX1gXCIsXG4gICAgTWluSXRlbXNPbmVFcnJvcjogXCJBdCBsZWFzdCBvbmUgaXRlbSBpcyByZXF1aXJlZCBpbiBge3twb2ludGVyfX1gXCIsXG4gICAgTWluTGVuZ3RoRXJyb3I6IFwiVmFsdWUgYHt7cG9pbnRlcn19YCBzaG91bGQgaGF2ZSBhIG1pbmltdW0gbGVuZ3RoIG9mIGB7e21pbkxlbmd0aH19YCwgYnV0IGdvdCBge3tsZW5ndGh9fWAuXCIsXG4gICAgTWluTGVuZ3RoT25lRXJyb3I6IFwiQSB2YWx1ZSBpcyByZXF1aXJlZCBpbiBge3twb2ludGVyfX1gXCIsXG4gICAgTWluUHJvcGVydGllc0Vycm9yOiBcIlRvbyBmZXcgcHJvcGVydGllcyBpbiBge3twb2ludGVyfX1gLCBzaG91bGQgYmUgYXQgbGVhc3QgYHt7bWluaW11bX19YCwgYnV0IGdvdCBge3tsZW5ndGh9fWBcIixcbiAgICBNaXNzaW5nRGVwZW5kZW5jeUVycm9yOiBcIlRoZSByZXF1aXJlZCBwcm9wZXJ5ICd7e21pc3NpbmdQcm9wZXJ0eX19JyBpbiBge3twb2ludGVyfX1gIGlzIG1pc3NpbmdcIixcbiAgICBNaXNzaW5nT25lT2ZQcm9wZXJ0eUVycm9yOiBcIlZhbHVlIGF0IGB7e3BvaW50ZXJ9fWAgcHJvcGVydHk6IGB7e3Byb3BlcnR5fX1gXCIsXG4gICAgTXVsdGlwbGVPZkVycm9yOiBcIkV4cGVjdGVkIGB7e3ZhbHVlfX1gIGluIGB7e3BvaW50ZXJ9fWAgdG8gYmUgbXVsdGlwbGUgb2YgYHt7bXVsdGlwbGVPZn19YFwiLFxuICAgIE11bHRpcGxlT25lT2ZFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBzaG91bGQgbm90IG1hdGNoIG11bHRpcGxlIHNjaGVtYXMgaW4gb25lT2YgYHt7bWF0Y2hlc319YFwiLFxuICAgIE5vQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcjogXCJBZGRpdGlvbmFsIHByb3BlcnR5IGB7e3Byb3BlcnR5fX1gIGluIGB7e3BvaW50ZXJ9fWAgaXMgbm90IGFsbG93ZWRcIixcbiAgICBOb3RFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBwb2ludGVyIHNob3VsZCBub3QgbWF0Y2ggc2NoZW1hIGB7e25vdH19YFwiLFxuICAgIE9uZU9mRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgaW4gYHt7cG9pbnRlcn19YCBkb2VzIG5vdCBtYXRjaCBhbnkgZ2l2ZW4gb25lb2Ygc2NoZW1hXCIsXG4gICAgT25lT2ZQcm9wZXJ0eUVycm9yOiBcIkZhaWxlZCBmaW5kaW5nIGEgbWF0Y2hpbmcgb25lT2ZQcm9wZXJ0eSBzY2hlbWEgaW4gYHt7cG9pbnRlcn19YCB3aGVyZSBge3twcm9wZXJ0eX19YCBtYXRjaGVzIGB7e3ZhbHVlfX1gXCIsXG4gICAgUGF0dGVybkVycm9yOiBcIlZhbHVlIGluIGB7e3BvaW50ZXJ9fWAgc2hvdWxkIG1hdGNoIGB7e2Rlc2NyaXB0aW9ufX1gLCBidXQgcmVjZWl2ZWQgYHt7cmVjZWl2ZWR9fWBcIixcbiAgICBQYXR0ZXJuUHJvcGVydGllc0Vycm9yOiBcIlByb3BlcnR5IGB7e2tleX19YCBkb2VzIG5vdCBtYXRjaCBhbnkgcGF0dGVybnMgaW4gYHt7cG9pbnRlcn19YC4gVmFsaWQgcGF0dGVybnMgYXJlOiB7e3BhdHRlcm5zfX1cIixcbiAgICBSZXF1aXJlZFByb3BlcnR5RXJyb3I6IFwiVGhlIHJlcXVpcmVkIHByb3BlcnR5IGB7e2tleX19YCBpcyBtaXNzaW5nIGF0IGB7e3BvaW50ZXJ9fWBcIixcbiAgICBTY2hlbWFXYXJuaW5nOiBcIkZhaWxlZCByZXRyaWV2aW5nIGEgc2NoZW1hIGZyb20gJ3t7cG9pbnRlcn19JyB0byBrZXkgJ3t7a2V5fX0nXCIsXG4gICAgVHlwZUVycm9yOiBcIkV4cGVjdGVkIGB7e3ZhbHVlfX1gICh7e3JlY2VpdmVkfX0pIGluIGB7e3BvaW50ZXJ9fWAgdG8gYmUgb2YgdHlwZSBge3tleHBlY3RlZH19YFwiLFxuICAgIFVuZGVmaW5lZFZhbHVlRXJyb3I6IFwiVmFsdWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIGluIGB7e3BvaW50ZXJ9fWBcIixcbiAgICBVbmlxdWVJdGVtc0Vycm9yOiBcIkl0ZW1zIGluIGFycmF5IG11c3QgYmUgdW5pcXVlLiBWYWx1ZSBge3t2YWx1ZX19YCBpbiBge3twb2ludGVyfX1gIGlzIGEgZHVwbGljYXRlIG9mIHt7ZHVwbGljYXRlUG9pbnRlcn19LlwiLFxuICAgIFVua25vd25Qcm9wZXJ0eUVycm9yOiBcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgc2NoZW1hIGZvciBwcm9wZXJ0eSBge3twb2ludGVyfX1gIHdpdGhpbiBvYmplY3RcIixcbiAgICBWYWx1ZU5vdEVtcHR5RXJyb3I6IFwiQSB2YWx1ZSBmb3IgYHt7cHJvcGVydHl9fWAgaXMgcmVxdWlyZWQgYXQgYHt7cG9pbnRlcn19YFwiXG59O1xuIiwiY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VHlwZU9mKHZhbHVlKSB7XG4gICAgY29uc3QgdHlwZSA9IHRvU3RyaW5nXG4gICAgICAgIC5jYWxsKHZhbHVlKVxuICAgICAgICAubWF0Y2goL1xccyhbXlxcXV0rKVxcXS8pXG4gICAgICAgIC5wb3AoKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuIiwiaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi4vZ2V0VHlwZU9mXCI7XG5jb25zdCBPQkpFQ1RfVFlQRSA9IFwib2JqZWN0XCI7XG5jb25zdCBBUlJBWV9UWVBFID0gXCJhcnJheVwiO1xuLyoqXG4gKiBSZW5kZXJzIGRhdGEgaW50byBhIHN0cmluZyBieSB7e3ZhcmlhYmxlc319LlxuICogR2l2ZW4gYSB0ZW1wbGF0ZSBzdHJpbmcsIHJlbW92ZXMgYWxsIHt7cHJvcGVydHl9fSBzdWJzdHJpbmdzIGFuZCByZXBsYWNlcyB0aGVtIHdpdGggdGhlIHByb3BlcnR5IGluIHRoZSBnaXZlbiBkYXRhXG4gKlxuICogQHBhcmFtIHRlbXBsYXRlIC0gdGVtcGxhdGUgc3RyaW5nIGNvbnRhaW5pbmcgdmFyaWFibGVzIGluIGhhbmRlbGJhcnMvbXVzdGFjaGUgc3R5bGVcbiAqIEBwYXJhbSBkYXRhIC0gZmxhdCBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIG1hdGNoaW5nIHZhcmlhYmxlc1xuICogQHJldHVybiByZW5kZXJlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVyKHRlbXBsYXRlLCBkYXRhID0ge30pIHtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFx7XFx7XFx3K1xcfVxcfS9nLCAobWF0Y2gpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gbWF0Y2gucmVwbGFjZSgvW3t9XS9nLCBcIlwiKTtcbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSBkYXRhW2tleV07XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlVHlwZSA9IGdldFR5cGVPZih2YXJpYWJsZSk7XG4gICAgICAgIGlmICh2YXJpYWJsZVR5cGUgPT09IE9CSkVDVF9UWVBFIHx8IHZhcmlhYmxlVHlwZSA9PT0gQVJSQVlfVFlQRSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgc3RyaW5ncyBmcm9tIFwiLi4vY29uZmlnL3N0cmluZ3NcIjtcbmltcG9ydCByZW5kZXIgZnJvbSBcIi4vcmVuZGVyXCI7XG4vKipcbiAqIFJlbmRlcnMgdGhlIGdpdmVuIHN0cmluZyBhcyBkZWZpbmVkIGluIF9fQHNlZSBjb25maWcvc3RyaW5ncy5qc19fXG4gKiBAcGFyYW0ga2V5d29yZFxuICogQHBhcmFtIGRhdGEgLSB0ZW1wbGF0ZSBkYXRhXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBmYWxsYmFjayB0ZW1wbGF0ZVxuICogQHJldHVybiByZXN1bHRpbmcgc3RyaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9fKGtleXdvcmQsIGRhdGEsIGZhbGxiYWNrID0ga2V5d29yZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IChfYSA9IHN0cmluZ3Nba2V5d29yZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbGxiYWNrO1xuICAgIHJldHVybiByZW5kZXIodGVtcGxhdGUsIGRhdGEpO1xufVxuIiwiaW1wb3J0IF9fIGZyb20gXCIuL19fXCI7XG5mdW5jdGlvbiBkYXNoQ2FzZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG5hbWUsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNvZGU6IGRhc2hDYXNlKG5hbWUpLFxuICAgICAgICBtZXNzYWdlOiBfXyhuYW1lLCBkYXRhKSxcbiAgICAgICAgZGF0YVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gRXJyb3IgQ3JlYXRvci4gSXRzIG1lc3NhZ2VzIGFyZSBkZWZpbmVkIGJ5IHN0cmluZ3Mtb2JqZWN0IEBzZWUgY29uZmlnL3N0cmluZ3MudHNcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIGlkIG9mIGVycm9yIChjYW1lbGNhc2VkKVxuICogQHJldHVybiBlcnJvciBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXJyb3IobmFtZSkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvci5iaW5kKG51bGwsIG5hbWUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmxhdHRlbkFycmF5KGxpc3QsIHJlc3VsdCA9IFtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgZmxhdHRlbkFycmF5KGl0ZW0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIERFQ0xBUkFUT1JfT05FT0Y6IFwib25lT2ZQcm9wZXJ0eVwiLFxuICAgIEdFVF9URU1QTEFURV9SRUNVUlNJT05fTElNSVQ6IDEsXG4gICAgcHJvcGVydHlCbGFja2xpc3Q6IFtcIl9pZFwiXSxcbiAgICB0ZW1wbGF0ZURlZmF1bHRPcHRpb25zOiB7XG4gICAgICAgIGFkZE9wdGlvbmFsUHJvcHM6IGZhbHNlLFxuICAgICAgICByZW1vdmVJbnZhbGlkRGF0YTogZmFsc2UsXG4gICAgICAgIGV4dGVuZERlZmF1bHRzOiB0cnVlXG4gICAgfVxufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPbmVPZlNjaGVtYVJlc3VsdChzY2hlbWEsIG9uZU9mU2NoZW1hLCBvbmVPZkluZGV4KSB7XG4gICAgY29uc3QgY2hpbGRTY2hlbWEgPSB7IC4uLm9uZU9mU2NoZW1hIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkU2NoZW1hLCBcImdldE9uZU9mT3JpZ2luXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgICAgaW5kZXg6IG9uZU9mSW5kZXgsXG4gICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gY2hpbGRTY2hlbWE7XG59XG4iLCIvKipcbiAqIHRzIHR5cGUgZ3VhcmQgZm9yIGpzb24gZXJyb3JcbiAqIEByZXR1cm5zIHRydWUgaWYgcGFzc2VkIHR5cGUgaXMgYSBKc29uRXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSnNvbkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IudHlwZSkgPT09IFwiZXJyb3JcIjtcbn1cbiIsImltcG9ydCB7IGlzSnNvbkVycm9yIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yT3JQcm9taXNlKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzSnNvbkVycm9yKGVycm9yKSB8fCBpc1Byb21pc2UoZXJyb3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yc09ubHkoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNKc29uRXJyb3IoZXJyb3IpO1xufVxuIiwiLyoqXG4gKiBAZHJhZnQtMDRcbiAqL1xuaW1wb3J0IGZsYXR0ZW5BcnJheSBmcm9tIFwiLi4vdXRpbHMvZmxhdHRlbkFycmF5XCI7XG5pbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi9nZXRUeXBlT2ZcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vY29uZmlnL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBjcmVhdGVPbmVPZlNjaGVtYVJlc3VsdCB9IGZyb20gXCIuLi9zY2hlbWEvY3JlYXRlT25lT2ZTY2hlbWFSZXN1bHRcIjtcbmltcG9ydCB7IGVycm9yT3JQcm9taXNlIH0gZnJvbSBcIi4uL3V0aWxzL2ZpbHRlclwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmNvbnN0IHsgREVDTEFSQVRPUl9PTkVPRiB9ID0gc2V0dGluZ3M7XG4vKipcbiAqIFNlbGVjdHMgYW5kIHJldHVybnMgYSBvbmVPZiBzY2hlbWEgZm9yIHRoZSBnaXZlbiBkYXRhXG4gKlxuICogQHBhcmFtIGRyYWZ0IC0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIHNjaGVtYSAtIGN1cnJlbnQganNvbiBzY2hlbWEgY29udGFpbmluZyBwcm9wZXJ0eSBvbmVPZlxuICogQHBhcmFtIHBvaW50ZXIgLSBqc29uIHBvaW50ZXIgdG8gZGF0YVxuICogQHJldHVybiBvbmVPZiBzY2hlbWEgb3IgYW4gZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPbmVPZihkcmFmdCwgZGF0YSwgc2NoZW1hID0gZHJhZnQucm9vdFNjaGVtYSwgcG9pbnRlciA9IFwiI1wiKSB7XG4gICAgLy8gIWtleXdvcmQ6IG9uZU9mUHJvcGVydHlcbiAgICAvLyBhbiBhZGRpdGlvbmFsIDxERUNMQVJBVE9SX09ORU9GPiAoZGVmYXVsdCBgb25lT2ZQcm9wZXJ0eWApIG9uIHRoZSBzY2hlbWEgd2lsbCBleGFjdGx5IGRldGVybWluZSB0aGVcbiAgICAvLyBvbmVPZiB2YWx1ZSAoaWYgc2V0IGluIGRhdGEpXG4gICAgLy8gQGZpeG1lXG4gICAgLy8gYWJvcnQgaWYgbm8gZGF0YSBpcyBnaXZlbiBhbiBERUNMQVJBVE9SX09ORU9GIGlzIHNldCAodXNlZCBieSBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbilcbiAgICAvLyB0aGlzIGNhc2UgKGRhdGEgIT0gbnVsbCkgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnlcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmIHNjaGVtYVtERUNMQVJBVE9SX09ORU9GXSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgb25lT2ZQcm9wZXJ0eSA9IHNjaGVtYVtERUNMQVJBVE9SX09ORU9GXTtcbiAgICAgICAgY29uc3Qgb25lT2ZWYWx1ZSA9IGRhdGFbc2NoZW1hW0RFQ0xBUkFUT1JfT05FT0ZdXTtcbiAgICAgICAgaWYgKG9uZU9mVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taXNzaW5nT25lT2ZQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogb25lT2ZQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZSA9IGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hLm9uZU9mW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mUHJvcGVydHlTY2hlbWEgPSBkcmFmdC5zdGVwKG9uZU9mUHJvcGVydHksIG9uZSwgZGF0YSwgcG9pbnRlcik7XG4gICAgICAgICAgICBpZiAoaXNKc29uRXJyb3Iob25lT2ZQcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25lT2ZQcm9wZXJ0eVNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmbGF0dGVuQXJyYXkoZHJhZnQudmFsaWRhdGUob25lT2ZWYWx1ZSwgb25lT2ZQcm9wZXJ0eVNjaGVtYSwgcG9pbnRlcikpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihlcnJvck9yUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9uZU9mU2NoZW1hUmVzdWx0KHNjaGVtYSwgb25lLCBpKTsgLy8gcmV0dXJuIHJlc29sdmVkIHNjaGVtYVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMub25lT2ZQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBvbmVPZlByb3BlcnR5LFxuICAgICAgICAgICAgdmFsdWU6IG9uZU9mVmFsdWUsXG4gICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb25lID0gZHJhZnQucmVzb2x2ZVJlZihzY2hlbWEub25lT2ZbaV0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmxhdHRlbkFycmF5KGRyYWZ0LnZhbGlkYXRlKGRhdGEsIG9uZSwgcG9pbnRlcikpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGVycm9yT3JQcm9taXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHsgaW5kZXg6IGksIHNjaGVtYTogb25lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlT25lT2ZTY2hlbWFSZXN1bHQoc2NoZW1hLCBtYXRjaGVzWzBdLnNjaGVtYSwgbWF0Y2hlc1swXS5pbmRleCk7IC8vIHJldHVybiByZXNvbHZlZCBzY2hlbWFcbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm11bHRpcGxlT25lT2ZFcnJvcih7XG4gICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm9uZU9mRXJyb3Ioe1xuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgb25lT2Y6IHNjaGVtYS5vbmVPZixcbiAgICAgICAgZXJyb3JzXG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSByYW5raW5nIGZvciB0aGUgZGF0YSBhbmQgZ2l2ZW4gc2NoZW1hXG4gKlxuICogQHBhcmFtIGRyYWZ0XG4gKiBAcGFyYW0gLSBqc29uIHNjaGVtYSB0eXBlOiBvYmplY3RcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gW3BvaW50ZXJdXG4gKiBAcmV0dXJuIHJhbmtpbmcgdmFsdWUgKGhpZ2hlciBpcyBiZXR0ZXIpXG4gKi9cbmZ1bmN0aW9uIGZ1enp5T2JqZWN0VmFsdWUoZHJhZnQsIG9uZSwgZGF0YSwgcG9pbnRlcikge1xuICAgIGlmIChkYXRhID09IG51bGwgfHwgb25lLnByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9uZS5wcm9wZXJ0aWVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGRhdGFba2V5XSAhPSBudWxsICYmIGRyYWZ0LmlzVmFsaWQoZGF0YVtrZXldLCBvbmUucHJvcGVydGllc1trZXldLCBwb2ludGVyKSkge1xuICAgICAgICAgICAgdmFsdWUgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFNlbGVjdHMgYW5kIHJldHVybnMgYSBvbmVPZiBzY2hlbWEgZm9yIHRoZSBnaXZlbiBkYXRhXG4gKlxuICogQHBhcmFtIGRyYWZ0XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIFtzY2hlbWFdIC0gY3VycmVudCBqc29uIHNjaGVtYSBjb250YWluaW5nIHByb3BlcnR5IG9uZU9mXG4gKiBAcGFyYW0gW3BvaW50ZXJdIC0ganNvbiBwb2ludGVyIHRvIGRhdGFcbiAqIEByZXR1cm4gb25lT2Ygc2NoZW1hIG9yIGFuIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT25lT2ZGdXp6eShkcmFmdCwgZGF0YSwgc2NoZW1hID0gZHJhZnQucm9vdFNjaGVtYSwgcG9pbnRlciA9IFwiI1wiKSB7XG4gICAgLy8gIWtleXdvcmQ6IG9uZU9mUHJvcGVydHlcbiAgICAvLyBhbiBhZGRpdGlvbmFsIDxERUNMQVJBVE9SX09ORU9GPiAoZGVmYXVsdCBgb25lT2ZQcm9wZXJ0eWApIG9uIHRoZSBzY2hlbWEgd2lsbCBleGFjdGx5IGRldGVybWluZSB0aGVcbiAgICAvLyBvbmVPZiB2YWx1ZSAoaWYgc2V0IGluIGRhdGEpXG4gICAgLy8gQGZpeG1lXG4gICAgLy8gYWJvcnQgaWYgbm8gZGF0YSBpcyBnaXZlbiBhbiBERUNMQVJBVE9SX09ORU9GIGlzIHNldCAodXNlZCBieSBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbilcbiAgICAvLyB0aGlzIGNhc2UgKGRhdGEgIT0gbnVsbCkgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnlcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmIHNjaGVtYVtERUNMQVJBVE9SX09ORU9GXSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgb25lT2ZQcm9wZXJ0eSA9IHNjaGVtYVtERUNMQVJBVE9SX09ORU9GXTtcbiAgICAgICAgY29uc3Qgb25lT2ZWYWx1ZSA9IGRhdGFbc2NoZW1hW0RFQ0xBUkFUT1JfT05FT0ZdXTtcbiAgICAgICAgaWYgKG9uZU9mVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taXNzaW5nT25lT2ZQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogb25lT2ZQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZSA9IGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hLm9uZU9mW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mUHJvcGVydHlTY2hlbWEgPSBkcmFmdC5zdGVwKG9uZU9mUHJvcGVydHksIG9uZSwgZGF0YSwgcG9pbnRlcik7XG4gICAgICAgICAgICBpZiAoaXNKc29uRXJyb3Iob25lT2ZQcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25lT2ZQcm9wZXJ0eVNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmbGF0dGVuQXJyYXkoZHJhZnQudmFsaWRhdGUob25lT2ZWYWx1ZSwgb25lT2ZQcm9wZXJ0eVNjaGVtYSwgcG9pbnRlcikpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihlcnJvck9yUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9uZU9mU2NoZW1hUmVzdWx0KHNjaGVtYSwgb25lLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm9uZU9mUHJvcGVydHlFcnJvcih7XG4gICAgICAgICAgICBwcm9wZXJ0eTogb25lT2ZQcm9wZXJ0eSxcbiAgICAgICAgICAgIHZhbHVlOiBvbmVPZlZhbHVlLFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIGVycm9yc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8ga2V5d29yZDogb25lT2ZcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb25lID0gZHJhZnQucmVzb2x2ZVJlZihzY2hlbWEub25lT2ZbaV0pO1xuICAgICAgICBpZiAoZHJhZnQuaXNWYWxpZChkYXRhLCBvbmUsIHBvaW50ZXIpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBzY2hlbWE6IG9uZSwgaW5kZXg6IGkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVPbmVPZlNjaGVtYVJlc3VsdChzY2hlbWEsIG1hdGNoZXNbMF0uc2NoZW1hLCBtYXRjaGVzWzBdLmluZGV4KTtcbiAgICB9XG4gICAgLy8gZnV6enkgbWF0Y2ggb25lT2ZcbiAgICBpZiAoZ2V0VHlwZU9mKGRhdGEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCBzY2hlbWFPZkl0ZW07XG4gICAgICAgIGxldCBzY2hlbWFPZkluZGV4ID0gLTE7XG4gICAgICAgIGxldCBmdXp6eUdyZWF0ZXN0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZSA9IGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hLm9uZU9mW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1enp5VmFsdWUgPSBmdXp6eU9iamVjdFZhbHVlKGRyYWZ0LCBvbmUsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGZ1enp5R3JlYXRlc3QgPCBmdXp6eVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnV6enlHcmVhdGVzdCA9IGZ1enp5VmFsdWU7XG4gICAgICAgICAgICAgICAgc2NoZW1hT2ZJdGVtID0gc2NoZW1hLm9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIHNjaGVtYU9mSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFPZkl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5vbmVPZkVycm9yKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgb25lT2Y6IHNjaGVtYS5vbmVPZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9uZU9mU2NoZW1hUmVzdWx0KHNjaGVtYSwgc2NoZW1hT2ZJdGVtLCBzY2hlbWFPZkluZGV4KTtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm11bHRpcGxlT25lT2ZFcnJvcih7IG1hdGNoZXMsIHBvaW50ZXIsIHNjaGVtYSwgdmFsdWU6IGRhdGEgfSk7XG4gICAgfVxuICAgIHJldHVybiBkcmFmdC5lcnJvcnMub25lT2ZFcnJvcih7XG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgcG9pbnRlcixcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBvbmVPZjogc2NoZW1hLm9uZU9mXG4gICAgfSk7XG59XG4vKipcbiAqIHZhbGlkYXRlcyBvbmVPZiBkZWZpbml0aW9uIGZvciBnaXZlbiBpbnB1dCBkYXRhXG4gKi9cbmNvbnN0IHZhbGlkYXRlT25lT2YgPSAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYU9yRXJyb3IgPSBkcmFmdC5yZXNvbHZlT25lT2YodmFsdWUsIHNjaGVtYSwgcG9pbnRlcik7XG4gICAgICAgIGlmIChpc0pzb25FcnJvcihzY2hlbWFPckVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYU9yRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IHsgdmFsaWRhdGVPbmVPZiB9O1xuIiwiaW1wb3J0IGRlZXBtZXJnZSBmcm9tIFwiZGVlcG1lcmdlXCI7XG5jb25zdCBvdmVyd3JpdGVNZXJnZSA9IChkZXN0aW5hdGlvbkFycmF5LCBzb3VyY2VBcnJheSkgPT4gc291cmNlQXJyYXk7XG4vKipcbiAqIHJldHVybnMgYSBuZXcganNvbi1zY2hlbWEsIHdoZXJlIHByb3BlcnRpZXMgYXJlIGNvbWJpbmVkIGFuZCBhcnJheXMgYXJlIHJlcGxhY2VkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChhLCBiKSA9PiBkZWVwbWVyZ2UoYSwgYiwgeyBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSB9KTtcbi8vIHZhciBkID0gYy5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gYy5pbmRleE9mKGl0ZW0pID09PSBwb3MpXG5jb25zdCBtZXJnZVVuaXF1ZUl0ZW1zID0gKGRlc3RpbmF0aW9uQXJyYXksIHNvdXJjZUFycmF5KSA9PiB7XG4gICAgY29uc3QgYWxsID0gZGVzdGluYXRpb25BcnJheS5jb25jYXQoc291cmNlQXJyYXkpO1xuICAgIHJldHVybiBhbGwuZmlsdGVyKChpdGVtLCBwb3MpID0+IGFsbC5pbmRleE9mKGl0ZW0pID09PSBwb3MpO1xufTtcbi8qKlxuICogcmV0dXJucyBhIG5ldyBqc29uLXNjaGVtYSwgd2hlcmUgcHJvcGVydGllcyBhcmUgY29tYmluZWQgYW5kIGFycmF5cyBhcmUgcmVwbGFjZWRcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlQXJyYXlzVW5pcXVlID0gKGEsIGIpID0+IGRlZXBtZXJnZShhLCBiLCB7IGFycmF5TWVyZ2U6IG1lcmdlVW5pcXVlSXRlbXMgfSk7XG4iLCJpbXBvcnQgeyBtZXJnZUFycmF5c1VuaXF1ZSB9IGZyb20gXCIuL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuLyoqXG4gKiBtZXJnZXMgdG8gdHdvIGpzb24gc2NoZW1hLiBJbiBjYXNlIG9mIGNvbmZsaWN0cywgd2lsbCB1c2Ugb3ZlcndyaXRlIGZpcnN0XG4gKiBzY2hlbWEgb3IgZGlyZWN0bHkgcmV0dXJuIGZpcnN0IGpzb24gc2NoZW1hLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTY2hlbWEoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gZ2V0VHlwZU9mKGEpO1xuICAgIGNvbnN0IGJUeXBlID0gZ2V0VHlwZU9mKGIpO1xuICAgIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG1lcmdlQXJyYXlzVW5pcXVlKGEsIGIpO1xuICAgIGlmIChhLmdldE9uZU9mT3JpZ2luKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwiZ2V0T25lT2ZPcmlnaW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogYS5nZXRPbmVPZk9yaWdpblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYi5nZXRPbmVPZk9yaWdpbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcImdldE9uZU9mT3JpZ2luXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGIuZ2V0T25lT2ZPcmlnaW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKipcbiAqIE9taXQgcHJvcGVydGllcyBmcm9tIGlucHV0IG9iamVjdC4gQWNjZXB0cyBhbnkgbnVtYmVyIG9mIHByb3BlcnRpZXMgdG9cbiAqIHJlbW92ZS4gRXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogb21pdChteU9iamVjdCwgXCJpZlwiLCBcImRlcGVuZGVuY2llc1wiKTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIHNoYWxsb3cgY29weSBvZiBpbnB1dCBvYmplY3Qgd2l0aG91dCBzcGVjaWZpZWQgcHJvcGVydGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gb21pdChvYmplY3QsIC4uLmtleXNUb09taXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIWtleXNUb09taXQuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvYmplY3QuZ2V0T25lT2ZPcmlnaW4pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgXCJnZXRPbmVPZk9yaWdpblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvYmplY3QuZ2V0T25lT2ZPcmlnaW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJ2YXIgdG9TdHJpbmdGdW5jdGlvbiA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIHRvU3RyaW5nT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8qKlxuICogQGNsYXNzZGVzYyBGYWxsYmFjayBjYWNoZSBmb3Igd2hlbiBXZWFrTWFwIGlzIG5vdCBuYXRpdmVseSBzdXBwb3J0ZWRcbiAqL1xudmFyIExlZ2FjeUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExlZ2FjeUNhY2hlKCkge1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBMZWdhY3lDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgfTtcbiAgICBMZWdhY3lDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW3RoaXMuX2tleXMuaW5kZXhPZihrZXkpXTtcbiAgICB9O1xuICAgIExlZ2FjeUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIExlZ2FjeUNhY2hlO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlTGVnYWN5KCkge1xuICAgIHJldHVybiBuZXcgTGVnYWN5Q2FjaGUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlTW9kZXJuKCkge1xuICAgIHJldHVybiBuZXcgV2Vha01hcCgpO1xufVxuLyoqXG4gKiBHZXQgYSBuZXcgY2FjaGUgb2JqZWN0IHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGNyZWF0ZUNhY2hlID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gY3JlYXRlQ2FjaGVNb2Rlcm4gOiBjcmVhdGVDYWNoZUxlZ2FjeTtcbi8qKlxuICogR2V0IGFuIGVtcHR5IHZlcnNpb24gb2YgdGhlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3RvdHlwZSBpdCBoYXMuXG4gKi9cbmZ1bmN0aW9uIGdldENsZWFuQ2xvbmUocHJvdG90eXBlKSB7XG4gICAgaWYgKCFwcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgdmFyIENvbnN0cnVjdG9yID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgPyB7fSA6IGNyZWF0ZShwcm90b3R5cGUpO1xuICAgIH1cbiAgICBpZiAoQ29uc3RydWN0b3IgJiZcbiAgICAgICAgfnRvU3RyaW5nRnVuY3Rpb24uY2FsbChDb25zdHJ1Y3RvcikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZShwcm90b3R5cGUpO1xufVxuZnVuY3Rpb24gZ2V0UmVnRXhwRmxhZ3NMZWdhY3kocmVnRXhwKSB7XG4gICAgdmFyIGZsYWdzID0gJyc7XG4gICAgaWYgKHJlZ0V4cC5nbG9iYWwpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgIH1cbiAgICBpZiAocmVnRXhwLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2knO1xuICAgIH1cbiAgICBpZiAocmVnRXhwLm11bHRpbGluZSkge1xuICAgICAgICBmbGFncyArPSAnbSc7XG4gICAgfVxuICAgIGlmIChyZWdFeHAudW5pY29kZSkge1xuICAgICAgICBmbGFncyArPSAndSc7XG4gICAgfVxuICAgIGlmIChyZWdFeHAuc3RpY2t5KSB7XG4gICAgICAgIGZsYWdzICs9ICd5JztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzO1xufVxuZnVuY3Rpb24gZ2V0UmVnRXhwRmxhZ3NNb2Rlcm4ocmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ0V4cC5mbGFncztcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyB0byBhcHBseSB0byB0aGUgY29waWVkIHJlZ2V4cC5cbiAqL1xudmFyIGdldFJlZ0V4cEZsYWdzID0gL3Rlc3QvZy5mbGFncyA9PT0gJ2cnID8gZ2V0UmVnRXhwRmxhZ3NNb2Rlcm4gOiBnZXRSZWdFeHBGbGFnc0xlZ2FjeTtcbmZ1bmN0aW9uIGdldFRhZ0xlZ2FjeSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdG9TdHJpbmdPYmplY3QuY2FsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIHR5cGUuc3Vic3RyaW5nKDgsIHR5cGUubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBnZXRUYWdNb2Rlcm4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBnZXRUYWdMZWdhY3kodmFsdWUpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRhZyBvZiB0aGUgdmFsdWUgcGFzc2VkLCBzbyB0aGF0IHRoZSBjb3JyZWN0IGNvcGllciBjYW4gYmUgdXNlZC5cbiAqL1xudmFyIGdldFRhZyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gZ2V0VGFnTW9kZXJuIDogZ2V0VGFnTGVnYWN5O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfYSA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093blByb3BlcnR5ID0gX2EuaGFzT3duUHJvcGVydHksIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gX2EucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU1VQUE9SVFNfU1lNQk9MID0gdHlwZW9mIGdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGdldFN0cmljdFByb3BlcnRpZXNNb2Rlcm4ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHByb3Blcml0ZXMgdXNlZCB3aGVuIGNvcHlpbmcgb2JqZWN0cyBzdHJpY3RseS4gVGhpcyBpbmNsdWRlcyBib3RoIGtleXMgYW5kIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTdHJpY3RQcm9wZXJ0aWVzID0gU1VQUE9SVFNfU1lNQk9MXG4gICAgPyBnZXRTdHJpY3RQcm9wZXJ0aWVzTW9kZXJuXG4gICAgOiBnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuLyoqXG4gKiBTdHJpY2x0eSBjb3B5IGFsbCBwcm9wZXJ0aWVzIGNvbnRhaW5lZCBvbiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjb3B5T3duUHJvcGVydGllc1N0cmljdCh2YWx1ZSwgY2xvbmUsIHN0YXRlKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBnZXRTdHJpY3RQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aF8xID0gcHJvcGVydGllcy5sZW5ndGgsIHByb3BlcnR5ID0gdm9pZCAwLCBkZXNjcmlwdG9yID0gdm9pZCAwOyBpbmRleCA8IGxlbmd0aF8xOyArK2luZGV4KSB7XG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF07XG4gICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NhbGxlZScgfHwgcHJvcGVydHkgPT09ICdjYWxsZXInKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgLy8gSW4gZXh0cmEgZWRnZSBjYXNlcyB3aGVyZSB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBjYW5ub3QgYmUgcmV0cml2ZWQsIGZhbGwgYmFjayB0b1xuICAgICAgICAgICAgLy8gdGhlIGxvb3NlIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICBjbG9uZVtwcm9wZXJ0eV0gPSBzdGF0ZS5jb3BpZXIodmFsdWVbcHJvcGVydHldLCBzdGF0ZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGNsb25lIHRoZSB2YWx1ZSBpZiBhY3R1YWxseSBhIHZhbHVlLCBub3QgYSBnZXR0ZXIgLyBzZXR0ZXIuXG4gICAgICAgIGlmICghZGVzY3JpcHRvci5nZXQgJiYgIWRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gc3RhdGUuY29waWVyKGRlc2NyaXB0b3IudmFsdWUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoY2xvbmUsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRlZSBhYm92ZSBjYW4gZmFpbCBvbiBub2RlIGluIGVkZ2UgY2FzZXMsIHNvIGZhbGwgYmFjayB0byB0aGUgbG9vc2UgYXNzaWdubWVudC5cbiAgICAgICAgICAgIGNsb25lW3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgaW5kZXhlZCB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXlMb29zZShhcnJheSwgc3RhdGUpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IoKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChhcnJheSwgY2xvbmUpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoXzIgPSBhcnJheS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoXzI7ICsraW5kZXgpIHtcbiAgICAgICAgY2xvbmVbaW5kZXhdID0gc3RhdGUuY29waWVyKGFycmF5W2luZGV4XSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBpbmRleGVkIHZhbHVlcyBpbiB0aGUgYXJyYXksIGFzIHdlbGwgYXMgYW55IGN1c3RvbSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXlTdHJpY3QoYXJyYXksIHN0YXRlKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoYXJyYXksIGNsb25lKTtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3QoYXJyYXksIGNsb25lLCBzdGF0ZSk7XG59XG4vKipcbiAqIENvcHkgdGhlIGNvbnRlbnRzIG9mIHRoZSBBcnJheUJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBfc3RhdGUpIHtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoMCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBCbG9iIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weUJsb2IoYmxvYiwgX3N0YXRlKSB7XG4gICAgcmV0dXJuIGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRGF0YVZpZXcgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5RGF0YVZpZXcoZGF0YVZpZXcsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBzdGF0ZS5Db25zdHJ1Y3Rvcihjb3B5QXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBEYXRlIGJhc2VkIG9uIHRoZSB0aW1lIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weURhdGUoZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKGRhdGUuZ2V0VGltZSgpKTtcbn1cbi8qKlxuICogRGVlcGx5IGNvcHkgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlNYXBMb29zZShtYXAsIHN0YXRlKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQobWFwLCBjbG9uZSk7XG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgY2xvbmUuc2V0KGtleSwgc3RhdGUuY29waWVyKHZhbHVlLCBzdGF0ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogRGVlcGx5IGNvcHkgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwsIGFzIHdlbGwgYXMgYW55IGN1c3RvbSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBjb3B5TWFwU3RyaWN0KG1hcCwgc3RhdGUpIHtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3QobWFwLCBjb3B5TWFwTG9vc2UobWFwLCBzdGF0ZSksIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNvcHlPYmplY3RMb29zZUxlZ2FjeShvYmplY3QsIHN0YXRlKSB7XG4gICAgdmFyIGNsb25lID0gZ2V0Q2xlYW5DbG9uZShzdGF0ZS5wcm90b3R5cGUpO1xuICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAgc3RhdGUuY2FjaGUuc2V0KG9iamVjdCwgY2xvbmUpO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBjbG9uZVtrZXldID0gc3RhdGUuY29waWVyKG9iamVjdFtrZXldLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuZnVuY3Rpb24gY29weU9iamVjdExvb3NlTW9kZXJuKG9iamVjdCwgc3RhdGUpIHtcbiAgICB2YXIgY2xvbmUgPSBnZXRDbGVhbkNsb25lKHN0YXRlLnByb3RvdHlwZSk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQob2JqZWN0LCBjbG9uZSk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSBzdGF0ZS5jb3BpZXIob2JqZWN0W2tleV0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoXzMgPSBzeW1ib2xzLmxlbmd0aCwgc3ltYm9sID0gdm9pZCAwOyBpbmRleCA8IGxlbmd0aF8zOyArK2luZGV4KSB7XG4gICAgICAgIHN5bWJvbCA9IHN5bWJvbHNbaW5kZXhdO1xuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCkpIHtcbiAgICAgICAgICAgIGNsb25lW3N5bWJvbF0gPSBzdGF0ZS5jb3BpZXIob2JqZWN0W3N5bWJvbF0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBwcm9wZXJ0aWVzIChrZXlzIGFuZCBzeW1ib2xzKSBhbmQgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xudmFyIGNvcHlPYmplY3RMb29zZSA9IFNVUFBPUlRTX1NZTUJPTFxuICAgID8gY29weU9iamVjdExvb3NlTW9kZXJuXG4gICAgOiBjb3B5T2JqZWN0TG9vc2VMZWdhY3k7XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBwcm9wZXJ0aWVzIChrZXlzIGFuZCBzeW1ib2xzKSBhbmQgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbFxuICogYXMgYW55IGhpZGRlbiBvciBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0U3RyaWN0KG9iamVjdCwgc3RhdGUpIHtcbiAgICB2YXIgY2xvbmUgPSBnZXRDbGVhbkNsb25lKHN0YXRlLnByb3RvdHlwZSk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQob2JqZWN0LCBjbG9uZSk7XG4gICAgcmV0dXJuIGNvcHlPd25Qcm9wZXJ0aWVzU3RyaWN0KG9iamVjdCwgY2xvbmUsIHN0YXRlKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHByaW1pdGl2ZSB3cmFwcGVyIGZyb20gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weVByaW1pdGl2ZVdyYXBwZXIocHJpbWl0aXZlT2JqZWN0LCBzdGF0ZSkge1xuICAgIHJldHVybiBuZXcgc3RhdGUuQ29uc3RydWN0b3IocHJpbWl0aXZlT2JqZWN0LnZhbHVlT2YoKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBSZWdFeHAgYmFzZWQgb24gdGhlIHZhbHVlIGFuZCBmbGFncyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlSZWdFeHAocmVnRXhwLCBzdGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcihyZWdFeHAuc291cmNlLCBnZXRSZWdFeHBGbGFncyhyZWdFeHApKTtcbiAgICBjbG9uZS5sYXN0SW5kZXggPSByZWdFeHAubGFzdEluZGV4O1xuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSAoYW4gaWRlbnRpdHkgZnVuY3Rpb24pLlxuICpcbiAqIEBub3RlXG4gKiBUSGlzIGlzIHVzZWQgZm9yIG9iamVjdHMgdGhhdCBjYW5ub3QgYmUgY29waWVkLCBzdWNoIGFzIFdlYWtNYXAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTZWxmKHZhbHVlLCBfc3RhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSB2YWx1ZXMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5U2V0TG9vc2Uoc2V0LCBzdGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcigpO1xuICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAgc3RhdGUuY2FjaGUuc2V0KHNldCwgY2xvbmUpO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbG9uZS5hZGQoc3RhdGUuY29waWVyKHZhbHVlLCBzdGF0ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogRGVlcGx5IGNvcHkgdGhlIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwsIGFzIHdlbGwgYXMgYW55IGN1c3RvbSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBjb3B5U2V0U3RyaWN0KHNldCwgc3RhdGUpIHtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3Qoc2V0LCBjb3B5U2V0TG9vc2Uoc2V0LCBzdGF0ZSksIHN0YXRlKTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai5fX3Byb3RvX187IH0pO1xudmFyIERFRkFVTFRfTE9PU0VfT1BUSU9OUyA9IHtcbiAgICBhcnJheTogY29weUFycmF5TG9vc2UsXG4gICAgYXJyYXlCdWZmZXI6IGNvcHlBcnJheUJ1ZmZlcixcbiAgICBibG9iOiBjb3B5QmxvYixcbiAgICBkYXRhVmlldzogY29weURhdGFWaWV3LFxuICAgIGRhdGU6IGNvcHlEYXRlLFxuICAgIGVycm9yOiBjb3B5U2VsZixcbiAgICBtYXA6IGNvcHlNYXBMb29zZSxcbiAgICBvYmplY3Q6IGNvcHlPYmplY3RMb29zZSxcbiAgICByZWdFeHA6IGNvcHlSZWdFeHAsXG4gICAgc2V0OiBjb3B5U2V0TG9vc2UsXG59O1xudmFyIERFRkFVTFRfU1RSSUNUX09QVElPTlMgPSBhc3NpZ24oe30sIERFRkFVTFRfTE9PU0VfT1BUSU9OUywge1xuICAgIGFycmF5OiBjb3B5QXJyYXlTdHJpY3QsXG4gICAgbWFwOiBjb3B5TWFwU3RyaWN0LFxuICAgIG9iamVjdDogY29weU9iamVjdFN0cmljdCxcbiAgICBzZXQ6IGNvcHlTZXRTdHJpY3QsXG59KTtcbi8qKlxuICogR2V0IHRoZSBjb3BpZXJzIHVzZWQgZm9yIGVhY2ggc3BlY2lmaWMgb2JqZWN0IHRhZy5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFnU3BlY2lmaWNDb3BpZXJzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBBcmd1bWVudHM6IG9wdGlvbnMub2JqZWN0LFxuICAgICAgICBBcnJheTogb3B0aW9ucy5hcnJheSxcbiAgICAgICAgQXJyYXlCdWZmZXI6IG9wdGlvbnMuYXJyYXlCdWZmZXIsXG4gICAgICAgIEJsb2I6IG9wdGlvbnMuYmxvYixcbiAgICAgICAgQm9vbGVhbjogY29weVByaW1pdGl2ZVdyYXBwZXIsXG4gICAgICAgIERhdGFWaWV3OiBvcHRpb25zLmRhdGFWaWV3LFxuICAgICAgICBEYXRlOiBvcHRpb25zLmRhdGUsXG4gICAgICAgIEVycm9yOiBvcHRpb25zLmVycm9yLFxuICAgICAgICBGbG9hdDMyQXJyYXk6IG9wdGlvbnMuYXJyYXlCdWZmZXIsXG4gICAgICAgIEZsb2F0NjRBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgSW50OEFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBJbnQxNkFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBJbnQzMkFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBNYXA6IG9wdGlvbnMubWFwLFxuICAgICAgICBOdW1iZXI6IGNvcHlQcmltaXRpdmVXcmFwcGVyLFxuICAgICAgICBPYmplY3Q6IG9wdGlvbnMub2JqZWN0LFxuICAgICAgICBQcm9taXNlOiBjb3B5U2VsZixcbiAgICAgICAgUmVnRXhwOiBvcHRpb25zLnJlZ0V4cCxcbiAgICAgICAgU2V0OiBvcHRpb25zLnNldCxcbiAgICAgICAgU3RyaW5nOiBjb3B5UHJpbWl0aXZlV3JhcHBlcixcbiAgICAgICAgV2Vha01hcDogY29weVNlbGYsXG4gICAgICAgIFdlYWtTZXQ6IGNvcHlTZWxmLFxuICAgICAgICBVaW50OEFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50OENsYW1wZWRBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgVWludDE2QXJyYXk6IG9wdGlvbnMuYXJyYXlCdWZmZXIsXG4gICAgICAgIFVpbnQzMkFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50NjRBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjdXN0b20gY29waWVyIGJhc2VkIG9uIHRoZSBvYmplY3Qtc3BlY2lmaWMgY29weSBtZXRob2RzIHBhc3NlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29waWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgbm9ybWFsaXplZE9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRfTE9PU0VfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIHRhZ1NwZWNpZmljQ29waWVycyA9IGdldFRhZ1NwZWNpZmljQ29waWVycyhub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgdmFyIGFycmF5ID0gdGFnU3BlY2lmaWNDb3BpZXJzLkFycmF5LCBvYmplY3QgPSB0YWdTcGVjaWZpY0NvcGllcnMuT2JqZWN0O1xuICAgIGZ1bmN0aW9uIGNvcGllcih2YWx1ZSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucHJvdG90eXBlID0gc3RhdGUuQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5jYWNoZS5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuY2FjaGUuZ2V0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgIHN0YXRlLkNvbnN0cnVjdG9yID0gc3RhdGUucHJvdG90eXBlICYmIHN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gcGxhaW4gb2JqZWN0c1xuICAgICAgICBpZiAoIXN0YXRlLkNvbnN0cnVjdG9yIHx8IHN0YXRlLkNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QodmFsdWUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcnJheXNcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkodmFsdWUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnU3BlY2lmaWNDb3BpZXIgPSB0YWdTcGVjaWZpY0NvcGllcnNbZ2V0VGFnKHZhbHVlKV07XG4gICAgICAgIGlmICh0YWdTcGVjaWZpY0NvcGllcikge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ1NwZWNpZmljQ29waWVyKHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBvYmplY3QodmFsdWUsIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvcHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvcGllcih2YWx1ZSwge1xuICAgICAgICAgICAgQ29uc3RydWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhY2hlOiBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgY29waWVyOiBjb3BpZXIsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY3VzdG9tIGNvcGllciBiYXNlZCBvbiB0aGUgb2JqZWN0LXNwZWNpZmljIGNvcHkgbWV0aG9kcyBwYXNzZWQsIGRlZmF1bHRpbmcgdG8gdGhlXG4gKiBzYW1lIGludGVybmFscyBhcyBgY29weVN0cmljdGAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmljdENvcGllcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvcGllcihhc3NpZ24oe30sIERFRkFVTFRfU1RSSUNUX09QVElPTlMsIG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ29weSBhbiB2YWx1ZSBkZWVwbHkgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hlcmUgc3RyaWN0IHJlY3JlYXRpb24gb2Ygb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtYWludGFpbmVkLiBBbGwgcHJvcGVydGllcyAoaW5jbHVkaW5nIG5vbi1lbnVtZXJhYmxlIG9uZXMpIGFyZSBjb3BpZWQgd2l0aCB0aGVpclxuICogb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvcnMgb24gYm90aCBvYmplY3RzIGFuZCBhcnJheXMuXG4gKi9cbnZhciBjb3B5U3RyaWN0ID0gY3JlYXRlU3RyaWN0Q29waWVyKHt9KTtcbi8qKlxuICogQ29weSBhbiB2YWx1ZSBkZWVwbHkgYXMgbXVjaCBhcyBwb3NzaWJsZS5cbiAqL1xudmFyIGluZGV4ID0gY3JlYXRlQ29waWVyKHt9KTtcblxuZXhwb3J0IHsgY29weVN0cmljdCwgY3JlYXRlQ29waWVyLCBjcmVhdGVTdHJpY3RDb3BpZXIsIGluZGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCBjb3B5IGZyb20gXCJmYXN0LWNvcHlcIjtcbmV4cG9ydCBkZWZhdWx0IGNvcHk7XG4iLCIvKipcbiAqIHJldHVybnMgaWYtdGhlbi1lbHNlIGFzIGEganNvbiBzY2hlbWEuIGRvZXMgbm90IG1lcmdlIHdpdGggaW5wdXRcbiAqIGpzb24gc2NoZW1hLiB5b3UgcHJvYmFibHkgd2lsbCBuZWVkIHRvIGRvIHNvIHRvIGNvcnJlY3RseSByZXNvbHZlXG4gKiByZWZlcmVuY2VzLlxuICpcbiAqIEByZXR1cm5zIGpzb24gc2NoZW1hIGRlZmluZWQgYnkgaWYtdGhlbi1lbHNlIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUlmU2NoZW1hKGRyYWZ0LCBzY2hlbWEsIGRhdGEpIHtcbiAgICBpZiAoc2NoZW1hLmlmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5pZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5lbHNlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmlmICYmIChzY2hlbWEudGhlbiB8fCBzY2hlbWEuZWxzZSkpIHtcbiAgICAgICAgY29uc3QgaWZFcnJvcnMgPSBkcmFmdC52YWxpZGF0ZShkYXRhLCBkcmFmdC5yZXNvbHZlUmVmKHNjaGVtYS5pZikpO1xuICAgICAgICBpZiAoaWZFcnJvcnMubGVuZ3RoID09PSAwICYmIHNjaGVtYS50aGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQucmVzb2x2ZVJlZihzY2hlbWEudGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlmRXJyb3JzLmxlbmd0aCAhPT0gMCAmJiBzY2hlbWEuZWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hLmVsc2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcmV0dXJucyB2YWxpZGF0aW9uIHJlc3VsdCBvZiBpdC10aGVuLWVsc2Ugc2NoZW1hXG4gKi9cbmNvbnN0IHZhbGlkYXRlSWYgPSAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IHJlc29sdmVJZlNjaGVtYShkcmFmdCwgc2NoZW1hLCB2YWx1ZSk7XG4gICAgaWYgKHJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBkcmFmdC52YWxpZGF0ZSh2YWx1ZSwgcmVzb2x2ZWRTY2hlbWEsIHBvaW50ZXIpO1xuICAgIH1cbn07XG5leHBvcnQgeyB2YWxpZGF0ZUlmIH07XG4iLCJpbXBvcnQgeyBtZXJnZVNjaGVtYSB9IGZyb20gXCIuLi9tZXJnZVNjaGVtYVwiO1xuaW1wb3J0IHsgb21pdCB9IGZyb20gXCIuLi91dGlscy9vbWl0XCI7XG5pbXBvcnQgY29weSBmcm9tIFwiLi4vdXRpbHMvY29weVwiO1xuaW1wb3J0IHsgcmVzb2x2ZUlmU2NoZW1hIH0gZnJvbSBcIi4vaWZcIjtcbi8qKlxuICogcmVzb2x2ZXMgc2NoZW1hXG4gKiB3aGVuIGNvbXBsZXRlIHRoaXMgd2lsbCBoYXZlIG11Y2ggZHVwbGljYXRpb24gdG8gc3RlcC5vYmplY3QgZXRjXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTY2hlbWEoZHJhZnQsIHNjaGVtYVRvUmVzb2x2ZSwgZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzY2hlbWEgPSB7IC4uLigoX2EgPSBkcmFmdC5yZXNvbHZlUmVmKHNjaGVtYVRvUmVzb2x2ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSB9O1xuICAgIGNvbnN0IGlmU2NoZW1hID0gcmVzb2x2ZUlmU2NoZW1hKGRyYWZ0LCBzY2hlbWEsIGRhdGEpO1xuICAgIGlmIChpZlNjaGVtYSkge1xuICAgICAgICByZXR1cm4gaWZTY2hlbWE7XG4gICAgfVxuICAgIHJldHVybiBvbWl0KHNjaGVtYSwgXCJpZlwiLCBcInRoZW5cIiwgXCJlbHNlXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBbGxPZihkcmFmdCwgZGF0YSwgc2NoZW1hID0gZHJhZnQucm9vdFNjaGVtYSkge1xuICAgIGxldCBtZXJnZWRTY2hlbWEgPSBjb3B5KHNjaGVtYSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuYWxsT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gQHRvZG8gaW50cm9kdWNlIGRyYWZ0LnJlc29sdmVTY2hlbWEgdG8gaXRlcmF0aXZlbHkgcmVzb2x2ZVxuICAgICAgICBjb25zdCBhbGxPZlNjaGVtYSA9IHJlc29sdmVTY2hlbWEoZHJhZnQsIHNjaGVtYS5hbGxPZltpXSwgZGF0YSk7XG4gICAgICAgIG1lcmdlZFNjaGVtYSA9IG1lcmdlU2NoZW1hKG1lcmdlZFNjaGVtYSwgYWxsT2ZTY2hlbWEpO1xuICAgICAgICBkYXRhID0gZHJhZnQuZ2V0VGVtcGxhdGUoZGF0YSwgbWVyZ2VkU2NoZW1hKTtcbiAgICB9XG4gICAgZGVsZXRlIG1lcmdlZFNjaGVtYS5hbGxPZjtcbiAgICByZXR1cm4gbWVyZ2VkU2NoZW1hO1xufVxuLyoqXG4gKiBAYXR0ZW50aW9uOiBzdWJzY2hlbWFzIGhhdmUgdG8gYmUgcmVzb2x2ZWQgdXBmcm9udCAoZS5nLiBpZi1lbHNlIHRoYXQgZG8gbm90IGFwcGx5KVxuICogTWVyZ2UgYWxsIGFsbE9mIHN1YiBzY2hlbWEgaW50byBhIHNpbmdsZSBzY2hlbWEuIFJldHVybnMgdW5kZWZpbmVkIGZvclxuICogbWlzc2luZyBhbGxPZiBkZWZpbml0aW9uLlxuICpcbiAqIEByZXR1cm5zIGpzb24gc2NoZW1hIGRlZmluZWQgYnkgYWxsT2Ygb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFsbE9mU2NoZW1hKGRyYWZ0LCBzY2hlbWEpIHtcbiAgICBjb25zdCB7IGFsbE9mIH0gPSBzY2hlbWE7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbE9mKSB8fCBhbGxPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSB7fTtcbiAgICBhbGxPZi5mb3JFYWNoKChzdWJzY2hlbWEpID0+IHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSwgZHJhZnQucmVzb2x2ZVJlZihzdWJzY2hlbWEpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG59XG4vKipcbiAqIHZhbGlkYXRlIGFsbE9mIGRlZmluaXRpb24gZm9yIGdpdmVuIGlucHV0IGRhdGFcbiAqL1xuY29uc3QgdmFsaWRhdGVBbGxPZiA9IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgIGNvbnN0IHsgYWxsT2YgfSA9IHNjaGVtYTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsT2YpIHx8IGFsbE9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIHNjaGVtYS5hbGxPZi5mb3JFYWNoKChzdWJTY2hlbWEpID0+IHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZHJhZnQudmFsaWRhdGUodmFsdWUsIHN1YlNjaGVtYSwgcG9pbnRlcikpO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuZXhwb3J0IHsgdmFsaWRhdGVBbGxPZiB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJlZihzY2hlbWEsIHJvb3RTY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwgfHwgc2NoZW1hLiRyZWYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmdldFJvb3QpIHtcbiAgICAgICAgLy8gd2UgYWN0dWFsbHkgYWx3YXlzIG5lZWQgdG8gcmVzb2x2ZSB0aGUgc2NoZW1hIGxpa2UgdGhpcywgc2luY2UgcmV0dXJuZWQgc3Vic2NoZW1hc1xuICAgICAgICAvLyBtdXN0IHJlc29sdmUgcmVsYXRpdmUgZnJvbSB0aGVpciBzY2hlbWFcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBzY2hlbWEuZ2V0Um9vdCgpLmdldFJlZihzY2hlbWEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhzY2hlbWEuJHJlZiwgXCI9PlwiLCByZXNvbHZlZFNjaGVtYSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFNjaGVtYTtcbiAgICB9XG4gICAgLy8gdHJ5b3V0IC0gdGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkLCBleGNlcHQgd2UgbWlzc2VkIHNvbWV0aGluZ1xuICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gcm9vdFNjaGVtYS5nZXRSZWYoc2NoZW1hKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmVmTWVyZ2Uoc2NoZW1hLCByb290U2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsIHx8IHNjaGVtYS4kcmVmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSByb290U2NoZW1hLmdldFJlZihzY2hlbWEpO1xuICAgIGNvbnN0IG1lcmdlZFNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVkU2NoZW1hLCBzY2hlbWEpO1xuICAgIGRlbGV0ZSBtZXJnZWRTY2hlbWEuJHJlZjtcbiAgICAvLyBAdG9kbyB0aGUgZm9sbG93aW5nIG1pZ2h0IG5vdCBiZSBzYWZlIG5vciBpbmNvbXBsZXRlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lcmdlZFNjaGVtYSwgXCJfX3JlZlwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogc2NoZW1hLl9fcmVmIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWRTY2hlbWEsIFwiZ2V0Um9vdFwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogc2NoZW1hLmdldFJvb3QgfSk7XG4gICAgcmV0dXJuIG1lcmdlZFNjaGVtYTtcbn1cbiIsImltcG9ydCB7IGVycm9yc09ubHkgfSBmcm9tIFwiLi91dGlscy9maWx0ZXJcIjtcbmltcG9ydCBmbGF0dGVuQXJyYXkgZnJvbSBcIi4vdXRpbHMvZmxhdHRlbkFycmF5XCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5mdW5jdGlvbiBjcmVhdGVFcnJvck5vdGlmaWNhdGlvbihvbkVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBmbGF0dGVuQXJyYXkoZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3IuZm9yRWFjaChub3RpZnlFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnNvbkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG59XG4vKipcbiAqIEBhc3luY1xuICogVmFsaWRhdGUgZGF0YSBieSBhIGpzb24gc2NoZW1hXG4gKlxuICogQHBhcmFtIGRyYWZ0IC0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIGpzb24gc2NoZW1hIHRvIHVzZSwgZGVmYXVsdHMgdG8gZHJhZnQucm9vdFNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnMucG9pbnRlciAtIGpzb24gcG9pbnRlciBwb2ludGluZyB0byBjdXJyZW50IHZhbHVlLiBVc2VkIGluIGVycm9yIHJlcG9ydHNcbiAqIEBwYXJhbSBvcHRpb25zLm9uRXJyb3IgICAtIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGVycm9yIGFzIHNvb24gYXMgaXQgaXMgcmVzb2x2ZWRcbiAqIEByZXR1cm4gbGlzdCBvZiBlcnJvcnMgb3IgZW1wdHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGVBc3luYyhkcmFmdCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgcG9pbnRlciwgb25FcnJvciB9ID0geyBzY2hlbWE6IGRyYWZ0LnJvb3RTY2hlbWEsIHBvaW50ZXI6IFwiI1wiLCAuLi5vcHRpb25zIH07XG4gICAgbGV0IGVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHBvaW50ZXIpO1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIGVycm9ycyA9IGZsYXR0ZW5BcnJheShlcnJvcnMpO1xuICAgICAgICBjb25zdCBub3RpZnlFcnJvciA9IGNyZWF0ZUVycm9yTm90aWZpY2F0aW9uKG9uRXJyb3IpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvcnNbaV07XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IudGhlbihub3RpZnlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0pzb25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZXJyb3JzKVxuICAgICAgICAudGhlbihmbGF0dGVuQXJyYXkpXG4gICAgICAgIC50aGVuKChyZXNvbHZlZEVycm9ycykgPT4gcmVzb2x2ZWRFcnJvcnMuZmlsdGVyKGVycm9yc09ubHkpKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgcmVzb2x2aW5nIHByb21pc2VzXCIsIGUubWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH0pO1xufVxuIiwiLyoqXG4gKiBAcmV0dXJucyBsaXN0IHdpdGggdW5pcXVlIHZhbHVlcyBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVJdGVtcyhsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QuZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gbGlzdC5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG59XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi9nZXRUeXBlT2ZcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2KSB7XG4gICAgcmV0dXJuIGdldFR5cGVPZih2KSA9PT0gXCJvYmplY3RcIjtcbn1cbiIsImltcG9ydCBnZXRUeXBlT2YgZnJvbSBcIi4uL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgbWVyZ2VTY2hlbWEgfSBmcm9tIFwiLi4vbWVyZ2VTY2hlbWFcIjtcbmltcG9ydCB7IHVuaXF1ZUl0ZW1zIH0gZnJvbSBcIi4uL3V0aWxzL3VuaXF1ZUl0ZW1zXCI7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCIuLi91dGlscy9pc09iamVjdFwiO1xuLyoqXG4gKiByZXR1cm5zIGRlcGVuZGVuY2llcyBhcyBhbiBvYmplY3QganNvbiBzY2hlbWEuIGRvZXMgbm90IG1lcmdlIHdpdGggaW5wdXRcbiAqIGpzb24gc2NoZW1hLiB5b3UgcHJvYmFibHkgd2lsbCBuZWVkIHRvIGRvIHNvIHRvIGNvcnJlY3RseSByZXNvbHZlXG4gKiByZWZlcmVuY2VzLlxuICpcbiAqIEByZXR1cm5zIG1lcmdlZCBqc29uIHNjaGVtYSBkZWZpbmVkIGJ5IGRlcGVuZGVuY2llcyBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVEZXBlbmRlbmNpZXMoZHJhZnQsIHNjaGVtYSwgZGF0YSkge1xuICAgIGNvbnN0IHsgZGVwZW5kZW5jaWVzIH0gPSBzY2hlbWE7XG4gICAgaWYgKCFpc09iamVjdChkZXBlbmRlbmNpZXMpIHx8ICFpc09iamVjdChkYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hID0geyByZXF1aXJlZDogW10gfTtcbiAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGRhdGFbcHJvcF0gPT0gbnVsbCAmJlxuICAgICAgICAgICAgISgoKF9hID0gc2NoZW1hLnJlcXVpcmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMocHJvcCkpIHx8ICgoX2IgPSByZXNvbHZlZFNjaGVtYS5yZXF1aXJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKHByb3ApKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW3Byb3BdO1xuICAgICAgICAvLyBkZXBlbmRlbmN5IGFycmF5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmVkU2NoZW1hLnJlcXVpcmVkLnB1c2goLi4uZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVwZW5kZW5jeSBzY2hlbWFcbiAgICAgICAgaWYgKGlzT2JqZWN0KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmVkU2NoZW1hID0gbWVyZ2VTY2hlbWEocmVzb2x2ZWRTY2hlbWEsIGRyYWZ0LnJlc29sdmVSZWYoZGVwZW5kZW5jeSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEucmVxdWlyZWQgPSB1bmlxdWVJdGVtcyhyZXNvbHZlZFNjaGVtYS5yZXF1aXJlZCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFNjaGVtYTtcbiAgICB9XG59XG4vKipcbiAqIHZhbGlkYXRlIGRlcGVuZGVuY2llcyBkZWZpbml0aW9uIGZvciBnaXZlbiBpbnB1dCBkYXRhXG4gKi9cbmNvbnN0IHZhbGlkYXRlRGVwZW5kZW5jaWVzID0gKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgaWYgKGdldFR5cGVPZihzY2hlbWEuZGVwZW5kZW5jaWVzKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXNbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAZHJhZnQgPj0gNiBib29sZWFuIHNjaGVtYVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVuY2llc1twcm9wZXJ0eV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVuY2llc1twcm9wZXJ0eV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMubWlzc2luZ0RlcGVuZGVuY3lFcnJvcih7IHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXBlbmRlbmN5RXJyb3JzO1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZU9mKHNjaGVtYS5kZXBlbmRlbmNpZXNbcHJvcGVydHldKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgZGVwZW5kZW5jeUVycm9ycyA9IHNjaGVtYS5kZXBlbmRlbmNpZXNbcHJvcGVydHldXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZGVwZW5kZW5jeSkgPT4gdmFsdWVbZGVwZW5kZW5jeV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAubWFwKChtaXNzaW5nUHJvcGVydHkpID0+IGRyYWZ0LmVycm9ycy5taXNzaW5nRGVwZW5kZW5jeUVycm9yKHsgbWlzc2luZ1Byb3BlcnR5LCBwb2ludGVyLCBzY2hlbWEsIHZhbHVlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmN5RXJyb3JzID0gZHJhZnQudmFsaWRhdGUodmFsdWUsIHNjaGVtYS5kZXBlbmRlbmNpZXNbcHJvcGVydHldLCBwb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZXBlbmRlbmN5IGRlZmluaXRpb24gZm9yICR7cG9pbnRlcn0vJHtwcm9wZXJ0eX0uIE11c3QgYmUgc3RyaW5nW10gb3Igc2NoZW1hYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZGVwZW5kZW5jeUVycm9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZXJyb3JzIDogdW5kZWZpbmVkO1xufTtcbmV4cG9ydCB7IHZhbGlkYXRlRGVwZW5kZW5jaWVzIH07XG4iLCIvKipcbiAqIEBkcmFmdC0wNFxuICovXG5pbXBvcnQgeyBtZXJnZVNjaGVtYSB9IGZyb20gXCIuLi9tZXJnZVNjaGVtYVwiO1xuaW1wb3J0IHsgb21pdCB9IGZyb20gXCIuLi91dGlscy9vbWl0XCI7XG4vKipcbiAqIHJldHVybnMgbWVyZ2VkIHNjaGVtYSBvZiBhbGwgdmFsaWQgYW55T2Ygc3Vic2NoZW1hcyBmb3IgdGhlIGdpdmVuIGlucHV0IGRhdGEuXG4gKiBEb2VzIG5vdCBtZXJnZSB3aXRoIHJlc3QgaW5wdXQgc2NoZW1hLlxuICpcbiAqIEByZXR1cm5zIG1lcmdlZCBhbnlPZiBzdWJzY2hlbWFzIHdoaWNoIGFyZSB2YWxpZCB0byB0aGUgZ2l2ZW4gaW5wdXQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVmFsaWRBbnlPZlNjaGVtYShkcmFmdCwgc2NoZW1hLCBkYXRhKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikgfHwgc2NoZW1hLmFueU9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXNvbHZlZFNjaGVtYTtcbiAgICBzY2hlbWEuYW55T2YuZm9yRWFjaCgoYW55U2NoZW1hKSA9PiB7XG4gICAgICAgIGFueVNjaGVtYSA9IGRyYWZ0LnJlc29sdmVSZWYoYW55U2NoZW1hKTtcbiAgICAgICAgaWYgKGRyYWZ0LmlzVmFsaWQoZGF0YSwgYW55U2NoZW1hKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlZFNjaGVtYSA/IG1lcmdlU2NoZW1hKHJlc29sdmVkU2NoZW1hLCBhbnlTY2hlbWEpIDogYW55U2NoZW1hO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xufVxuLyoqXG4gKiBAcmV0dXJucyBleHRlbmRlZCBpbnB1dCBzY2hlbWEgd2l0aCB2YWxpZCBhbnlPZiBzdWJzY2hlbWFzIG9yIEpzb25FcnJvciBpZlxuICogbm8gYW55T2Ygc2NoZW1hIG1hdGNoZXMgaW5wdXQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFueU9mKGRyYWZ0LCBkYXRhLCBzY2hlbWEgPSBkcmFmdC5yb290U2NoZW1hLCBwb2ludGVyID0gXCIjXCIpIHtcbiAgICBjb25zdCB7IGFueU9mIH0gPSBzY2hlbWE7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFueU9mKSB8fCBhbnlPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVZhbGlkQW55T2ZTY2hlbWEoZHJhZnQsIHNjaGVtYSwgZGF0YSk7XG4gICAgaWYgKHJlc29sdmVkU2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5hbnlPZkVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZTogZGF0YSwgYW55T2Y6IEpTT04uc3RyaW5naWZ5KGFueU9mKSB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkU2NoZW1hID0gbWVyZ2VTY2hlbWEoc2NoZW1hLCByZXNvbHZlZFNjaGVtYSk7XG4gICAgcmV0dXJuIG9taXQobWVyZ2VkU2NoZW1hLCBcImFueU9mXCIpO1xufVxuLyoqXG4gKiB2YWxpZGF0ZSBhbnlPZiBkZWZpbml0aW9uIGZvciBnaXZlbiBpbnB1dCBkYXRhXG4gKi9cbmNvbnN0IHZhbGlkYXRlQW55T2YgPSAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSB8fCBzY2hlbWEuYW55T2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLmFueU9mLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChkcmFmdC5pc1ZhbGlkKHZhbHVlLCBzY2hlbWEuYW55T2ZbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkcmFmdC5lcnJvcnMuYW55T2ZFcnJvcih7IHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUsIGFueU9mOiBzY2hlbWEuYW55T2YgfSk7XG59O1xuZXhwb3J0IHsgdmFsaWRhdGVBbnlPZiB9O1xuIiwiaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgbWVyZ2VTY2hlbWEgfSBmcm9tIFwiLi9tZXJnZVNjaGVtYVwiO1xuaW1wb3J0IHsgcmVzb2x2ZUlmU2NoZW1hIH0gZnJvbSBcIi4vZmVhdHVyZXMvaWZcIjtcbmltcG9ydCB7IHJlc29sdmVEZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi9mZWF0dXJlcy9kZXBlbmRlbmNpZXNcIjtcbmltcG9ydCB7IG1lcmdlQWxsT2ZTY2hlbWEgfSBmcm9tIFwiLi9mZWF0dXJlcy9hbGxPZlwiO1xuaW1wb3J0IHsgbWVyZ2VWYWxpZEFueU9mU2NoZW1hIH0gZnJvbSBcIi4vZmVhdHVyZXMvYW55T2ZcIjtcbmltcG9ydCB7IHJlc29sdmVPbmVPZkZ1enp5IGFzIHJlc29sdmVPbmVPZiB9IGZyb20gXCIuL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgeyBvbWl0IH0gZnJvbSBcIi4vdXRpbHMvb21pdFwiO1xuY29uc3QgdG9PbWl0ID0gW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcIm9uZU9mXCIsIFwiZGVwZW5kZW5jaWVzXCIsIFwiaWZcIiwgXCJ0aGVuXCIsIFwiZWxzZVwiXTtcbmNvbnN0IGR5bmFtaWNQcm9wZXJ0aWVzID0gW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcIm9uZU9mXCIsIFwiZGVwZW5kZW5jaWVzXCIsIFwiaWZcIl07XG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IGdpdmVuUHJvcHMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgIHJldHVybiBkeW5hbWljUHJvcGVydGllcy5maW5kSW5kZXgoKHByb3ApID0+IGdpdmVuUHJvcHMuaW5jbHVkZXMocHJvcCkpICE9PSAtMTtcbn1cbi8qKlxuICogQG5vdGUgdGhpcyB1dGlsaXR5IGRvZXMgbm90IHJlZmVyZW5jZSBkcmFmdCBtZXRob2RzIGZvciByZXNvbHV0aW9uXG4gKiBAdG9kbyBjb25zaWRlciB1c2luZyBkcmFmdCBtZXRob2RzXG4gKlxuICogUmVzb2x2ZXMgYWxsIGR5bmFtaWMgc2NoZW1hIGRlZmluaXRpb25zIGZvciB0aGUgZ2l2ZW4gaW5wdXQgZGF0YSBhbmQgcmV0dXJuc1xuICogdGhlIHJlc3VsdGluZyBqc29uLXNjaGVtYSB3aXRob3V0IGFueSBkeW5hbWljIHNjaGVtYSBkZWZpbml0aW9ucy4gVGhlIHJlc3VsdFxuICogaXMgbm90IG1lcmdlZCB3aXRoIHRoZSBvcmlnaW5hbCBpbnB1dCBzY2hlbWEsIHRodXMgc3RhdGljIGRlZmluaXRpb25zIG9mIHRoZVxuICogaW5wdXQgc2NoZW1hIGFyZSB1bnRvdWNoZWQgYW5kIG1pc3NpbmcuIEZvciBhIGZ1bGwgc2NoZW1hIGRlZmluaXRpb24gb2YgdGhpc1xuICogaW5wdXQgZGF0YSB5b3UgaGF2ZSB0byBtZXJnZSB0aGUgcmVzdWx0IHdpdGggdGhlIG9yaWdpbmFsIHNjaGVtYVxuICogKEBzZWUgcmVkdWNlU2NoZW1hKVxuICpcbiAqIGR5bmFtaWMgc2NoZW1hIGRlZmluaXRpb25zOiBkZXBlbmRlbmNpZXMsIGFsbE9mLCBhbnlPZiwgb25lT2YsIGlmXG4gKlxuICogQHJldHVybnMgc3RhdGljIHNjaGVtYSBmcm9tIHJlc29sdmVkIGR5bmFtaWMgc2NoZW1hIGRlZmluaXRpb25zIGZvciB0aGlzXG4gKiAgc3BlY2lmaWMgaW5wdXQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNTY2hlbWEoZHJhZnQsIHNjaGVtYSwgZGF0YSwgcG9pbnRlcikge1xuICAgIGxldCByZXNvbHZlZFNjaGVtYTtcbiAgICBsZXQgZXJyb3I7XG4gICAgc2NoZW1hID0gZHJhZnQucmVzb2x2ZVJlZihzY2hlbWEpO1xuICAgIC8vIEBmZWF0dXJlIG9uZU9mXG4gICAgaWYgKHNjaGVtYS5vbmVPZikge1xuICAgICAgICBjb25zdCBvbmVPZlNjaGVtYSA9IHJlc29sdmVPbmVPZihkcmFmdCwgZGF0YSwgc2NoZW1hLCBwb2ludGVyKTtcbiAgICAgICAgaWYgKGlzSnNvbkVycm9yKG9uZU9mU2NoZW1hKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBvbmVPZlNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbmVPZlNjaGVtYSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXNvbHZlZFNjaGVtYSAhPT0gdm9pZCAwID8gcmVzb2x2ZWRTY2hlbWEgOiB7fSwgb25lT2ZTY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBmZWF0dXJlIGFsbE9mXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICBjb25zdCBhbGxPZiA9IHNjaGVtYS5hbGxPZi5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgIC8vIGJlZm9yZSBtZXJnaW5nIGFsbE9mIHNjaGVtYSB3ZSBuZWVkIHRvIHJlc29sdmUgYWxsIHN1YnNjaGVtYXNcbiAgICAgICAgICAgIC8vIGlmIG5vdCwgd2Ugd291bGQgd3JvbmdseSBtZXJnZSBvbmVPZiwgaWYtdGhlbiBzdGF0ZW1lbnRzLCBldGNcbiAgICAgICAgICAgIGlmIChpc0R5bmFtaWNTY2hlbWEocykpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IG9mIHJlZHVjZVNjaGVtYVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXNvbHZlRHluYW1pY1NjaGVtYShkcmFmdCwgcywgZGF0YSwgcG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXJnZVNjaGVtYShzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb21pdChyZXN1bHQsIC4uLnRvT21pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhbGxPZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxPZlNjaGVtYSA9IG1lcmdlQWxsT2ZTY2hlbWEoZHJhZnQsIHsgYWxsT2YgfSk7XG4gICAgICAgICAgICByZXNvbHZlZFNjaGVtYSA9IG1lcmdlU2NoZW1hKHJlc29sdmVkU2NoZW1hICE9PSBudWxsICYmIHJlc29sdmVkU2NoZW1hICE9PSB2b2lkIDAgPyByZXNvbHZlZFNjaGVtYSA6IHt9LCBhbGxPZlNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQGZlYXR1cmUgYW55T2ZcbiAgICBjb25zdCBhbnlPZlNjaGVtYSA9IG1lcmdlVmFsaWRBbnlPZlNjaGVtYShkcmFmdCwgc2NoZW1hLCBkYXRhKTtcbiAgICBpZiAoYW55T2ZTY2hlbWEpIHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXNvbHZlZFNjaGVtYSAhPT0gdm9pZCAwID8gcmVzb2x2ZWRTY2hlbWEgOiB7fSwgYW55T2ZTY2hlbWEpO1xuICAgIH1cbiAgICAvLyBAZmVhdHVyZSBkZXBlbmRlbmNpZXNcbiAgICBjb25zdCBkZXBlbmRlbmNpZXNTY2hlbWEgPSByZXNvbHZlRGVwZW5kZW5jaWVzKGRyYWZ0LCBzY2hlbWEsIGRhdGEpO1xuICAgIGlmIChkZXBlbmRlbmNpZXNTY2hlbWEpIHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXNvbHZlZFNjaGVtYSAhPT0gdm9pZCAwID8gcmVzb2x2ZWRTY2hlbWEgOiB7fSwgZGVwZW5kZW5jaWVzU2NoZW1hKTtcbiAgICB9XG4gICAgLy8gQGZlYXR1cmUgaWYtdGhlbi1lbHNlXG4gICAgY29uc3QgaWZTY2hlbWEgPSByZXNvbHZlSWZTY2hlbWEoZHJhZnQsIHNjaGVtYSwgZGF0YSk7XG4gICAgaWYgKGlmU2NoZW1hKSB7XG4gICAgICAgIHJlc29sdmVkU2NoZW1hID0gbWVyZ2VTY2hlbWEocmVzb2x2ZWRTY2hlbWEgIT09IG51bGwgJiYgcmVzb2x2ZWRTY2hlbWEgIT09IHZvaWQgMCA/IHJlc29sdmVkU2NoZW1hIDoge30sIGlmU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHJlc29sdmVkU2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBuZXN0ZWRTY2hlbWEgPSByZXNvbHZlRHluYW1pY1NjaGVtYShkcmFmdCwgcmVzb2x2ZWRTY2hlbWEsIGRhdGEsIHBvaW50ZXIpO1xuICAgIGlmIChuZXN0ZWRTY2hlbWEpIHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSwgbmVzdGVkU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIG9taXQocmVzb2x2ZWRTY2hlbWEsIC4uLnRvT21pdCk7XG59XG4iLCJpbXBvcnQgeyBtZXJnZVNjaGVtYSB9IGZyb20gXCIuL21lcmdlU2NoZW1hXCI7XG5pbXBvcnQgeyByZXNvbHZlRHluYW1pY1NjaGVtYSB9IGZyb20gXCIuL3Jlc29sdmVEeW5hbWljU2NoZW1hXCI7XG5pbXBvcnQgeyBvbWl0IH0gZnJvbSBcIi4vdXRpbHMvb21pdFwiO1xuY29uc3QgdG9PbWl0ID0gW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcIm9uZU9mXCIsIFwiZGVwZW5kZW5jaWVzXCIsIFwiaWZcIiwgXCJ0aGVuXCIsIFwiZWxzZVwiXTtcbi8qKlxuICogcmVkdWNlcyBqc29uIHNjaGVtYSBieSBtZXJnaW5nIGR5bmFtaWMgY29uc3RydWN0cyBsaWtlIGlmLXRoZW4tZWxzZSxcbiAqIGRlcGVuZGVuY2llcywgYWxsT2YsIGFueU9mLCBvbmVPZiwgZXRjIGludG8gYSBzdGF0aWMganNvbiBzY2hlbWFcbiAqIG9taXR0aW5nIHRob3NlIHByb3BlcnRpZXMuXG4gKlxuICogQHJldHVybnMgaW5wdXQgc2NoZW1hIHJlZHVjZWQgYnkgZHluYW1pYyBzY2hlbWEgZGVmaW5pdGlvbnMgZm9yIHRoZSBnaXZlblxuICogaW5wdXQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlU2NoZW1hKGRyYWZ0LCBzY2hlbWEsIGRhdGEsIHBvaW50ZXIpIHtcbiAgICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlRHluYW1pY1NjaGVtYShkcmFmdCwgc2NoZW1hLCBkYXRhLCBwb2ludGVyKTtcbiAgICBpZiAocmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShzY2hlbWEsIHJlc29sdmVkU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG9taXQocmVzb2x2ZWRTY2hlbWEsIC4uLnRvT21pdCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG4iLCJpbXBvcnQgY29weSBmcm9tIFwiLi4vdXRpbHMvY29weVwiO1xuZXhwb3J0IGNsYXNzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNjaGVtYSkge1xuICAgICAgICAvKiogY2FjaGUgZm9yIHJlbW90ZSBzY2hlbWFzICovXG4gICAgICAgIHRoaXMucmVtb3RlcyA9IHt9O1xuICAgICAgICAvKiogZXJyb3IgY3JlYXRvcnMgYnkgaWQgKi9cbiAgICAgICAgdGhpcy5lcnJvcnMgPSB7fTtcbiAgICAgICAgLyoqIG1hcCBmb3IgdmFsaWQga2V5d29yZHMgb2YgYSB0eXBlICAqL1xuICAgICAgICB0aGlzLnR5cGVLZXl3b3JkcyA9IHt9O1xuICAgICAgICAvKioga2V5d29yZCB2YWxpZGF0b3JzICAqL1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5d29yZCA9IHt9O1xuICAgICAgICAvKiogdHlwZSB2YWxpZGF0b3JzICAqL1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZSA9IHt9O1xuICAgICAgICAvKiogZm9ybWF0IHZhbGlkYXRvcnMgICovXG4gICAgICAgIHRoaXMudmFsaWRhdGVGb3JtYXQgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudHlwZUtleXdvcmRzID0gY29weShjb25maWcudHlwZUtleXdvcmRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUtleXdvcmQgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcudmFsaWRhdGVLZXl3b3JkKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcudmFsaWRhdGVUeXBlKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm1hdCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy52YWxpZGF0ZUZvcm1hdCk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLmVycm9ycyk7XG4gICAgICAgIHRoaXMuc2V0U2NoZW1hKHNjaGVtYSk7XG4gICAgfVxuICAgIGdldCByb290U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3Jvb3RTY2hlbWE7XG4gICAgfVxuICAgIHNldCByb290U2NoZW1hKHJvb3RTY2hlbWEpIHtcbiAgICAgICAgaWYgKHJvb3RTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19yb290U2NoZW1hID0gdGhpcy5jb25maWcuY29tcGlsZVNjaGVtYSh0aGlzLCByb290U2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgYSBqc29uLXNjaGVtYSB0byBiZSByZWZlcmVuY2VkIGZyb20gYW5vdGhlciBqc29uLXNjaGVtYVxuICAgICAqIEBwYXJhbSB1cmwgLSBiYXNlLXVybCBvZiBqc29uLXNjaGVtYSAoYWthIGlkKVxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBqc29uLXNjaGVtYSByb290XG4gICAgICovXG4gICAgYWRkUmVtb3RlU2NoZW1hKHVybCwgc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFkZFJlbW90ZVNjaGVtYSh0aGlzLCB1cmwsIHNjaGVtYSk7XG4gICAgfVxuICAgIGNvbXBpbGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvbXBpbGVTY2hlbWEodGhpcywgc2NoZW1hLCAoX2EgPSB0aGlzLnJvb3RTY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNjaGVtYSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjaGVtYU9mKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNyZWF0ZVNjaGVtYU9mKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGRhdGEsIHJldHJpZXZpbmcgaXRzIHNjaGVtYVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSB0aGUgZGF0YSB0byBpdGVyYXRlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gd2lsbCBiZSBjYWxsZWQgd2l0aCAoc2NoZW1hLCBkYXRhLCBwb2ludGVyKSBvbiBlYWNoIGl0ZW1cbiAgICAgKiBAcGFyYW0gW3NjaGVtYV0gLSB0aGUgc2NoZW1hIG1hdGNoaW5nIHRoZSBkYXRhLiBEZWZhdWx0cyB0byByb290U2NoZW1hXG4gICAgICogQHBhcmFtIFtwb2ludGVyXSAtIHBvaW50ZXIgdG8gY3VycmVudCBkYXRhLiBEZWZhdWx0IHRvIHJvb3RQb2ludGVyXG4gICAgICovXG4gICAgZWFjaChkYXRhLCBjYWxsYmFjaywgc2NoZW1hLCBwb2ludGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5lYWNoKHRoaXMsIGRhdGEsIGNhbGxiYWNrLCBzY2hlbWEsIHBvaW50ZXIpO1xuICAgIH1cbiAgICBlYWNoU2NoZW1hKGNhbGxiYWNrLCBzY2hlbWEgPSB0aGlzLnJvb3RTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmVhY2hTY2hlbWEoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldENoaWxkU2NoZW1hU2VsZWN0aW9uKHByb3BlcnR5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmdldENoaWxkU2NoZW1hU2VsZWN0aW9uKHRoaXMsIHByb3BlcnR5LCBzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqc29uLXNjaGVtYSBvZiBhIGRhdGEtanNvbi1wb2ludGVyLlxuICAgICAqXG4gICAgICogVG8gcmVzb2x2ZSBkeW5hbWljIHNjaGVtYSB3aGVyZSB0aGUgdHlwZSBvZiBqc29uLXNjaGVtYSBpcyBldmFsdWF0ZWQgYnlcbiAgICAgKiBpdHMgdmFsdWUsIGEgZGF0YSBvYmplY3QgaGFzIHRvIGJlIHBhc3NlZCBpbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogUGVyIGRlZmF1bHQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgdmFsaWQgcHJvcGVydGllcyB0aGF0XG4gICAgICogZG8gbm90IGhhdmUgYSBkZWZpbmVkIHNjaGVtYS4gVXNlIHRoZSBvcHRpb24gYHdpdGhTY2hlbWFXYXJuaW5nOiB0cnVlYCB0b1xuICAgICAqIHJlY2VpdmUgYW4gZXJyb3Igd2l0aCBgY29kZTogc2NoZW1hLXdhcm5pbmdgIGNvbnRhaW5pbmcgdGhlIGxvY2F0aW9uIG9mIGl0c1xuICAgICAqIGxhc3QgZXZhbHVhdGVkIGpzb24tc2NoZW1hLlxuICAgICAqXG4gICAgICogTm90ZXNcbiAgICAgKiAgICAgIC0gdXNlcyBkcmFmdC5zdGVwIHRvIHdhbGsgdGhyb3VnaCBkYXRhIGFuZCBzY2hlbWFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFmdFxuICAgICAqIEBwYXJhbSBwb2ludGVyIC0ganNvbiBwb2ludGVyIGluIGRhdGEgdG8gZ2V0IHRoZSBqc29uIHNjaGVtYSBmb3JcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMuZGF0YV0gLSB0aGUgZGF0YSBvYmplY3QsIHdoaWNoIGluY2x1ZGVzIHRoZSBqc29uIHBvaW50ZXJzIHZhbHVlLiBUaGlzIGlzIG9wdGlvbmFsLCBhc1xuICAgICAqICAgIGxvbmcgYXMgbm8gb25lT2YsIGFueU9mLCBldGMgc3RhdGVtZW50IGlzIHBhcnQgb2YgdGhlIHBvaW50ZXJzIHNjaGVtYVxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5zY2hlbWFdIC0gdGhlIGpzb24gc2NoZW1hIHRvIGl0ZXJhdGUuIERlZmF1bHRzIHRvIGRyYWZ0LnJvb3RTY2hlbWFcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMud2l0aFNjaGVtYVdhcm5pbmddIC0gaWYgdHJ1ZSByZXR1cm5zIGFuIGVycm9yIGluc3RlYWQgb2YgYHVuZGVmaW5lZGAgZm9yIHZhbGlkIHByb3BlcnRpZXMgbWlzc2luZyBhIHNjaGVtYSBkZWZpbml0aW9uXG4gICAgICogQHJldHVybiByZXNvbHZlZCBqc29uLXNjaGVtYSBvYmplY3Qgb2YgcmVxdWVzdGVkIGpzb24tcG9pbnRlciBsb2NhdGlvblxuICAgICAqL1xuICAgIGdldFNjaGVtYShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5nZXRTY2hlbWEodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkYXRhIG9iamVjdCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2NoZW1hXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2RhdGFdIC0gb3B0aW9uYWwgdGVtcGxhdGUgZGF0YVxuICAgICAqIEBwYXJhbSBbc2NoZW1hXSAtIGpzb24gc2NoZW1hLCBkZWZhdWx0cyB0byByb290U2NoZW1hXG4gICAgICogQHJldHVybiBjcmVhdGVkIHRlbXBsYXRlIGRhdGFcbiAgICAgKi9cbiAgICBnZXRUZW1wbGF0ZShkYXRhLCBzY2hlbWEsIG9wdHMgPSB0aGlzLmNvbmZpZy50ZW1wbGF0ZURlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5nZXRUZW1wbGF0ZSh0aGlzLCBkYXRhLCBzY2hlbWEsIG9wdHMpO1xuICAgIH1cbiAgICBpc1ZhbGlkKGRhdGEsIHNjaGVtYSwgcG9pbnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuaXNWYWxpZCh0aGlzLCBkYXRhLCBzY2hlbWEsIHBvaW50ZXIpO1xuICAgIH1cbiAgICByZXNvbHZlQW55T2YoZGF0YSwgc2NoZW1hLCBwb2ludGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5yZXNvbHZlQW55T2YodGhpcywgZGF0YSwgc2NoZW1hLCBwb2ludGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZUFsbE9mKGRhdGEsIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucmVzb2x2ZUFsbE9mKHRoaXMsIGRhdGEsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJlc29sdmVSZWYoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5yZXNvbHZlUmVmKHNjaGVtYSwgdGhpcy5yb290U2NoZW1hKTtcbiAgICB9XG4gICAgcmVzb2x2ZU9uZU9mKGRhdGEsIHNjaGVtYSwgcG9pbnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucmVzb2x2ZU9uZU9mKHRoaXMsIGRhdGEsIHNjaGVtYSwgcG9pbnRlcik7XG4gICAgfVxuICAgIHNldFNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5yb290U2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqc29uLXNjaGVtYSBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHByb3BlcnR5IG9yIGFycmF5IGl0ZW0uXG4gICAgICogZS5nLiBpdCBzdGVwcyBieSBvbmUga2V5IGludG8gdGhlIGRhdGFcbiAgICAgKlxuICAgICAqICBUaGlzIGhlbHBlciBkZXRlcm1pbmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgcHJvcGVydHkgd2l0aGluIHRoZSBzY2hlbWEgKGFkZGl0aW9uYWwgcHJvcGVydGllcywgb25lT2YsIC4uLikgYW5kXG4gICAgICogIHJldHVybnMgdGhlIGNvcnJlY3Qgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtICBrZXkgICAgICAgLSBwcm9wZXJ0eS1uYW1lIG9yIGFycmF5LWluZGV4XG4gICAgICogQHBhcmFtICBzY2hlbWEgICAgLSBqc29uIHNjaGVtYSBvZiBjdXJyZW50IGRhdGFcbiAgICAgKiBAcGFyYW0gIGRhdGEgICAgICAtIHBhcmVudCBvZiBrZXlcbiAgICAgKiBAcGFyYW0gIFtwb2ludGVyXSAtIHBvaW50ZXIgdG8gc2NoZW1hIGFuZCBkYXRhIChwYXJlbnQgb2Yga2V5KVxuICAgICAqIEByZXR1cm4gU2NoZW1hIG9yIEVycm9yIGlmIGZhaWxlZCByZXNvbHZpbmcga2V5XG4gICAgICovXG4gICAgc3RlcChrZXksIHNjaGVtYSwgZGF0YSwgcG9pbnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc3RlcCh0aGlzLCBrZXksIHNjaGVtYSwgZGF0YSwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGRhdGEgYnkgYSBqc29uIHNjaGVtYVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gdmFsaWRhdGVcbiAgICAgKiBAcGFyYW0gW3NjaGVtYV0gLSBqc29uIHNjaGVtYSwgZGVmYXVsdHMgdG8gcm9vdFNjaGVtYVxuICAgICAqIEBwYXJhbSBbcG9pbnRlcl0gLSBqc29uIHBvaW50ZXIgcG9pbnRpbmcgdG8gdmFsdWUgKHVzZWQgZm9yIGVycm9yLW1lc3NhZ2VzIG9ubHkpXG4gICAgICogQHJldHVybiBsaXN0IG9mIGVycm9ycyBvciBlbXB0eVxuICAgICAqL1xuICAgIHZhbGlkYXRlKGRhdGEsIHNjaGVtYSwgcG9pbnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcudmFsaWRhdGUodGhpcywgZGF0YSwgc2NoZW1hLCBwb2ludGVyKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIHJlZ2lzdGVyIGEganNvbi1zY2hlbWEgdG8gYmUgcmVmZXJlbmNlZCBmcm9tIGFub3RoZXIganNvbi1zY2hlbWFcbiAqIEBwYXJhbSB1cmwgICAgYmFzZS11cmwgb2YganNvbi1zY2hlbWEgKGFrYSBpZClcbiAqIEBwYXJhbSBzY2hlbWFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkUmVtb3RlU2NoZW1hKGRyYWZ0LCB1cmwsIHNjaGVtYSkge1xuICAgIHNjaGVtYS5pZCA9IHNjaGVtYS5pZCB8fCB1cmw7XG4gICAgZHJhZnQucmVtb3Rlc1t1cmxdID0gZHJhZnQuY29tcGlsZVNjaGVtYShzY2hlbWEpO1xufVxuIiwiZXhwb3J0IGNvbnN0IHByb3BlcnR5UmVnZXggPSBcIltePy97fSosKCkjXStcIjtcbi8vIFczQyBFTkJGIGdyYW1tYXJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9seXMtbGFuZy9ub2RlLWVibmYvYmxvYi9tYXN0ZXIvdGVzdC9XM0NFQk5GLnNwZWMudHNcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI3NlYy1ub3RhdGlvblxuZXhwb3J0IGNvbnN0IGpzb25RdWVyeUdyYW1tYXIgPSBgXG5yb290IDo6PSAoXCIjXCIgcmVjdXJzaW9uIHwgcmVjdXJzaW9uIHwgKHF1ZXJ5IHwgcGF0dGVybikgcmVjdXJzaW9uKiB8IFwiI1wiIFNFUD8gfCBTRVApXG5yZWN1cnNpb24gOjo9IChTRVAgcXVlcnkgfCBwYXR0ZXJuKSpcblxucXVlcnkgOjo9IChFU0MgZXNjYXBlZCBFU0MgfCBwcm9wZXJ0eSB8IGFsbCB8IGFueSB8IHJlZ2V4KSB0eXBlY2hlY2s/IGxvb2thaGVhZD9cbnByb3BlcnR5IDo6PSAke3Byb3BlcnR5UmVnZXh9XG5yZWdleCA6Oj0gXCJ7XCIgW159XSsgXCJ9XCJcblNFUCA6Oj0gXCIvXCJcbmFsbCA6Oj0gXCIqKlwiXG5hbnkgOjo9IFwiKlwiXG5cbnR5cGVjaGVjayA6Oj0gXCI/OlwiIChcInZhbHVlXCIgfCBcImJvb2xlYW5cIiB8IFwic3RyaW5nXCIgfCBcIm51bWJlclwiIHwgXCJvYmplY3RcIiB8IFwiYXJyYXlcIilcbmxvb2thaGVhZCA6Oj0gXCI/XCIgZXhwcmVzc2lvbiAoKGFuZEV4cHIgfCBvckV4cHIpIGV4cHJlc3Npb24pKlxuYW5kRXhwciA6Oj0gUz8gXCImJlwiIFM/XG5vckV4cHIgOjo9IFM/IFwifHxcIiBTP1xuXG5leHByZXNzaW9uIDo6PSAoZXhwclByb3BlcnR5IHwgRVNDIGVzY2FwZWQgRVNDKSAoKGlzbm90IHwgaXMpIChleHByUHJvcGVydHkgfCByZWdleCB8IEVTQyBlc2NhcGVkIEVTQykpKlxuZXhwclByb3BlcnR5IDo6PSBbYS16QS1aMC05LV8gJF0rXG5lc2NhcGVkIDo6PSBbXlwiXStcbmlzIDo6PSBcIjpcIlxuaXNub3QgOjo9IFwiOiFcIlxuRVNDIDo6PSAnXCInXG5cbnBhdHRlcm4gOjo9IFM/IFwiKFwiIChTRVAgcXVlcnkgfCBwYXR0ZXJuIChvclBhdHRlcm4/IHBhdHRlcm4pKikqIFwiKVwiIHF1YW50aWZpZXI/IFM/IGxvb2thaGVhZD9cbnF1YW50aWZpZXIgOjo9IFwiK1wiIHwgXCIqXCIgfCBbMC05XStcbm9yUGF0dGVybiA6Oj0gUz8gXCIsXCIgUz9cblxuUyA6Oj0gWyBdKlxuYDtcbiIsImltcG9ydCBFQk5GIGZyb20gXCJlYm5mL2Rpc3QvR3JhbW1hcnMvVzNDRUJORlwiO1xuaW1wb3J0IHsganNvblF1ZXJ5R3JhbW1hciB9IGZyb20gXCIuL2pzb25RdWVyeUdyYW1tYXJcIjtcbmNvbnN0IHZhbGlkID0gLyhjaGlsZHJlbnx0ZXh0fHR5cGV8c3RhcnR8ZW5kfHJlc3R8ZXJyb3JzfGZ1bGxUZXh0fFxcZCspLztcbmNvbnN0IHN1YnNldCA9IC8oY2hpbGRyZW58dGV4dHx0eXBlfFxcZCspLztcbmNvbnN0IHRvSlNPTiA9IChhc3QpID0+IEpTT04uc3RyaW5naWZ5KGFzdCwgKGtleSwgdmFsdWUpID0+IChrZXkgPT09IFwiXCIgfHwgdmFsaWQudGVzdChrZXkpID8gdmFsdWUgOiB1bmRlZmluZWQpLCAyKTtcbmNvbnN0IHRvU21hbGxKU09OID0gKGFzdCkgPT4gSlNPTi5zdHJpbmdpZnkoYXN0LCAoa2V5LCB2YWx1ZSkgPT4ga2V5ID09PSBcIlwiIHx8IChrZXkgPT09IFwicmVzdFwiICYmIHZhbHVlICE9PSBcIlwiKSB8fCBzdWJzZXQudGVzdChrZXkpXG4gICAgPyB2YWx1ZVxuICAgIDogdW5kZWZpbmVkLCAyKTtcbmNvbnN0IHBhcnNlciA9IG5ldyBFQk5GLlBhcnNlcihqc29uUXVlcnlHcmFtbWFyKTtcbmV4cG9ydCBjb25zdCBwYXJzZSA9IChxdWVyeSkgPT4gcGFyc2VyLmdldEFTVChxdWVyeSk7XG5leHBvcnQgY29uc3QgcmVkdWNlID0gKGFzdCkgPT4gSlNPTi5wYXJzZSh0b1NtYWxsSlNPTihhc3QpKTtcbmV4cG9ydCB7IHRvSlNPTiB9O1xuIiwiZXhwb3J0IGNvbnN0IFZBTFVFX0lOREVYID0gMDtcbmV4cG9ydCBjb25zdCBLRVlfSU5ERVggPSAxO1xuZXhwb3J0IGNvbnN0IFBBUkVOVF9JTkRFWCA9IDI7XG5leHBvcnQgY29uc3QgUE9JTlRFUl9JTkRFWCA9IDM7XG4iLCJjb25zdCBqb2luID0gKGEsIGIpID0+IGAke2F9LyR7Yn1gO1xuaW1wb3J0IHsgVkFMVUVfSU5ERVgsIFBPSU5URVJfSU5ERVggfSBmcm9tIFwiLi9rZXlzXCI7XG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCByQ29udGFpbmVyID0gL09iamVjdHxBcnJheS87XG5jb25zdCBpc0NvbnRhaW5lciA9ICh2KSA9PiByQ29udGFpbmVyLnRlc3QodG9TdHJpbmcuY2FsbCh2KSk7XG5jb25zdCBnZXRUeXBlT2YgPSAodikgPT4gdG9TdHJpbmdcbiAgICAuY2FsbCh2KVxuICAgIC5tYXRjaCgvXFxzKFteXFxdXSspXFxdLylcbiAgICAucG9wKClcbiAgICAudG9Mb3dlckNhc2UoKTtcbmZ1bmN0aW9uIG5vZGVBc1JlZ2V4KG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChub2RlLnRleHQucmVwbGFjZSgvKF57fH0kKS9nLCBcIlwiKSk7XG59XG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgb2JqZWN0IG9yIGFycmF5LCBwYXNzaW5nIGVhY2gga2V5LCB2YWx1ZSBhbmQgcGFyZW50T2JqZWN0IHRvIHRoZSBjYWxsYmFja1xuICogQHBhcmFtIHZhbHVlIC0gdG8gaXRlcmF0ZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gcmVjZWl2aW5nIGtleSBvbiBnaXZlbiBpbnB1dCB2YWx1ZVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKHBhcmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBhcmVudCkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhcmVudFtrZXldLCBrZXksIHBhcmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhbGwga2V5cyBvZiB0aGUgZ2l2ZW4gaW5wdXQgZGF0YVxuICogQHBhcmFtICB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl9IGNvbnRhaW5pbmcga2V5cyBvZiBnaXZlbiB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRLZXlzKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2luZGV4fWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5jb25zdCBjYWNoZSA9IHtcbiAgICBtZW06IFtdLFxuICAgIGdldChlbnRyeSwgcHJvcCkge1xuICAgICAgICBjb25zdCB2ID0gZW50cnlbVkFMVUVfSU5ERVhdW3Byb3BdO1xuICAgICAgICBpZiAoY2FjaGUubWVtLmluY2x1ZGVzKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcih2KSkge1xuICAgICAgICAgICAgY2FjaGUubWVtLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt2LCBwcm9wLCBlbnRyeVtWQUxVRV9JTkRFWF0sIGpvaW4oZW50cnlbUE9JTlRFUl9JTkRFWF0sIHByb3ApXTtcbiAgICB9LFxuICAgIHJlc2V0KCkge1xuICAgICAgICBjYWNoZS5tZW0ubGVuZ3RoID0gMDtcbiAgICB9LFxufTtcbmNvbnN0IGV4cGFuZCA9IHtcbiAgICBhbnkobm9kZSwgZW50cnkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbnRyeVtWQUxVRV9JTkRFWF07XG4gICAgICAgIHJldHVybiAoZ2V0S2V5cyh2YWx1ZSlcbiAgICAgICAgICAgIC8vIC5tYXAocHJvcCA9PiBjYWNoZS5nZXQoZW50cnksIHByb3ApKTtcbiAgICAgICAgICAgIC5tYXAoKHByb3ApID0+IFtcbiAgICAgICAgICAgIHZhbHVlW3Byb3BdLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgam9pbihlbnRyeVtQT0lOVEVSX0lOREVYXSwgcHJvcCksXG4gICAgICAgIF0pKTtcbiAgICB9LFxuICAgIGFsbChub2RlLCBlbnRyeSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbZW50cnldO1xuICAgICAgICBmb3JFYWNoKGVudHJ5W1ZBTFVFX0lOREVYXSwgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVudHJ5ID0gY2FjaGUuZ2V0KGVudHJ5LCBwcm9wKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGNoaWxkRW50cnkgPSBbdmFsdWUsIHByb3AsIGVudHJ5W1ZBTFVFX0lOREVYXSwgam9pbihlbnRyeVtQT0lOVEVSX0lOREVYXSwgcHJvcCldO1xuICAgICAgICAgICAgY2hpbGRFbnRyeSAmJiByZXN1bHQucHVzaCguLi5leHBhbmQuYWxsKG5vZGUsIGNoaWxkRW50cnkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICByZWdleChub2RlLCBlbnRyeSkge1xuICAgICAgICBjb25zdCByZWdleCA9IG5vZGVBc1JlZ2V4KG5vZGUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVudHJ5W1ZBTFVFX0lOREVYXTtcbiAgICAgICAgcmV0dXJuIGdldEtleXModmFsdWUpXG4gICAgICAgICAgICAuZmlsdGVyKChwcm9wKSA9PiByZWdleC50ZXN0KHByb3ApKVxuICAgICAgICAgICAgLm1hcCgocHJvcCkgPT4gW1xuICAgICAgICAgICAgdmFsdWVbcHJvcF0sXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBqb2luKGVudHJ5W1BPSU5URVJfSU5ERVhdLCBwcm9wKSxcbiAgICAgICAgXSk7XG4gICAgfSxcbn07XG5jb25zdCBzZWxlY3QgPSB7XG4gICAgLy8gYWxpYXMgdG8gcHJvcGVydHkgKGJ1dCBlc2NhcGVkKVxuICAgIGVzY2FwZWQ6IChub2RlLCBlbnRyeSkgPT4gc2VsZWN0LnByb3BlcnR5KG5vZGUsIGVudHJ5KSxcbiAgICBwcm9wZXJ0eTogKG5vZGUsIGVudHJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBub2RlLnRleHQ7XG4gICAgICAgIGlmIChlbnRyeVtWQUxVRV9JTkRFWF0gJiYgZW50cnlbVkFMVUVfSU5ERVhdW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZW50cnlbVkFMVUVfSU5ERVhdW3Byb3BdLFxuICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgZW50cnlbVkFMVUVfSU5ERVhdLFxuICAgICAgICAgICAgICAgIGpvaW4oZW50cnlbUE9JTlRFUl9JTkRFWF0sIHByb3ApLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHlwZWNoZWNrOiAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tlZFR5cGVkID0gbm9kZS50ZXh0LnJlcGxhY2UoL15cXD86LywgXCJcIik7XG4gICAgICAgIGlmIChjaGVja2VkVHlwZWQgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGFpbmVyKGVudHJ5W1ZBTFVFX0lOREVYXSkgPyB1bmRlZmluZWQgOiBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZU9mKGVudHJ5W1ZBTFVFX0lOREVYXSk7XG4gICAgICAgIGlmICh0eXBlID09PSBjaGVja2VkVHlwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbG9va2FoZWFkOiAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgbGV0IG9yID0gZmFsc2U7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoZXhwcikgPT4ge1xuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJleHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gc2VsZWN0LmV4cHJlc3Npb24oZXhwciwgZW50cnkpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSBvciA9PT0gdHJ1ZSA/IHZhbGlkIHx8IGlzVmFsaWQgOiB2YWxpZCAmJiBpc1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3IgPSBleHByLnR5cGUgPT09IFwib3JFeHByXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWQgPyBlbnRyeSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGV4cHJlc3Npb246IChub2RlLCBlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wID0gbm9kZS5jaGlsZHJlblswXS50ZXh0O1xuICAgICAgICBjb25zdCBjbXAgPSBub2RlLmNoaWxkcmVuWzFdO1xuICAgICAgICBjb25zdCB0ZXN0ID0gbm9kZS5jaGlsZHJlblsyXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbnRyeVtWQUxVRV9JTkRFWF07XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcih2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uTWF0Y2hlcyh2YWx1ZVtwcm9wXSwgY21wLCB0ZXN0KSA/IGVudHJ5IDogdW5kZWZpbmVkO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZXhwcmVzc2lvbk1hdGNoZXModmFsdWUsIGNtcCwgdGVzdCkge1xuICAgIGlmIChjbXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHZhbGlkO1xuICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gYCR7dmFsdWV9YDtcbiAgICBpZiAodGVzdC50eXBlID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBub2RlQXNSZWdleCh0ZXN0KTtcbiAgICAgICAgdmFsaWQgPSByZWdleC50ZXN0KHZhbHVlU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWVTdHJpbmcgPT09IHRlc3QudGV4dDtcbiAgICB9XG4gICAgaWYgKGNtcC50eXBlID09PSBcImlzbm90XCIpIHtcbiAgICAgICAgdmFsaWQgPSB2YWxpZCA9PT0gZmFsc2UgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xufVxuZXhwb3J0IHsgZXhwYW5kLCBzZWxlY3QsIGNhY2hlIH07XG4iLCJpbXBvcnQgeyBleHBhbmQsIHNlbGVjdCwgY2FjaGUgfSBmcm9tIFwiLi9ub2Rlc1wiO1xuaW1wb3J0IHsgVkFMVUVfSU5ERVgsIEtFWV9JTkRFWCwgUEFSRU5UX0lOREVYLCBQT0lOVEVSX0lOREVYIH0gZnJvbSBcIi4va2V5c1wiO1xuZnVuY3Rpb24gY29sbGVjdChmdW5jLCBpbnB1dCwgbm9kZSwgcG9pbnRlcikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaW5wdXQubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmZ1bmMobm9kZSwgaW5wdXRbaV0sIG5vZGUsIHBvaW50ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlZHVjZShmdW5jLCBpbnB1dCwgbm9kZSwgcG9pbnRlcikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaW5wdXQubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGZ1bmMobm9kZSwgaW5wdXRbaV0sIHBvaW50ZXIpO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBxdWVyeShkYXRhLCBhc3QsIHBvaW50ZXIpIHtcbiAgICBsZXQgcmVzdWx0ID0gZGF0YTtcbiAgICBhc3QuY2hpbGRyZW4uZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoZXhwYW5kW25vZGUudHlwZV0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3QoZXhwYW5kW25vZGUudHlwZV0sIHJlc3VsdCwgbm9kZSwgcG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0W25vZGUudHlwZV0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlZHVjZShzZWxlY3Rbbm9kZS50eXBlXSwgcmVzdWx0LCBub2RlLCBwb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWx0ZXIgJHtub2RlLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcnVuUGF0dGVybk9uY2UoaW5wdXRTZXQsIGFzdCwgcG9pbnRlcikge1xuICAgIGNvbnN0IHJlc3VsdGluZ1NldCA9IFtdO1xuICAgIGxldCB3b3JraW5nU2V0ID0gaW5wdXRTZXQ7XG4gICAgYXN0LmNoaWxkcmVuLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJvclBhdHRlcm5cIikge1xuICAgICAgICAgICAgcmVzdWx0aW5nU2V0LnB1c2goLi4ud29ya2luZ1NldCk7XG4gICAgICAgICAgICB3b3JraW5nU2V0ID0gaW5wdXRTZXQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya2luZ1NldCA9IHJ1bk5vZGUod29ya2luZ1NldCwgbm9kZSwgcG9pbnRlcik7XG4gICAgfSk7XG4gICAgcmVzdWx0aW5nU2V0LnB1c2goLi4ud29ya2luZ1NldCk7XG4gICAgcmV0dXJuIHJlc3VsdGluZ1NldDtcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhdGlvbkNvdW50KHF1YW50aWZpZXIpIHtcbiAgICBpZiAocXVhbnRpZmllciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxOyAvLyBkZWZhdWx0LCBzaW1wbGUgZ3JvdXBcbiAgICB9XG4gICAgaWYgKHF1YW50aWZpZXIgPT09IFwiKlwiIHx8IHF1YW50aWZpZXIgPT09IFwiK1wiKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBwYXJzZUludChxdWFudGlmaWVyKTtcbiAgICByZXR1cm4gaXNOYU4oY291bnQpID8gMSA6IGNvdW50O1xufVxuZnVuY3Rpb24gcGF0dGVybihkYXRhLCBhc3QsIHBvaW50ZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBxdWFudGlmaWVyID0gYXN0LmNoaWxkcmVuLmZpbmQoKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gXCJxdWFudGlmaWVyXCIpO1xuICAgIGNvbnN0IGl0ZXJhdGlvbkNvdW50ID0gZ2V0SXRlcmF0aW9uQ291bnQocXVhbnRpZmllciAmJiBxdWFudGlmaWVyLnRleHQpO1xuICAgIGxldCB3b3JraW5nU2V0ID0gZGF0YTtcbiAgICBpZiAocXVhbnRpZmllciAmJiBxdWFudGlmaWVyLnRleHQgPT09IFwiKlwiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLndvcmtpbmdTZXQpO1xuICAgIH1cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHdoaWxlICh3b3JraW5nU2V0Lmxlbmd0aCA+IDAgJiYgY291bnQgPCBpdGVyYXRpb25Db3VudCkge1xuICAgICAgICB3b3JraW5nU2V0ID0gcnVuUGF0dGVybk9uY2Uod29ya2luZ1NldCwgYXN0LCBwb2ludGVyKTtcbiAgICAgICAgcmVzdWx0LnB1c2goLi4ud29ya2luZ1NldCk7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBza2lwKGRhdGEsIGFzdCwgcG9pbnRlcikge1xuICAgIGxldCByZXN1bHQgPSBkYXRhO1xuICAgIGFzdC5jaGlsZHJlbi5mb3JFYWNoKChuKSA9PiAocmVzdWx0ID0gcnVuTm9kZShyZXN1bHQsIG4sIHBvaW50ZXIpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJ1bk5vZGUoZGF0YSwgYXN0LCBwb2ludGVyKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoYXN0LnR5cGUgPT09IFwicXVlcnlcIikge1xuICAgICAgICByZXN1bHQgPSBxdWVyeShkYXRhLCBhc3QsIHBvaW50ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QudHlwZSA9PT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybihkYXRhLCBhc3QsIHBvaW50ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc2tpcChkYXRhLCBhc3QsIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvLyBhZnRlciBlYWNoIHF1ZXJ5IG9yIHBhdHRlcm4sIHJlc2V0IHRoZSBjYWNoZSwgdG8gKHJlKWVuYWJsZSBuZXN0ZWQgcXVlcmllc1xuICAgIGNhY2hlLnJlc2V0KCk7XG4gICAgY2FjaGUubWVtLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBydW4oZGF0YSwgYXN0KSB7XG4gICAgY2FjaGUucmVzZXQoKTtcbiAgICBjYWNoZS5tZW0ucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcnVuTm9kZShbW2RhdGEsIG51bGwsIG51bGwsIFwiI1wiXV0sIGFzdCk7XG59XG5leHBvcnQgeyBWQUxVRV9JTkRFWCwgS0VZX0lOREVYLCBQQVJFTlRfSU5ERVgsIFBPSU5URVJfSU5ERVggfTtcbiIsImltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBydW4sIFZBTFVFX0lOREVYLCBQT0lOVEVSX0lOREVYIH0gZnJvbSBcIi4vaW50ZXJwcmV0ZXJcIjtcbmNvbnN0IHJldHVyblR5cGVzID0ge1xuICAgIHZhbHVlOiAocikgPT4gci5tYXAoKGUpID0+IGVbVkFMVUVfSU5ERVhdKSxcbiAgICBwb2ludGVyOiAocikgPT4gci5tYXAoKGUpID0+IGVbUE9JTlRFUl9JTkRFWF0pLFxuICAgIGFsbDogKHIpID0+IHIsXG4gICAgbWFwOiAocikgPT4ge1xuICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgci5mb3JFYWNoKChlKSA9PiAobWFwW2VbUE9JTlRFUl9JTkRFWF1dID0gZVtWQUxVRV9JTkRFWF0pKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxufTtcbmV4cG9ydCB2YXIgUmV0dXJuVHlwZTtcbihmdW5jdGlvbiAoUmV0dXJuVHlwZSkge1xuICAgIFJldHVyblR5cGVbXCJQT0lOVEVSXCJdID0gXCJwb2ludGVyXCI7XG4gICAgUmV0dXJuVHlwZVtcIlZBTFVFXCJdID0gXCJ2YWx1ZVwiO1xuICAgIFJldHVyblR5cGVbXCJBTExcIl0gPSBcImFsbFwiO1xuICAgIFJldHVyblR5cGVbXCJNQVBcIl0gPSBcIm1hcFwiO1xufSkoUmV0dXJuVHlwZSB8fCAoUmV0dXJuVHlwZSA9IHt9KSk7XG4vLyBleHBvcnQgcmV0dXJuIHR5cGVzIG9uIGZ1bmN0aW9uXG5nZXQuUE9JTlRFUiA9IFJldHVyblR5cGUuUE9JTlRFUjtcbmdldC5WQUxVRSA9IFJldHVyblR5cGUuVkFMVUU7XG5nZXQuQUxMID0gUmV0dXJuVHlwZS5BTEw7XG5nZXQuTUFQID0gUmV0dXJuVHlwZS5NQVA7XG4vKipcbiAqIFJ1bnMgcXVlcnkgb24gaW5wdXQgZGF0YSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0c1xuICogQHBhcmFtIGRhdGEgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0gcXVlcnlTdHJpbmcgLSBqc29uLXF1ZXJ5IHN0cmluZ1xuICogQHBhcmFtIHJldHVyblR5cGUgLSByZXN1bHQgZm9ybWF0IG9yIGEgY3VzdG9tIGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoZGF0YSwgcXVlcnlTdHJpbmcsIHJldHVyblR5cGUgPSBSZXR1cm5UeXBlLlZBTFVFKSB7XG4gICAgaWYgKHF1ZXJ5U3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoLyhcXC8kKS9nLCBcIlwiKTtcbiAgICBpZiAocXVlcnlTdHJpbmcgPT09IFwiXCIpIHtcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBcIiNcIjtcbiAgICB9XG4gICAgY29uc3QgYXN0ID0gcGFyc2UocXVlcnlTdHJpbmcpO1xuICAgIGlmIChhc3QgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGFzdCBmb3IgJyR7cXVlcnlTdHJpbmd9J2ApO1xuICAgIH1cbiAgICBpZiAoYXN0LnJlc3QgIT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgcGFyc2luZyBxdWVyeVN0cmluZyBmcm9tOiAnJHthc3QucmVzdH0nYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJ1bihkYXRhLCBhc3QpO1xuICAgIGlmICh0eXBlb2YgcmV0dXJuVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKChyKSA9PiByZXR1cm5UeXBlKC4uLnIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmV0dXJuVHlwZXNbcmV0dXJuVHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGVzW3JldHVyblR5cGVdKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBwYXJzZSB9IGZyb20gXCIuL3BhcnNlclwiO1xuY29uc3Qgc2tpcCA9IFtcInJvb3RcIiwgXCJyZWN1cnNpb25cIl07XG5mdW5jdGlvbiBidWlsZFBhdGgobm9kZSwgcGF0aCA9IFtdKSB7XG4gICAgaWYgKHNraXAuaW5jbHVkZXMobm9kZS50eXBlKSkge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKG4pID0+IGJ1aWxkUGF0aChuLCBwYXRoKSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICAvLyByZW1vdmUgZXNjYXBlZCBwcm9wZXJ0eSBxdW90ZXM/XG4gICAgcGF0aC5wdXNoKG5vZGUudGV4dCk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIFJldHVybnMgcXVlcnlTdHJpbmcgYXMgYSBsaXN0IG9mIHByb3BlcnR5LXF1ZXJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KHF1ZXJ5U3RyaW5nKSB7XG4gICAgaWYgKHF1ZXJ5U3RyaW5nID09IG51bGwgfHwgcXVlcnlTdHJpbmcgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhc3QgPSBwYXJzZShxdWVyeVN0cmluZyk7XG4gICAgLy8gY29uc29sZS5sb2codG9KU09OKGFzdCwgbnVsbCwgMikpO1xuICAgIHJldHVybiBidWlsZFBhdGgoYXN0KTtcbn1cbiIsImltcG9ydCB7IGdldCwgUmV0dXJuVHlwZSB9IGZyb20gXCIuL2dldFwiO1xuaW1wb3J0IHsgcHJvcGVydHlSZWdleCB9IGZyb20gXCIuL3BhcnNlci9qc29uUXVlcnlHcmFtbWFyXCI7XG5pbXBvcnQgeyBzcGxpdCB9IGZyb20gXCIuL3NwbGl0XCI7XG5jb25zdCBjcCA9ICh2KSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHYpKTtcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IGdldFR5cGUgPSAodikgPT4gdG9TdHJpbmdcbiAgICAuY2FsbCh2KVxuICAgIC5tYXRjaCgvXFxzKFteXFxdXSspXFxdLylcbiAgICAucG9wKClcbiAgICAudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzUHJvcGVydHkgPSBuZXcgUmVnRXhwKGBeKFwiW15cIl0rXCJ8JHtwcm9wZXJ0eVJlZ2V4fSkkYCk7XG5jb25zdCBpZ25vcmVUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdO1xuY29uc3QgaXNBcnJheSA9IC9eXFxbXFxkKlxcXSQvO1xuY29uc3QgYXJyYXlIYXNJbmRleCA9IC9eXFxbKFxcZCspXFxdJC87XG5jb25zdCBpc0VzY2FwZWQgPSAvXlwiLitcIiQvO1xuY29uc3QgaXNBcnJheVByb3AgPSAvKF5cXFtcXGQqXFxdJHxeXFxkKyQpLztcbmZ1bmN0aW9uIGNvbnZlcnRUb0luZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGluZGV4LnJlcGxhY2UoL14oXFxbfFxcXSQpLywgXCJcIikpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXNjYXBlKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGlzRXNjYXBlZC50ZXN0KHByb3BlcnR5KVxuICAgICAgICA/IHByb3BlcnR5LnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIlwiKVxuICAgICAgICA6IHByb3BlcnR5O1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0KHdvcmtpbmdTZXQsIHF1ZXJ5KSB7XG4gICAgY29uc3QgbmV4dFNldCA9IFtdO1xuICAgIHdvcmtpbmdTZXQuZm9yRWFjaCgoZCkgPT4gbmV4dFNldC5wdXNoKC4uLmdldChkWzBdLCBxdWVyeSwgUmV0dXJuVHlwZS5BTEwpKSk7XG4gICAgcmV0dXJuIG5leHRTZXQ7XG59XG5mdW5jdGlvbiBhZGRUb0FycmF5KHJlc3VsdCwgaW5kZXgsIHZhbHVlLCBmb3JjZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHJlc3VsdFswXTtcbiAgICAvLyBhcHBlbmQgaXRlbT9cbiAgICBpZiAoL15cXFtcXF0kLy50ZXN0KGluZGV4KSkge1xuICAgICAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGkgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRbaV0sIGksIHRhcmdldCwgYCR7cmVzdWx0WzNdfS8ke2l9fWBdO1xuICAgIH1cbiAgICAvLyBtZXJnZSBhcnJheSBpdGVtP1xuICAgIGlmIChmb3JjZSA9PSBudWxsICYmXG4gICAgICAgIGdldFR5cGUodGFyZ2V0W2luZGV4XSkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZ2V0VHlwZSh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXRbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0W2luZGV4XSwgaW5kZXgsIHRhcmdldCwgYCR7cmVzdWx0WzNdfS8ke2luZGV4fX1gXTtcbiAgICB9XG4gICAgaWYgKGZvcmNlID09PSBzZXQuSU5TRVJUX0lURU1TIHx8XG4gICAgICAgIChmb3JjZSA9PSBudWxsICYmIGFycmF5SGFzSW5kZXgudGVzdChpbmRleCkpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5SW5kZXggPSBjb252ZXJ0VG9JbmRleChpbmRleCk7XG4gICAgICAgIGluc2VydCh0YXJnZXQsIGFycmF5SW5kZXgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRhcmdldFthcnJheUluZGV4XSxcbiAgICAgICAgICAgIGFycmF5SW5kZXgsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBgJHtyZXN1bHRbM119LyR7YXJyYXlJbmRleH19YCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGZvcmNlID09PSBzZXQuUkVQTEFDRV9JVEVNUyB8fCBmb3JjZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGFycmF5SW5kZXggPSBjb252ZXJ0VG9JbmRleChpbmRleCk7XG4gICAgICAgIHRhcmdldFthcnJheUluZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGFyZ2V0W2FycmF5SW5kZXhdLFxuICAgICAgICAgICAgYXJyYXlJbmRleCxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGAke3Jlc3VsdFszXX0vJHthcnJheUluZGV4fX1gLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXJyYXkgaW5kZXggJyR7aW5kZXh9JyB3aXRoIGZvcmNlLW9wdGlvbiAnJHtmb3JjZX0nYCk7XG59XG5mdW5jdGlvbiBjcmVhdGUod29ya2luZ1NldCwgcXVlcnksIGtleUlzQXJyYXksIGZvcmNlKSB7XG4gICAgcXVlcnkgPSByZW1vdmVFc2NhcGUocXVlcnkpO1xuICAgIHJldHVybiB3b3JraW5nU2V0XG4gICAgICAgIC5maWx0ZXIoKG8pID0+IHtcbiAgICAgICAgLy8gcmVwbGFjaW5nIG9yIGluc2VydGluZyBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvWzBdKSAmJiBpc0FycmF5UHJvcC50ZXN0KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlnbm9yZVR5cGVzLmluY2x1ZGVzKGdldFR5cGUob1swXVtxdWVyeV0pKSA9PT0gZmFsc2U7XG4gICAgfSlcbiAgICAgICAgLm1hcCgocikgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBrZXlJc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgY29uc3QgbyA9IHJbMF07XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclR5cGUgPSBnZXRUeXBlKGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gZ2V0VHlwZShvW3F1ZXJ5XSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pICYmIGl0ZW1UeXBlICE9PSBjb250YWluZXJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkVG9BcnJheShyLCBxdWVyeSwgY29udGFpbmVyLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgICAgb1txdWVyeV0gPSBvW3F1ZXJ5XSB8fCBjb250YWluZXI7XG4gICAgICAgIHJldHVybiBbb1txdWVyeV0sIHF1ZXJ5LCBvLCBgJHtyWzNdfS8ke3F1ZXJ5fWBdO1xuICAgIH0pO1xufVxuZXhwb3J0IHZhciBJbnNlcnRNb2RlO1xuKGZ1bmN0aW9uIChJbnNlcnRNb2RlKSB7XG4gICAgSW5zZXJ0TW9kZVtcIlJFUExBQ0VfSVRFTVNcIl0gPSBcInJlcGxhY2VcIjtcbiAgICBJbnNlcnRNb2RlW1wiSU5TRVJUX0lURU1TXCJdID0gXCJpbnNlcnRcIjtcbn0pKEluc2VydE1vZGUgfHwgKEluc2VydE1vZGUgPSB7fSkpO1xuLy8gZm9yIGFsbCBhcnJheS1pbmRpY2VzIHdpdGhpbiBwYXRoLCByZXBsYWNlIHRoZSB2YWx1ZXMsIGlnbm9yaW5nIGluc2VydGlvbiBzeW50YXggL1sxXS9cbnNldC5SRVBMQUNFX0lURU1TID0gSW5zZXJ0TW9kZS5SRVBMQUNFX0lURU1TO1xuLy8gZm9yIGFsbCBhcnJheS1pbmRpY2VzIHdpdGhpbiBwYXRoLCBpbnNlcnQgdGhlIHZhbHVlcywgaWdub3JpbmcgcmVwbGFjZSBzeW50YXggLzEvXG5zZXQuSU5TRVJUX0lURU1TID0gSW5zZXJ0TW9kZS5JTlNFUlRfSVRFTVM7XG4vLyBzZXQuTUVSR0VfSVRFTVMgPSBcIm1lcmdlXCI7XG4vKipcbiAqIFJ1bnMgcXVlcnkgb24gaW5wdXQgZGF0YSBhbmQgYXNzaWducyBhIHZhbHVlIHRvIHF1ZXJ5LXJlc3VsdHMuXG4gKiBAcGFyYW0gZGF0YSAtIGlucHV0IGRhdGFcbiAqIEBwYXJhbSBxdWVyeVN0cmluZyAtIGpzb24tcXVlcnkgc3RyaW5nXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBhc3NpZ25cbiAqIEBwYXJhbSBbZm9yY2VdIC0gd2hldGhlciB0byByZXBsYWNlIG9yIGluc2VydCBpbnRvIGFycmF5c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KGRhdGEsIHF1ZXJ5U3RyaW5nLCB2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAocXVlcnlTdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY3AoZGF0YSk7XG4gICAgfVxuICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgvKFxcLyQpL2csIFwiXCIpO1xuICAgIGlmIChxdWVyeVN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gY3AodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBjcChkYXRhKTtcbiAgICBsZXQgd29ya2luZ1NldCA9IFtbcmVzdWx0LCBudWxsLCBudWxsLCBcIiNcIl1dO1xuICAgIGNvbnN0IHBhdGggPSBzcGxpdChxdWVyeVN0cmluZyk7XG4gICAgY29uc3QgcHJvcGVydHkgPSBwYXRoLnBvcCgpO1xuICAgIGNvbnN0IGFycmF5V2l0aG91dEluZGV4ID0gaXNBcnJheS50ZXN0KHByb3BlcnR5KSAmJiBhcnJheUhhc0luZGV4LnRlc3QocHJvcGVydHkpID09PSBmYWxzZTtcbiAgICBpZiAoaXNQcm9wZXJ0eS50ZXN0KHByb3BlcnR5KSA9PT0gZmFsc2UgfHwgYXJyYXlXaXRob3V0SW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBxdWVyeSAnJHtxdWVyeVN0cmluZ30nIGVuZGluZyB3aXRoIG5vbi1wcm9wZXJ0eWApO1xuICAgIH1cbiAgICBwYXRoLmZvckVhY2goKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoXCJfX3Byb3RvX19cIiA9PT0gcXVlcnkgfHxcbiAgICAgICAgICAgIFwicHJvdG90eXBlZFwiID09PSBxdWVyeSB8fFxuICAgICAgICAgICAgXCJjb25zdHJ1Y3RvclwiID09PSBxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3BlcnR5LnRlc3QocXVlcnkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgd29ya2luZ1NldCA9IHNlbGVjdCh3b3JraW5nU2V0LCBxdWVyeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvY2VzcyBwcm9wZXJ0eSAmIG1pc3NpbmcgZGF0YS1zdHJ1Y3R1cmVcbiAgICAgICAgY29uc3QgbmV4dEtleSA9IGluZGV4ID49IHBhdGgubGVuZ3RoIC0gMSA/IHByb3BlcnR5IDogcGF0aFtpbmRleCArIDFdO1xuICAgICAgICBjb25zdCBpbnNlcnRBcnJheSA9IGlzQXJyYXlQcm9wLnRlc3QobmV4dEtleSk7XG4gICAgICAgIHdvcmtpbmdTZXQgPSBjcmVhdGUod29ya2luZ1NldCwgcXVlcnksIGluc2VydEFycmF5LCBmb3JjZSk7XG4gICAgfSk7XG4gICAgd29ya2luZ1NldC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGxldCB0YXJnZXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSB2YWx1ZShyWzNdLCBwcm9wZXJ0eSwgclswXSwgYCR7clszXX0vJHtwcm9wZXJ0eX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gclswXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZCkpIHtcbiAgICAgICAgICAgIGFkZFRvQXJyYXkociwgcHJvcGVydHksIHRhcmdldFZhbHVlLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1bmVzY2FwZWRQcm9wID0gcmVtb3ZlRXNjYXBlKHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChcIl9fcHJvdG9fX1wiID09PSB1bmVzY2FwZWRQcm9wIHx8XG4gICAgICAgICAgICAgICAgXCJwcm90b3R5cGVkXCIgPT09IHVuZXNjYXBlZFByb3AgfHxcbiAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yXCIgPT09IHVuZXNjYXBlZFByb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkW3VuZXNjYXBlZFByb3BdID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgcmVtb3ZlIGFzIHJlbW92ZVBvaW50ZXIsIHJlbW92ZVVuZGVmaW5lZEl0ZW1zLCB9IGZyb20gXCJAc2Fnb2xkL2pzb24tcG9pbnRlclwiO1xuaW1wb3J0IHsgZ2V0LCBSZXR1cm5UeXBlIH0gZnJvbSBcIi4vZ2V0XCI7XG5pbXBvcnQgeyBQQVJFTlRfSU5ERVgsIFBPSU5URVJfSU5ERVggfSBmcm9tIFwiLi9pbnRlcnByZXRlci9rZXlzXCI7XG4vKipcbiAqIFJ1bnMgcXVlcnkgb24gaW5wdXQgZGF0YSBhbmQgcmVtb3ZlcyBtYXRjaGluZyBwcm9wZXJ0aWVzIGZyb20gcmVzdWx0c1xuICogQHBhcmFtIGRhdGEgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0gcXVlcnlTdHJpbmcgLSBqc29uLXF1ZXJ5IHN0cmluZ1xuICogQHBhcmFtIFtyZXR1cm5SZW1vdmVkXSAtIGlmIHRydWUsIHdpbGwgcmV0dXJuZWQgcmVtb3ZlZCBwcm9wZXJ0aWVzLCBlbHNlIGlucHV0LWRhdGEgaXMgcmVtb3ZlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGRhdGEsIHF1ZXJ5U3RyaW5nLCByZXR1cm5SZW1vdmVkID0gZmFsc2UpIHtcbiAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgY29uc3QgbWF0Y2hlcyA9IGdldChkYXRhLCBxdWVyeVN0cmluZywgUmV0dXJuVHlwZS5BTEwpO1xuICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgcmVtb3ZlUG9pbnRlcihkYXRhLCBtYXRjaFtQT0lOVEVSX0lOREVYXSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaFtQQVJFTlRfSU5ERVhdKSkge1xuICAgICAgICAgICAgcmVtb3ZlVW5kZWZpbmVkSXRlbXMobWF0Y2hbUEFSRU5UX0lOREVYXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuUmVtb3ZlZCA/IHJlbW92ZWQgOiBkYXRhO1xufVxuIiwiaW1wb3J0IHsgZ2V0LCBSZXR1cm5UeXBlIH0gZnJvbSBcIi4vbGliL2dldFwiO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSBcIi4vbGliL3NldFwiO1xuaW1wb3J0IHsgc3BsaXQgfSBmcm9tIFwiLi9saWIvc3BsaXRcIjtcbmltcG9ydCB7IHJlbW92ZSB9IGZyb20gXCIuL2xpYi9yZW1vdmVcIjtcbmV4cG9ydCB7IGdldCwgc2V0LCBzcGxpdCwgcmVtb3ZlLCBSZXR1cm5UeXBlIH07XG5leHBvcnQgZGVmYXVsdCB7IGdldCwgc2V0LCBzcGxpdCwgcmVtb3ZlLCBSZXR1cm5UeXBlIH07XG4iLCJjb25zdCBUeXBlcyA9IHtcbiAgICAkcmVmOiB7XG4gICAgICAgIHR5cGU6IGZhbHNlXG4gICAgfSxcbiAgICBhbGxPZjoge1xuICAgICAgICB0eXBlOiBmYWxzZSxcbiAgICAgICAgZGVmaW5pdGlvbnM6IFtcImFsbE9mLypcIl1cbiAgICB9LFxuICAgIGFueU9mOiB7XG4gICAgICAgIHR5cGU6IGZhbHNlLFxuICAgICAgICBkZWZpbml0aW9uczogW1wiYW55T2YvKlwiXVxuICAgIH0sXG4gICAgYXJyYXk6IHtcbiAgICAgICAgdHlwZTogdHJ1ZSxcbiAgICAgICAgLy8gaWdub3JlIGFkZGl0aW9uYWxJdGVtczpUeXBlRGVmLCB3aGVuIGl0ZW1zOlR5cGVEZWZcbiAgICAgICAgZGVmaW5pdGlvbnM6IFtcbiAgICAgICAgICAgIFwiYWxsT2YvKlwiLFxuICAgICAgICAgICAgXCJhbnlPZi8qXCIsXG4gICAgICAgICAgICBcIm9uZU9mLypcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCIsXG4gICAgICAgICAgICBcIml0ZW1zLypcIixcbiAgICAgICAgICAgIFwiYWRkaXRpb25hbEl0ZW1zXCJcbiAgICAgICAgXSxcbiAgICAgICAgdmFsaWRhdGlvbktleXdvcmRzOiBbXCJtaW5JdGVtc1wiLCBcIm1heEl0ZW1zXCIsIFwidW5pcXVlSXRlbXNcIl0sXG4gICAgICAgIGtleXdvcmRzOiBbXCJpdGVtc1wiLCBcImFkZGl0aW9uYWxJdGVtc1wiLCBcIm1pbkl0ZW1zXCIsIFwibWF4SXRlbXNcIiwgXCJ1bmlxdWVJdGVtc1wiXVxuICAgIH0sXG4gICAgYm9vbGVhbjoge1xuICAgICAgICB0eXBlOiB0cnVlXG4gICAgfSxcbiAgICBlbnVtOiB7XG4gICAgICAgIHR5cGU6IGZhbHNlXG4gICAgfSxcbiAgICBpbnRlZ2VyOiB7XG4gICAgICAgIHR5cGU6IHRydWUsXG4gICAgICAgIGRlZmluaXRpb25zOiBbXCJhbGxPZi8qXCIsIFwiYW55T2YvKlwiLCBcIm9uZU9mLypcIiwgXCJub3RcIl0sXG4gICAgICAgIHZhbGlkYXRpb25LZXl3b3JkczogW1wibWluaW11bVwiLCBcIm1heGltdW1cIiwgXCJtdWx0aXBsZU9mXCJdXG4gICAgfSxcbiAgICBub3Q6IHtcbiAgICAgICAgdHlwZTogZmFsc2UsXG4gICAgICAgIGRlZmluaXRpb25zOiBbXCJub3RcIl1cbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgICB0eXBlOiB0cnVlLFxuICAgICAgICBkZWZpbml0aW9uczogW1wiYWxsT2YvKlwiLCBcImFueU9mLypcIiwgXCJvbmVPZi8qXCIsIFwibm90XCJdLFxuICAgICAgICB2YWxpZGF0aW9uS2V5d29yZHM6IFtcIm1pbmltdW1cIiwgXCJtYXhpbXVtXCIsIFwibXVsdGlwbGVPZlwiXVxuICAgIH0sXG4gICAgbnVsbDoge1xuICAgICAgICB0eXBlOiB0cnVlXG4gICAgfSxcbiAgICBvYmplY3Q6IHtcbiAgICAgICAgdHlwZTogdHJ1ZSxcbiAgICAgICAgLy8gcGF0dGVyblByb3BlcnRpZXMgYWxzbyB2YWxpZGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGRlcGVuZGVuY2llczooc3RyaW5nLCBUeXBlRGVmKSBleHRlbmQgY3VycmVudCBUeXBlRGVmXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgUHJvcGVydGllcyB2YWxpZGF0ZSBvbmx5IHJlbWFpbmluZyBwcm9wZXJ0aWVzIChhZnRlciBwcm9wZXJ0aWVzICYgcGF0dGVybilcbiAgICAgICAgZGVmaW5pdGlvbnM6IFtcbiAgICAgICAgICAgIFwiYWxsT2YvKlwiLFxuICAgICAgICAgICAgXCJhbnlPZi8qXCIsXG4gICAgICAgICAgICBcIm9uZU9mLypcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcInByb3BlcnRpZXMvKlwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuUHJvcGVydGllcy8qXCIsXG4gICAgICAgICAgICBcImRlcGVuZGVuY2llcy8qXCJcbiAgICAgICAgXSxcbiAgICAgICAgdmFsaWRhdGlvbktleXdvcmRzOiBbXCJtaW5Qcm9wZXJ0aWVzXCIsIFwibWF4UHJvcGVydGllc1wiLCBcInJlcXVpcmVkXCJdLFxuICAgICAgICBrZXl3b3JkczogW1xuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcImRlcGVuZGVuY2llc1wiLFxuICAgICAgICAgICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIlxuICAgICAgICBdXG4gICAgfSxcbiAgICBvbmVPZjoge1xuICAgICAgICB0eXBlOiBmYWxzZSxcbiAgICAgICAgZGVmaW5pdGlvbnM6IFtcIm9uZU9mLypcIl1cbiAgICB9LFxuICAgIHN0cmluZzoge1xuICAgICAgICB0eXBlOiB0cnVlLFxuICAgICAgICBkZWZpbml0aW9uczogW1wiYWxsT2YvKlwiLCBcImFueU9mLypcIiwgXCJvbmVPZi8qXCIsIFwibm90XCJdLFxuICAgICAgICB2YWxpZGF0aW9uS2V5d29yZHM6IFtcIm1pbkxlbmd0aFwiLCBcIm1heExlbmd0aFwiLCBcInBhdHRlcm5cIl1cbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgVHlwZXM7XG4iLCJpbXBvcnQgdHlwZXMgZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4uL3V0aWxzL2lzT2JqZWN0XCI7XG5jb25zdCB0eXBlS2V5d29yZHMgPSBPYmplY3Qua2V5cyh0eXBlcykuZmlsdGVyKChpZCkgPT4gdHlwZXNbaWRdLnR5cGUgPT09IGZhbHNlKTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQHRocm93cyBFcnJvciAgICBvbiBtdWx0aXBsZSBtYXRjaGVzIChpbnZhbGlkIHNjaGVtYSlcbiAqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIGlkIG9mIGEgc2NoZW1hIG9iamVjdFxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB0eXBlIGlkLCBpZiBmb3VuZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUeXBlSWQoc2NoZW1hKSB7XG4gICAgaWYgKGlzT2JqZWN0KHNjaGVtYSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuZW51bSkge1xuICAgICAgICByZXR1cm4gXCJlbnVtXCI7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSB8fCB0eXBlc1t0eXBlXSkge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgY29uc3QgaWRzID0gdHlwZUtleXdvcmRzLmZpbHRlcigodHlwZSkgPT4gc2NoZW1hW3R5cGVdKTtcbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gaWRzWzBdO1xuICAgIH1cbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBAZXhwZW5zaXZlLCBndWVzcyB0eXBlIG9iamVjdFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHR5cGVzLm9iamVjdC5rZXl3b3Jkcy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmQgPSB0eXBlcy5vYmplY3Qua2V5d29yZHNbaV07XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGtleXdvcmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBleHBlbnNpdmUsIGd1ZXNzIHR5cGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0eXBlcy5hcnJheS5rZXl3b3Jkcy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmQgPSB0eXBlcy5hcnJheS5rZXl3b3Jkc1tpXTtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga2V5d29yZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11dGlwbGUgdHlwZUlkcyBbJHtpZHMuam9pbihcIiwgXCIpfV0gbWF0Y2hlZCBpbiAke0pTT04uc3RyaW5naWZ5KHNjaGVtYSl9YCk7XG59XG4iLCJpbXBvcnQgZ3AgZnJvbSBcIkBzYWdvbGQvanNvbi1wb2ludGVyXCI7XG5pbXBvcnQgeyBnZXQgfSBmcm9tIFwiQHNhZ29sZC9qc29uLXF1ZXJ5XCI7XG5pbXBvcnQgZ2V0VHlwZUlkIGZyb20gXCIuL2dldFR5cGVJZFwiO1xuaW1wb3J0IHR5cGVzIGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCIuLi91dGlscy9pc09iamVjdFwiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgKGRpcmVjdCkgdHlwZSBkZWZpbml0aW9ucyBmcm9tIHRoZSBnaXZlbiBzY2hlbWFcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4gbGlzdCBvZiB0eXBlIGRlZmluaXRpb24sIGdpdmVuIGFzIHsgcG9pbnRlciwgZGVmIH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VHlwZURlZnMoc2NoZW1hKSB7XG4gICAgY29uc3QgZGVmcyA9IFtdO1xuICAgIGNvbnN0IGlkID0gZ2V0VHlwZUlkKHNjaGVtYSk7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZnM7XG4gICAgfVxuICAgIGxldCB0eXBlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICAvLyBzaW5jZSB0eXBlcyBjYW4gYWxzbyBiZSBkZWNsYXJlZCBhcyBhIHNldCBvZiB0eXBlcywgbWVyZ2UgdGhlIGRlZmluaXRpb25zXG4gICAgICAgIC8vIG1heWJlIHRoaXMgd2lsbCByZXF1aXJlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIGFwcHJvYWNoXG4gICAgICAgIHR5cGUgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpZC5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZSwgdHlwZXNbaWRbaV1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHR5cGVzW2lkXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuZGVmaW5pdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmcztcbiAgICB9XG4gICAgdHlwZS5kZWZpbml0aW9ucy5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBnZXQoc2NoZW1hLCBxdWVyeSwgKHZhbHVlLCBrZXksIHBhcmVudCwgcG9pbnRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBnZXRUeXBlSWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVmcy5wdXNoKHsgcG9pbnRlcjogZ3Auam9pbihncC5zcGxpdChwb2ludGVyKSwgZmFsc2UpLCBkZWY6IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmcztcbn1cbiIsImltcG9ydCBncCBmcm9tIFwiQHNhZ29sZC9qc29uLXBvaW50ZXJcIjtcbmltcG9ydCBnZXRUeXBlRGVmcyBmcm9tIFwiLi9zY2hlbWEvZ2V0VHlwZURlZnNcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHMvaXNPYmplY3RcIjtcbmZ1bmN0aW9uIG5leHRUeXBlRGVmcyhzY2hlbWEsIHBvaW50ZXIpIHtcbiAgICBpZiAodGhpcy5jYWxsYmFjayhzY2hlbWEsIHBvaW50ZXIpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgICAgIHJldHVybjsgLy8gc3RvcCBpdGVyYXRpb25cbiAgICB9XG4gICAgY29uc3QgZGVmcyA9IGdldFR5cGVEZWZzKHNjaGVtYSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuICAgIGRlZnMuZm9yRWFjaCgobmV4dCkgPT4gdGhpcy5uZXh0VHlwZURlZnMobmV4dC5kZWYsIGdwLmpvaW4ocG9pbnRlciwgbmV4dC5wb2ludGVyLCBmYWxzZSkpKTtcbn1cbmZ1bmN0aW9uIGVhY2hEZWZpbml0aW9uKHdhbGssIHNjaGVtYSwgcG9pbnRlciwga2V5ID0gXCJkZWZpbml0aW9uc1wiKSB7XG4gICAgY29uc3QgZGVmcyA9IHNjaGVtYVtrZXldO1xuICAgIE9iamVjdC5rZXlzKGRlZnMpLmZvckVhY2goKGRlZklkKSA9PiB7XG4gICAgICAgIGlmIChkZWZzW2RlZklkXSA9PT0gZmFsc2UgfHwgaXNPYmplY3QoZGVmc1tkZWZJZF0pKSB7XG4gICAgICAgICAgICB3YWxrLm5leHRUeXBlRGVmcyhkZWZzW2RlZklkXSwgZ3Auam9pbihwb2ludGVyLCBrZXksIGRlZklkLCBmYWxzZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBJbnZhbGlkIHNjaGVtYSBpbiAke3BvaW50ZXJ9LyR7a2V5fS8ke2RlZklkfWApO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hTY2hlbWEoc2NoZW1hLCBjYWxsYmFjaywgcG9pbnRlciA9IFwiI1wiKSB7XG4gICAgY29uc3Qgd2FsayA9IHsgY2FsbGJhY2ssIG5leHRUeXBlRGVmcyB9O1xuICAgIHdhbGsubmV4dFR5cGVEZWZzKHNjaGVtYSwgcG9pbnRlcik7XG4gICAgaWYgKHNjaGVtYS5kZWZpbml0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHdhbGsuY2FsbGJhY2sgPSAoZGVmc2NoZW1hLCBzY2hlbWFQb2ludGVyKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhkZWZzY2hlbWEsIHNjaGVtYVBvaW50ZXIpO1xuICAgICAgICAgICAgaWYgKGRlZnNjaGVtYS5kZWZpbml0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWFjaERlZmluaXRpb24od2FsaywgZGVmc2NoZW1hLCBzY2hlbWFQb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWFjaERlZmluaXRpb24od2Fsaywgc2NoZW1hLCBwb2ludGVyKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS4kZGVmcyAhPSBudWxsKSB7XG4gICAgICAgIHdhbGsuY2FsbGJhY2sgPSAoZGVmc2NoZW1hLCBzY2hlbWFQb2ludGVyKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhkZWZzY2hlbWEsIHNjaGVtYVBvaW50ZXIpO1xuICAgICAgICAgICAgaWYgKGRlZnNjaGVtYS5kZWZpbml0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWFjaERlZmluaXRpb24od2FsaywgZGVmc2NoZW1hLCBzY2hlbWFQb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWFjaERlZmluaXRpb24od2Fsaywgc2NoZW1hLCBwb2ludGVyLCBcIiRkZWZzXCIpO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludCBtYXgtc3RhdGVtZW50cy1wZXItbGluZTogW1wiZXJyb3JcIiwgeyBcIm1heFwiOiAyIH1dICovXG5jb25zdCBzdWZmaXhlcyA9IC8oI3xcXC8pKyQvO1xuY29uc3QgdHJhaWxpbmdIYXNoID0gLyMkLztcbmNvbnN0IGlzRG9tYWluID0gL15bXjpdKzpcXC9cXC9bXi9dK1xcLy87XG5jb25zdCB0cmFpbGluZ0ZyYWdtZW50cyA9IC9cXC9bXi9dKiQvO1xuY29uc3QgaWRBbmRQb2ludGVyID0gLyMuKiQvO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gam9pblNjb3BlKHByZXZpb3VzLCBpZCkge1xuICAgIGlmIChwcmV2aW91cyA9PSBudWxsICYmIGlkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiI1wiO1xuICAgIH1cbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXMucmVwbGFjZSh0cmFpbGluZ0hhc2gsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWQucmVwbGFjZSh0cmFpbGluZ0hhc2gsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoaWRbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtwcmV2aW91cy5yZXBsYWNlKGlkQW5kUG9pbnRlciwgXCJcIil9JHtpZC5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKX1gO1xuICAgIH1cbiAgICBpZiAoaXNEb21haW4udGVzdChpZCkpIHtcbiAgICAgICAgcmV0dXJuIGlkLnJlcGxhY2UodHJhaWxpbmdIYXNoLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZXZpb3VzLnJlcGxhY2UodHJhaWxpbmdGcmFnbWVudHMsIFwiXCIpfS8ke2lkLnJlcGxhY2UodHJhaWxpbmdIYXNoLCBcIlwiKX1gO1xufVxuIiwiY29uc3Qgc3VmZml4ZXMgPSAvKCN8XFwvKSskL2c7XG5jb25zdCBlbXB0eVZhbHVlcyA9IFtcIlwiLCBudWxsLCBcIiNcIl07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcGxpdFJlZigkcmVmKSB7XG4gICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKCRyZWYpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgJHJlZiA9ICRyZWYucmVwbGFjZShzdWZmaXhlcywgXCJcIik7XG4gICAgaWYgKCRyZWYuaW5kZXhPZihcIiNcIikgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJHJlZi5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKV07XG4gICAgfVxuICAgIGlmICgkcmVmLmluZGV4T2YoXCIjXCIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbJHJlZi5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9ICRyZWYuc3BsaXQoXCIjXCIpO1xuICAgIHJlc3VsdFswXSA9IHJlc3VsdFswXS5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKTtcbiAgICByZXN1bHRbMV0gPSBgIyR7cmVzdWx0WzFdLnJlcGxhY2Uoc3VmZml4ZXMsIFwiXCIpfWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IGdldCB9IGZyb20gXCJAc2Fnb2xkL2pzb24tcG9pbnRlclwiO1xuaW1wb3J0IHNwbGl0UmVmIGZyb20gXCIuL3NwbGl0UmVmXCI7XG5pbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi9nZXRUeXBlT2ZcIjtcbmNvbnN0IHN1ZmZpeGVzID0gLygjfFxcLykrJC9nO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiBnZXRUeXBlT2YodmFsKSA9PT0gXCJvYmplY3RcIjtcbi8vIDEuIGNvbWJpbmVkIGlzIGtub3duXG4vLyAyLiBiYXNlIG9yIHBvaW50ZXIgaXMga25vd25cbi8vIDMuIGJhc2UgKyBwb2ludGVyIGlzIGtub3duXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWYoY29udGV4dCwgcm9vdFNjaGVtYSwgJHJlZikge1xuICAgIGlmIChpc09iamVjdCgkcmVmKSkge1xuICAgICAgICAkcmVmID0gJHJlZi5fX3JlZiB8fCAkcmVmLiRyZWY7XG4gICAgfVxuICAgIGlmICgkcmVmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RTY2hlbWE7XG4gICAgfVxuICAgIGxldCBzY2hlbWE7XG4gICAgLy8gaXMgaXQgYSBrbm93biAkcmVmP1xuICAgIGNvbnN0ICRyZW1vdGUgPSAkcmVmLnJlcGxhY2Uoc3VmZml4ZXMsIFwiXCIpO1xuICAgIGlmIChjb250ZXh0LnJlbW90ZXNbJHJlbW90ZV0pIHtcbiAgICAgICAgc2NoZW1hID0gY29udGV4dC5yZW1vdGVzWyRyZW1vdGVdO1xuICAgICAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS4kcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVmKGNvbnRleHQsIHJvb3RTY2hlbWEsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5pZHNbJHJlZl0pIHtcbiAgICAgICAgc2NoZW1hID0gZ2V0KHJvb3RTY2hlbWEsIGNvbnRleHQuaWRzWyRyZWZdKTtcbiAgICAgICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuJHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlZihjb250ZXh0LCByb290U2NoZW1hLCBzY2hlbWEuJHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgLy8gaXMgaXQgYSByZWYgd2l0aCBob3N0L3BvaW50ZXI/XG4gICAgY29uc3QgZnJhZ21lbnRzID0gc3BsaXRSZWYoJHJlZik7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJvb3RTY2hlbWE7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICRyZWYgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIGlmIChjb250ZXh0LnJlbW90ZXNbJHJlZl0pIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IGNvbnRleHQucmVtb3Rlc1skcmVmXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWYoY29udGV4dCwgcm9vdFNjaGVtYSwgc2NoZW1hLiRyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0Lmlkc1skcmVmXSkge1xuICAgICAgICAgICAgc2NoZW1hID0gZ2V0KHJvb3RTY2hlbWEsIGNvbnRleHQuaWRzWyRyZWZdKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVmKGNvbnRleHQsIHJvb3RTY2hlbWEsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgJHJlZiA9IGZyYWdtZW50c1sxXTtcbiAgICAgICAgaWYgKGNvbnRleHQucmVtb3Rlc1tiYXNlXSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucmVtb3Rlc1tiYXNlXS5nZXRSZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5yZW1vdGVzW2Jhc2VdLmdldFJlZigkcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwid2FybmluZzogdW5jb21waWxlZCByZW1vdGUgLSBjb250ZXh0IG1heSBiZSB3cm9uZ1wiLCBiYXNlKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWYoY29udGV4dCwgY29udGV4dC5yZW1vdGVzW2Jhc2VdLCAkcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5pZHNbYmFzZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWYoY29udGV4dCwgZ2V0KHJvb3RTY2hlbWEsIGNvbnRleHQuaWRzW2Jhc2VdKSwgJHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NoZW1hID0gZ2V0KHJvb3RTY2hlbWEsIGNvbnRleHQuaWRzWyRyZWZdIHx8ICRyZWYpO1xuICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlZihjb250ZXh0LCByb290U2NoZW1hLCBzY2hlbWEuJHJlZik7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG4iLCIvKiBlc2xpbnQgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmU6IFtcImVycm9yXCIsIHsgXCJtYXhcIjogMiB9XSAqL1xuaW1wb3J0IHsgZWFjaFNjaGVtYSB9IGZyb20gXCIuLi9lYWNoU2NoZW1hXCI7XG5pbXBvcnQgam9pblNjb3BlIGZyb20gXCIuL2pvaW5TY29wZVwiO1xuaW1wb3J0IGdldFJlZiBmcm9tIFwiLi9nZXRSZWZcIjtcbmltcG9ydCB7IGdldCB9IGZyb20gXCJAc2Fnb2xkL2pzb24tcG9pbnRlclwiO1xuY29uc3QgQ09NUElMRUQgPSBcIl9fY29tcGlsZWRcIjtcbmNvbnN0IENPTVBJTEVEX1JFRiA9IFwiX19yZWZcIjtcbmNvbnN0IEdFVF9SRUYgPSBcImdldFJlZlwiO1xuY29uc3QgR0VUX1JPT1QgPSBcImdldFJvb3RcIjtcbmNvbnN0IHN1ZmZpeGVzID0gLygjfFxcLykrJC9nO1xuLyoqXG4gKiBjb21waWxlcyB0aGUgaW5wdXQgcm9vdCBzY2hlbWEgZm9yIGAkcmVmYCByZXNvbHV0aW9uIGFuZCByZXR1cm5zIGl0IGFnYWluXG4gKiBAYXR0ZW50aW9uIHRoaXMgbW9kaWZpZXMgaW5wdXQgc2NoZW1hIGJ1dCBtYWludGFpbnMgZGF0YS1zdHJ1Y3R1cmUgYW5kIHRodXMgcmV0dXJuc1xuICogdGhlIHNhbWUgb2JqZWN0IHdpdGggSlNPTi5zdHJpbmdpZnlcbiAqXG4gKiBmb3IgYSBjb21waWxlZCBqc29uLXNjaGVtYSB5b3UgY2FuIGNhbGwgZ2V0UmVmIG9uIGFueSBjb250YWluZWQgc2NoZW1hIChsb2NhdGlvbiBvZiB0eXBlKS5cbiAqIHRoaXMgcmVzb2x2ZXMgYSAkcmVmIHRhcmdldCB0byBhIHZhbGlkIHNjaGVtYSAoZm9yIGEgdmFsaWQgJHJlZilcbiAqXG4gKiBAcGFyYW0gZHJhZnRcbiAqIEBwYXJhbSBzY2hlbWFUb0NvbXBpbGUgLSBqc29uLXNjaGVtYSB0byBjb21waWxlXG4gKiBAcGFyYW0gW3Jvb3RTY2hlbWFdIC0gY29tcGlsZWQgcm9vdCBqc29uLXNjaGVtYSB0byB1c2UgZm9yIGRlZmluaXRpb25zIHJlc29sdXRpb25cbiAqIEBwYXJhbSBbZm9yY2VdID0gZmFsc2UgLSBmb3JjZSBjb21waWxlIGpzb24tc2NoZW1hXG4gKiBAcmV0dXJuIGNvbXBpbGVkIGlucHV0IGpzb24tc2NoZW1hXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoZHJhZnQsIHNjaGVtYVRvQ29tcGlsZSwgcm9vdFNjaGVtYSA9IHNjaGVtYVRvQ29tcGlsZSwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICghc2NoZW1hVG9Db21waWxlIHx8IHNjaGVtYVRvQ29tcGlsZVtDT01QSUxFRF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hVG9Db21waWxlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0geyBpZHM6IHt9LCByZW1vdGVzOiBkcmFmdC5yZW1vdGVzIH07XG4gICAgY29uc3Qgcm9vdFNjaGVtYUFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc2NoZW1hVG9Db21waWxlKTtcbiAgICBjb25zdCBjb21waWxlZFNjaGVtYSA9IEpTT04ucGFyc2Uocm9vdFNjaGVtYUFzU3RyaW5nKTtcbiAgICAvLyBmbGFnIHRoaXMgc2NoZW1hIGFzIGNvbXBpbGVkXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBpbGVkU2NoZW1hLCBDT01QSUxFRCwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IHRydWUgfSk7XG4gICAgLy8gYWRkIGdldFJlZi1oZWxwZXIgdG8gdGhpcyBvYmplY3RcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcGlsZWRTY2hlbWEsIEdFVF9SRUYsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBnZXRSZWYuYmluZChudWxsLCBjb250ZXh0LCBjb21waWxlZFNjaGVtYSlcbiAgICB9KTtcbiAgICAvLyBiYWlsIGVhcmx5LCB3aGVuIG5vICRyZWZzIGFyZSBkZWZpbmVkXG4gICAgaWYgKGZvcmNlID09PSBmYWxzZSAmJiByb290U2NoZW1hQXNTdHJpbmcuaW5jbHVkZXMoXCIkcmVmXCIpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gY29tcGlsZWRTY2hlbWE7XG4gICAgfVxuICAgIC8vIGNvbXBpbGUgdGhpcyBzY2hlbWEgdW5kZXIgcm9vdFNjaGVtYSwgbWFraW5nIGRlZmluaXRpb25zIGF2YWlsYWJsZSB0byAkcmVmLXJlc29sdXRpb25cbiAgICBpZiAoc2NoZW1hVG9Db21waWxlICE9PSByb290U2NoZW1hKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21waWxlZFNjaGVtYSwgXCJkZWZpbml0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCByb290U2NoZW1hLmRlZmluaXRpb25zLCByb290U2NoZW1hLiRkZWZzLCBzY2hlbWFUb0NvbXBpbGUuZGVmaW5pdGlvbnMsIHNjaGVtYVRvQ29tcGlsZS4kZGVmcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IHt9O1xuICAgIGNvbnN0IGdldFJvb3QgPSAoKSA9PiBjb21waWxlZFNjaGVtYTtcbiAgICBlYWNoU2NoZW1hKGNvbXBpbGVkU2NoZW1hLCAoc2NoZW1hLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNjaGVtYS5pZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHNjaGVtYSBiZWluZyBtZXJnZWQgb24gcm9vdCBvYmplY3QsIHdlIGNhbm5vdCBvdmVycmlkZVxuICAgICAgICAgICAgLy8gcGFyZW50cyBsb2NhdGlvbnMsIGJ1dCBtdXN0IHJldXNlIGl0XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmlkLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmIC8oYWxsT2Z8YW55T2Z8b25lT2YpXFwvXFxkKyQvLnRlc3QocG9pbnRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQb2ludGVyID0gcG9pbnRlci5yZXBsYWNlKC9cXC8oYWxsT2Z8YW55T2Z8b25lT2YpXFwvXFxkKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSBnZXQoY29tcGlsZWRTY2hlbWEsIHBhcmVudFBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIHNjaGVtYS5pZCA9IChfYSA9IHBhcmVudFNjaGVtYS5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2NoZW1hLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5pZHNbc2NoZW1hLmlkLnJlcGxhY2Uoc3VmZml4ZXMsIFwiXCIpXSA9IHBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVpbGQgdXAgc2NvcGVzIGFuZCBhZGQgdGhlbSB0byAkcmVmLXJlc29sdXRpb24gbWFwXG4gICAgICAgIHBvaW50ZXIgPSBgIyR7cG9pbnRlcn1gLnJlcGxhY2UoLyMjKy8sIFwiI1wiKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludGVyID0gcG9pbnRlci5yZXBsYWNlKC9cXC9bXi9dKyQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgcGFyZW50UG9pbnRlciA9IHBvaW50ZXIucmVwbGFjZSgvXFwvW14vXStcXC9bXi9dKyQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTY29wZSA9IHNjb3Blc1twcmV2aW91c1BvaW50ZXJdIHx8IHNjb3Blc1twYXJlbnRQb2ludGVyXTtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBqb2luU2NvcGUocHJldmlvdXNTY29wZSwgc2NoZW1hLmlkKTtcbiAgICAgICAgc2NvcGVzW3BvaW50ZXJdID0gc2NvcGU7XG4gICAgICAgIGlmIChjb250ZXh0Lmlkc1tzY29wZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC5pZHNbc2NvcGVdID0gcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLiRyZWYgJiYgIXNjaGVtYVtDT01QSUxFRF9SRUZdKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCBDT01QSUxFRF9SRUYsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogam9pblNjb3BlKHNjb3BlLCBzY2hlbWEuJHJlZilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQHRvZG8gY3VycmVudGx5IG5vdCB1c2VkOlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYSwgR0VUX1JPT1QsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBnZXRSb290IH0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJjb21waWxlZCByZWZcIiwgc2NvcGUsIHNjaGVtYS4kcmVmLCBcIj0+XCIsIGpvaW5TY29wZShzY29wZSwgc2NoZW1hLiRyZWYpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGNvbnRleHQuaWRzLCBudWxsLCAyKSk7XG4gICAgcmV0dXJuIGNvbXBpbGVkU2NoZW1hO1xufVxuIiwiaW1wb3J0IGNvbXBpbGUgZnJvbSBcIi4vY29tcGlsZVwiO1xuZXhwb3J0IGRlZmF1bHQgY29tcGlsZTtcbiIsImltcG9ydCBnZXRUeXBlT2YgZnJvbSBcIi4vZ2V0VHlwZU9mXCI7XG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZGF0YSwgcmV0cmlldmluZyBpdHMgc2NoZW1hXG4gKlxuICogQHBhcmFtIGRyYWZ0IC0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gZGF0YSAtIHRoZSBkYXRhIHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSBjYWxsYmFjayAtIHdpbGwgYmUgY2FsbGVkIHdpdGggKHNjaGVtYSwgZGF0YSwgcG9pbnRlcikgb24gZWFjaCBpdGVtXG4gKiBAcGFyYW0gW3NjaGVtYV0gLSB0aGUgc2NoZW1hIG1hdGNoaW5nIHRoZSBkYXRhLiBEZWZhdWx0cyB0byByb290U2NoZW1hXG4gKiBAcGFyYW0gW3BvaW50ZXJdIC0gcG9pbnRlciB0byBjdXJyZW50IGRhdGEuIERlZmF1bHQgdG8gcm9vdFBvaW50ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2goZHJhZnQsIGRhdGEsIGNhbGxiYWNrLCBzY2hlbWEgPSBkcmFmdC5yb290U2NoZW1hLCBwb2ludGVyID0gXCIjXCIpIHtcbiAgICBzY2hlbWEgPSBkcmFmdC5yZXNvbHZlUmVmKHNjaGVtYSk7XG4gICAgY2FsbGJhY2soc2NoZW1hLCBkYXRhLCBwb2ludGVyKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldFR5cGVPZihkYXRhKTtcbiAgICBpZiAoZGF0YVR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0U2NoZW1hID0gZHJhZnQuc3RlcChrZXksIHNjaGVtYSwgZGF0YSwgcG9pbnRlcik7IC8vIG5vdCBzYXZlXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gZGF0YVtrZXldOyAvLyBzYXZlXG4gICAgICAgICAgICBkcmFmdC5lYWNoKG5leHQsIGNhbGxiYWNrLCBuZXh0U2NoZW1hLCBgJHtwb2ludGVyfS8ke2tleX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKChuZXh0LCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTY2hlbWEgPSBkcmFmdC5zdGVwKGtleSwgc2NoZW1hLCBkYXRhLCBwb2ludGVyKTtcbiAgICAgICAgICAgIGRyYWZ0LmVhY2gobmV4dCwgY2FsbGJhY2ssIG5leHRTY2hlbWEsIGAke3BvaW50ZXJ9LyR7a2V5fWApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAwICovXG5pbXBvcnQgeyBjcmVhdGVDdXN0b21FcnJvciB9IGZyb20gXCIuLi91dGlscy9jcmVhdGVDdXN0b21FcnJvclwiO1xuY29uc3QgZXJyb3JzID0ge1xuICAgIGFkZGl0aW9uYWxJdGVtc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkFkZGl0aW9uYWxJdGVtc0Vycm9yXCIpLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvclwiKSxcbiAgICBhbnlPZkVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkFueU9mRXJyb3JcIiksXG4gICAgYWxsT2ZFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJBbGxPZkVycm9yXCIpLFxuICAgIGNvbnN0RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQ29uc3RFcnJvclwiKSxcbiAgICBjb250YWluc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkNvbnRhaW5zRXJyb3JcIiksXG4gICAgY29udGFpbnNBcnJheUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkNvbnRhaW5zQXJyYXlFcnJvclwiKSxcbiAgICBjb250YWluc0FueUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkNvbnRhaW5zQW55RXJyb3JcIiksXG4gICAgZW51bUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkVudW1FcnJvclwiKSxcbiAgICBmb3JiaWRkZW5Qcm9wZXJ0eUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcmJpZGRlblByb3BlcnR5RXJyb3JcIiksXG4gICAgZm9ybWF0VVJMRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0VVJMRXJyb3JcIiksXG4gICAgZm9ybWF0VVJJRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0VVJJRXJyb3JcIiksXG4gICAgZm9ybWF0VVJJUmVmZXJlbmNlRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0VVJJUmVmZXJlbmNlRXJyb3JcIiksXG4gICAgZm9ybWF0VVJJVGVtcGxhdGVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRVUklUZW1wbGF0ZUVycm9yXCIpLFxuICAgIGZvcm1hdERhdGVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXREYXRlRXJyb3JcIiksXG4gICAgZm9ybWF0RGF0ZVRpbWVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXREYXRlVGltZUVycm9yXCIpLFxuICAgIGZvcm1hdEVtYWlsRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0RW1haWxFcnJvclwiKSxcbiAgICBmb3JtYXRIb3N0bmFtZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdEhvc3RuYW1lRXJyb3JcIiksXG4gICAgZm9ybWF0SVBWNEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdElQVjRFcnJvclwiKSxcbiAgICBmb3JtYXRJUFY0TGVhZGluZ1plcm9FcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRJUFY0TGVhZGluZ1plcm9FcnJvclwiKSxcbiAgICBmb3JtYXRJUFY2RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0SVBWNkVycm9yXCIpLFxuICAgIGZvcm1hdElQVjZMZWFkaW5nWmVyb0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdElQVjZMZWFkaW5nWmVyb0Vycm9yXCIpLFxuICAgIGZvcm1hdEpzb25Qb2ludGVyRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0SnNvblBvaW50ZXJFcnJvclwiKSxcbiAgICBmb3JtYXRSZWdFeEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdFJlZ0V4RXJyb3JcIiksXG4gICAgZm9ybWF0VGltZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdFRpbWVFcnJvclwiKSxcbiAgICBpbnZhbGlkU2NoZW1hRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiSW52YWxpZFNjaGVtYUVycm9yXCIpLFxuICAgIGludmFsaWREYXRhRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiSW52YWxpZERhdGFFcnJvclwiKSxcbiAgICBpbnZhbGlkVHlwZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkludmFsaWRUeXBlRXJyb3JcIiksXG4gICAgaW52YWxpZFByb3BlcnR5TmFtZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkludmFsaWRQcm9wZXJ0eU5hbWVFcnJvclwiKSxcbiAgICBtYXhpbXVtRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWF4aW11bUVycm9yXCIpLFxuICAgIG1heEl0ZW1zRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWF4SXRlbXNFcnJvclwiKSxcbiAgICBtYXhMZW5ndGhFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNYXhMZW5ndGhFcnJvclwiKSxcbiAgICBtYXhQcm9wZXJ0aWVzRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWF4UHJvcGVydGllc0Vycm9yXCIpLFxuICAgIG1pbmltdW1FcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNaW5pbXVtRXJyb3JcIiksXG4gICAgbWluSXRlbXNFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNaW5JdGVtc0Vycm9yXCIpLFxuICAgIG1pbkl0ZW1zT25lRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWluSXRlbXNPbmVFcnJvclwiKSxcbiAgICBtaW5MZW5ndGhFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNaW5MZW5ndGhFcnJvclwiKSxcbiAgICBtaW5MZW5ndGhPbmVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNaW5MZW5ndGhPbmVFcnJvclwiKSxcbiAgICBtaW5Qcm9wZXJ0aWVzRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWluUHJvcGVydGllc0Vycm9yXCIpLFxuICAgIG1pc3NpbmdEZXBlbmRlbmN5RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWlzc2luZ0RlcGVuZGVuY3lFcnJvclwiKSxcbiAgICBtaXNzaW5nT25lT2ZQcm9wZXJ0eUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1pc3NpbmdPbmVPZlByb3BlcnR5RXJyb3JcIiksXG4gICAgbXVsdGlwbGVPZkVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk11bHRpcGxlT2ZFcnJvclwiKSxcbiAgICBtdWx0aXBsZU9uZU9mRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTXVsdGlwbGVPbmVPZkVycm9yXCIpLFxuICAgIG5vQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJOb0FkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3JcIiksXG4gICAgbm90RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTm90RXJyb3JcIiksXG4gICAgb25lT2ZFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJPbmVPZkVycm9yXCIpLFxuICAgIG9uZU9mUHJvcGVydHlFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJPbmVPZlByb3BlcnR5RXJyb3JcIiksXG4gICAgcGF0dGVybkVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlBhdHRlcm5FcnJvclwiKSxcbiAgICBwYXR0ZXJuUHJvcGVydGllc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlBhdHRlcm5Qcm9wZXJ0aWVzRXJyb3JcIiksXG4gICAgcmVxdWlyZWRQcm9wZXJ0eUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlJlcXVpcmVkUHJvcGVydHlFcnJvclwiKSxcbiAgICBzY2hlbWFXYXJuaW5nOiBjcmVhdGVDdXN0b21FcnJvcihcIlNjaGVtYVdhcm5pbmdcIiksXG4gICAgdHlwZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlR5cGVFcnJvclwiKSxcbiAgICB1bmRlZmluZWRWYWx1ZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlVuZGVmaW5lZFZhbHVlRXJyb3JcIiksXG4gICAgdW5pcXVlSXRlbXNFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJVbmlxdWVJdGVtc0Vycm9yXCIpLFxuICAgIHVua25vd25Qcm9wZXJ0eUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlVua25vd25Qcm9wZXJ0eUVycm9yXCIpLFxuICAgIHZhbHVlTm90RW1wdHlFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJWYWx1ZU5vdEVtcHR5RXJyb3JcIilcbn07XG5leHBvcnQgZGVmYXVsdCBlcnJvcnM7XG4iLCJpbXBvcnQgdmFsaWRVcmwgZnJvbSBcInZhbGlkLXVybFwiO1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VJZG5FbWFpbCB9IGZyb20gXCJzbXRwLWFkZHJlc3MtcGFyc2VyXCI7XG4vLyByZWZlcmVuY2VkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2Z3b3JrZXIvY2Z3b3JrZXIvYmxvYi9tYWluL3BhY2thZ2VzL2pzb24tc2NoZW1hL3NyYy9mb3JtYXQudHNcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21hcmNlbG90bWVsby9iNjdmNThhMDhiZWU2YzI0NjhmOFxuY29uc3QgaXNWYWxpZERhdGVUaW1lID0gbmV3IFJlZ0V4cChcIl4oWzAtOV0rKS0oMFsxLTldfDFbMDEyXSktKDBbMS05XXxbMTJdWzAtOV18M1swMV0pW1R0XShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKFxcXFwuWzAtOV0rKT8oKFtael0pfChbXFxcXCt8XFxcXC1dKFswMV1bMC05XXwyWzAtM10pOlswLTVdWzAtOV0pKSRcIik7XG5jb25zdCBpc1ZhbGlkSVBWNCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC87XG5jb25zdCBpc1ZhbGlkSVBWNiA9IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pO1xuY29uc3QgaXNWYWxpZEhvc3RuYW1lID0gL14oPz0uezEsMjU1fSQpWzAtOUEtWmEtel0oPzooPzpbMC05QS1aYS16XXwtKXswLDYxfVswLTlBLVphLXpdKT8oPzpcXC5bMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPykqXFwuPyQvO1xuY29uc3QgbWF0Y2hEYXRlID0gL14oXFxkXFxkXFxkXFxkKS0oXFxkXFxkKS0oXFxkXFxkKSQvO1xuLy8gY29uc3QgbWF0Y2hUaW1lID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuY29uc3QgbWF0Y2hUaW1lID0gL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2k7XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuY29uc3QgaXNWYWxpZEpzb25Qb2ludGVyID0gL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLztcbmNvbnN0IGlzVmFsaWRSZWxhdGl2ZUpzb25Qb2ludGVyID0gL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvO1xuY29uc3QgaXNWYWxpZFVSSVJlZiA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopPyg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG4vLyB1cmktdGVtcGxhdGU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NTcwXG5jb25zdCBpc1ZhbGlkVVJJVGVtcGxhdGUgPSAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaTtcbi8vIERlZmF1bHQgSnNvbi1TY2hlbWEgZm9ybWF0czogZGF0ZS10aW1lLCBlbWFpbCwgaG9zdG5hbWUsIGlwdjQsIGlwdjYsIHVyaSwgdXJpcmVmXG5jb25zdCBmb3JtYXRWYWxpZGF0b3JzID0ge1xuICAgIGRhdGU6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jZndvcmtlci9jZndvcmtlci9ibG9iL21haW4vcGFja2FnZXMvanNvbi1zY2hlbWEvc3JjL2Zvcm1hdC50c1xuICAgICAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChtYXRjaERhdGUpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RGF0ZVRpbWVFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgICAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBkYXkgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgICAgICBjb25zdCBpc0xlYXBZZWFyID0geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gICAgICAgIGlmIChtb250aCA+PSAxICYmXG4gICAgICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICAgICAgZGF5ID49IDEgJiZcbiAgICAgICAgICAgIGRheSA8PSAobW9udGggPT0gMiAmJiBpc0xlYXBZZWFyID8gMjkgOiBEQVlTW21vbnRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXREYXRlRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgXCJkYXRlLXRpbWVcIjogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiIHx8IGlzVmFsaWREYXRlVGltZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKHZhbHVlKS50b1N0cmluZygpID09PSBcIkludmFsaWQgRGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXREYXRlVGltZUVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXREYXRlVGltZUVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9LFxuICAgIGVtYWlsOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9FeG9kdXNNb3ZlbWVudC9zY2hlbWFzYWZlL2Jsb2IvbWFzdGVyL3NyYy9mb3JtYXRzLmpzXG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRFbWFpbEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbmFtZSwgaG9zdCwgLi4ucmVzdF0gPSB2YWx1ZS5zcGxpdChcIkBcIik7XG4gICAgICAgIGlmICghbmFtZSB8fCAhaG9zdCB8fCByZXN0Lmxlbmd0aCAhPT0gMCB8fCBuYW1lLmxlbmd0aCA+IDY0IHx8IGhvc3QubGVuZ3RoID4gMjUzKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdEVtYWlsRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lWzBdID09PSBcIi5cIiB8fCBuYW1lLmVuZHNXaXRoKFwiLlwiKSB8fCBuYW1lLmluY2x1ZGVzKFwiLi5cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RW1haWxFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXlthLXowLTkuLV0rJC9pLnRlc3QoaG9zdCkgfHwgIS9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXSskL2kudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRFbWFpbEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhvc3Quc3BsaXQoXCIuXCIpLmV2ZXJ5KChwYXJ0KSA9PiAvXlthLXowLTldKFthLXowLTktXXswLDYxfVthLXowLTldKT8kL2kudGVzdChwYXJ0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RW1haWxFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBkcmFmdCA3XG4gICAgICogW1JGQzY1MzFdIGh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNSRkM2NTMxXG4gICAgICovXG4gICAgXCJpZG4tZW1haWxcIjogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlSWRuRW1haWwodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRFbWFpbEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG9zdG5hbWU6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCBpc1ZhbGlkSG9zdG5hbWUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRIb3N0bmFtZUVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9LFxuICAgIGlwdjQ6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVswXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIC8vIGxlYWRpbmcgemVyb2VzIHNob3VsZCBiZSByZWplY3RlZCwgYXMgdGhleSBhcmUgdHJlYXRlZCBhcyBvY3RhbHNcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0SVBWNExlYWRpbmdaZXJvRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMTUgJiYgaXNWYWxpZElQVjQudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRJUFY0RXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgaXB2NjogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWzBdID09PSBcIjBcIikge1xuICAgICAgICAgICAgLy8gbGVhZGluZyB6ZXJvZXMgc2hvdWxkIGJlIHJlamVjdGVkLCBhcyB0aGV5IGFyZSB0cmVhdGVkIGFzIG9jdGFsc1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRJUFY2TGVhZGluZ1plcm9FcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSA0NSAmJiBpc1ZhbGlkSVBWNi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdElQVjZFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICBcImpzb24tcG9pbnRlclwiOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZEpzb25Qb2ludGVyLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0SnNvblBvaW50ZXJFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZFJlbGF0aXZlSnNvblBvaW50ZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRKc29uUG9pbnRlckVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9LFxuICAgIHJlZ2V4OiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAvXFxcXFokLy50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRSZWdFeEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2NyB0ZXN0cywgaWdub3JlIG5vbi1yZWdleCB2YWx1ZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRSZWdFeEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9LFxuICAgIC8vIGhoOm1tOnNzLnNUWkRcbiAgICAvLyBodHRwczovL29waXMuaW8vanNvbi1zY2hlbWEvMi54L2Zvcm1hdHMuaHRtbFxuICAgIC8vIHJlZ2V4IGh0dHBzOi8vd3d3Lm9yZWlsbHkuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODE0NDkzMjc0NTMvY2gwNHMwNy5odG1sXG4gICAgdGltZTogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nmd29ya2VyL2Nmd29ya2VyL2Jsb2IvbWFpbi9wYWNrYWdlcy9qc29uLXNjaGVtYS9zcmMvZm9ybWF0LnRzXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChtYXRjaFRpbWUpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcyA/IHVuZGVmaW5lZCA6IGRyYWZ0LmVycm9ycy5mb3JtYXREYXRlVGltZUVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgLy8gaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gZXJyb3JzLmZvcm1hdERhdGVUaW1lRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGNvbnN0IGhvdXIgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAgLy8gY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgICAgIC8vIGNvbnN0IHNlY29uZCA9ICttYXRjaGVzWzNdO1xuICAgICAgICAvLyBjb25zdCB0aW1lWm9uZSA9ICEhbWF0Y2hlc1s1XTtcbiAgICAgICAgLy8gaWYgKFxuICAgICAgICAvLyAgICAgKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIC8vICAgICAgICAgKGhvdXIgPT0gMjMgJiYgbWludXRlID09IDU5ICYmIHNlY29uZCA9PSA2MCkpICYmXG4gICAgICAgIC8vICAgICB0aW1lWm9uZVxuICAgICAgICAvLyApIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcmV0dXJuIGVycm9ycy5mb3JtYXRUaW1lRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgdXJpOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRVcmwuaXNVcmkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0VVJJRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkVVJJUmVmLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0VVJJUmVmZXJlbmNlRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgXCJ1cmktdGVtcGxhdGVcIjogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWRVUklUZW1wbGF0ZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdFVSSVRlbXBsYXRlRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgdXJsOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiIHx8IHZhbGlkVXJsLmlzV2ViVXJpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdFVSTEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgZm9ybWF0VmFsaWRhdG9ycztcbiIsImltcG9ydCBncCBmcm9tIFwiQHNhZ29sZC9qc29uLXBvaW50ZXJcIjtcbmltcG9ydCB7IGlzSnNvbkVycm9yIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG4vKipcbiAqIFJldHVybnMgdGhlIGpzb24tc2NoZW1hIG9mIGEgZGF0YS1qc29uLXBvaW50ZXIuXG4gKlxuICogVG8gcmVzb2x2ZSBkeW5hbWljIHNjaGVtYSB3aGVyZSB0aGUgdHlwZSBvZiBqc29uLXNjaGVtYSBpcyBldmFsdWF0ZWQgYnlcbiAqIGl0cyB2YWx1ZSwgYSBkYXRhIG9iamVjdCBoYXMgdG8gYmUgcGFzc2VkIGluIG9wdGlvbnMuXG4gKlxuICogUGVyIGRlZmF1bHQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgdmFsaWQgcHJvcGVydGllcyB0aGF0XG4gKiBkbyBub3QgaGF2ZSBhIGRlZmluZWQgc2NoZW1hLiBVc2UgdGhlIG9wdGlvbiBgd2l0aFNjaGVtYVdhcm5pbmc6IHRydWVgIHRvXG4gKiByZWNlaXZlIGFuIGVycm9yIHdpdGggYGNvZGU6IHNjaGVtYS13YXJuaW5nYCBjb250YWluaW5nIHRoZSBsb2NhdGlvbiBvZiBpdHNcbiAqIGxhc3QgZXZhbHVhdGVkIGpzb24tc2NoZW1hLlxuICpcbiAqIE5vdGVzXG4gKiAgICAgIC0gdXNlcyBkcmFmdC5zdGVwIHRvIHdhbGsgdGhyb3VnaCBkYXRhIGFuZCBzY2hlbWFcbiAqXG4gKiBAcGFyYW0gZHJhZnRcbiAqIEBwYXJhbSBwb2ludGVyIC0ganNvbiBwb2ludGVyIGluIGRhdGEgdG8gZ2V0IHRoZSBqc29uIHNjaGVtYSBmb3JcbiAqIEBwYXJhbSBbb3B0aW9ucy5kYXRhXSAtIHRoZSBkYXRhIG9iamVjdCwgd2hpY2ggaW5jbHVkZXMgdGhlIGpzb24gcG9pbnRlcnMgdmFsdWUuIFRoaXMgaXMgb3B0aW9uYWwsIGFzXG4gKiAgICBsb25nIGFzIG5vIG9uZU9mLCBhbnlPZiwgZXRjIHN0YXRlbWVudCBpcyBwYXJ0IG9mIHRoZSBwb2ludGVycyBzY2hlbWFcbiAqIEBwYXJhbSBbb3B0aW9ucy5zY2hlbWFdIC0gdGhlIGpzb24gc2NoZW1hIHRvIGl0ZXJhdGUuIERlZmF1bHRzIHRvIGRyYWZ0LnJvb3RTY2hlbWFcbiAqIEBwYXJhbSBbb3B0aW9ucy53aXRoU2NoZW1hV2FybmluZ10gLSBpZiB0cnVlIHJldHVybnMgYW4gZXJyb3IgaW5zdGVhZCBvZiBgdW5kZWZpbmVkYCBmb3IgdmFsaWQgcHJvcGVydGllcyBtaXNzaW5nIGEgc2NoZW1hIGRlZmluaXRpb25cbiAqIEByZXR1cm4gcmVzb2x2ZWQganNvbi1zY2hlbWEgb2JqZWN0IG9mIHJlcXVlc3RlZCBqc29uLXBvaW50ZXIgbG9jYXRpb24gb3IganNvbi1lcnJvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY2hlbWEoZHJhZnQsIG9wdGlvbnMgPSBlbXB0eU9iamVjdCkge1xuICAgIGNvbnN0IHsgcG9pbnRlciA9IFwiI1wiLCBkYXRhLCBzY2hlbWEgPSBkcmFmdC5yb290U2NoZW1hLCB3aXRoU2NoZW1hV2FybmluZyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHBhdGggPSBncC5zcGxpdChwb2ludGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBfZ2V0U2NoZW1hKGRyYWZ0LCBkcmFmdC5yZXNvbHZlUmVmKHNjaGVtYSksIHBhdGgsIFwiI1wiLCBkYXRhKTtcbiAgICBpZiAoIXdpdGhTY2hlbWFXYXJuaW5nICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuY29kZSkgPT09IFwic2NoZW1hLXdhcm5pbmdcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2dldFNjaGVtYShkcmFmdCwgc2NoZW1hLCBwYXRoLCBwb2ludGVyLCBkYXRhID0gZW1wdHlPYmplY3QpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcGF0aC5zaGlmdCgpOyAvLyBzdGVwIGtleVxuICAgIHNjaGVtYSA9IGRyYWZ0LnN0ZXAoa2V5LCBzY2hlbWEsIGRhdGEsIHBvaW50ZXIpOyAvLyBzdGVwIHNjaGVtYVxuICAgIGlmIChpc0pzb25FcnJvcihzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZGF0YVxuICAgIGRhdGEgPSBkYXRhW2tleV07IC8vIHN0ZXAgZGF0YVxuICAgIHJldHVybiBfZ2V0U2NoZW1hKGRyYWZ0LCBzY2hlbWEsIHBhdGgsIGAke3BvaW50ZXJ9LyR7a2V5fWAsIGRhdGEpO1xufVxuIiwiaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi4vZ2V0VHlwZU9mXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eSh2KSB7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGVPZih2KTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGVzdGVkIGFzIGFycmF5IC0gY291bGQgdXNlIHRzIHR5cGUgZ3VhcmRcbiAgICAgICAgICAgIHJldHVybiAodiA9PT0gbnVsbCB8fCB2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2Lmxlbmd0aCkgPT09IDA7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModikubGVuZ3RoID09PSAwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludCBxdW90ZS1wcm9wczogMCwgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmU6IFtcImVycm9yXCIsIHsgXCJtYXhcIjogMiB9XSAqL1xuaW1wb3J0IHsgcmVzb2x2ZU9uZU9mRnV6enkgfSBmcm9tIFwiLi9mZWF0dXJlcy9vbmVPZlwiO1xuaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi9nZXRUeXBlT2ZcIjtcbmltcG9ydCBtZXJnZSBmcm9tIFwiLi91dGlscy9tZXJnZVwiO1xuaW1wb3J0IGNvcHkgZnJvbSBcIi4vdXRpbHMvY29weVwiO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gXCIuL2NvbmZpZy9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gXCIuL3V0aWxzL2lzRW1wdHlcIjtcbmltcG9ydCB7IHJlc29sdmVJZlNjaGVtYSB9IGZyb20gXCIuL2ZlYXR1cmVzL2lmXCI7XG5pbXBvcnQgeyBtZXJnZUFsbE9mU2NoZW1hIH0gZnJvbSBcIi4vZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCB7IHJlc29sdmVEZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi9mZWF0dXJlcy9kZXBlbmRlbmNpZXNcIjtcbmltcG9ydCB7IG1lcmdlU2NoZW1hIH0gZnJvbSBcIi4vbWVyZ2VTY2hlbWFcIjtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gc2V0dGluZ3MudGVtcGxhdGVEZWZhdWx0T3B0aW9ucztcbmxldCBjYWNoZTtcbmZ1bmN0aW9uIHNob3VsZFJlc29sdmVSZWYoc2NoZW1hLCBwb2ludGVyKSB7XG4gICAgY29uc3QgeyAkcmVmIH0gPSBzY2hlbWE7XG4gICAgaWYgKCRyZWYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjYWNoZVtwb2ludGVyXSA9PSBudWxsIHx8IGNhY2hlW3BvaW50ZXJdWyRyZWZdID09IG51bGwgPyAwIDogY2FjaGVbcG9pbnRlcl1bJHJlZl07XG4gICAgcmV0dXJuIHZhbHVlIDwgc2V0dGluZ3MuR0VUX1RFTVBMQVRFX1JFQ1VSU0lPTl9MSU1JVDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWYoZHJhZnQsIHNjaGVtYSwgcG9pbnRlcikge1xuICAgIGNvbnN0IHsgJHJlZiB9ID0gc2NoZW1hO1xuICAgIGlmICgkcmVmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgLy8gQHRvZG8gcG9pbnRlciArIHJlZiBpcyByZWR1bmRhbnQ/XG4gICAgY2FjaGVbcG9pbnRlcl0gPSBjYWNoZVtwb2ludGVyXSB8fCB7fTtcbiAgICBjYWNoZVtwb2ludGVyXVskcmVmXSA9IGNhY2hlW3BvaW50ZXJdWyRyZWZdIHx8IDA7XG4gICAgY2FjaGVbcG9pbnRlcl1bJHJlZl0gKz0gMTtcbiAgICByZXR1cm4gZHJhZnQucmVzb2x2ZVJlZihzY2hlbWEpO1xufVxuZnVuY3Rpb24gY29udmVydFZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJlc29sdmVzICRyZWYsIGFsbE9mIGFuZCBhbnlPZiBzY2hlbWEtb3B0aW9ucywgcmV0dXJuaW5nIGEgY29tYmluZWQganNvbi1zY2hlbWEuXG4gKiBBbHNvIHJldHVybnMgYSBwb2ludGVyLXByb3BlcnR5IG9uIHNjaGVtYSwgdGhhdCBtdXN0IGJlIHVzZWQgYXMgY3VycmVudCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBkcmFmdFxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJuIHJlc29sdmVkIGpzb24tc2NoZW1hIG9yIGlucHV0LXNjaGVtYVxuICovXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZVNjaGVtYShkcmFmdCwgc2NoZW1hLCBkYXRhLCBwb2ludGVyKSB7XG4gICAgLy8gaW52YWxpZCBzY2hlbWFcbiAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBwb2ludGVyIH0sIHNjaGVtYSk7XG4gICAgfVxuICAgIC8vIHJldHVybiBpZiByZWFjaGVkIHJlY3Vyc2lvbiBsaW1pdFxuICAgIGlmIChzaG91bGRSZXNvbHZlUmVmKHNjaGVtYSwgcG9pbnRlcikgPT09IGZhbHNlICYmIGRhdGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgJHJlZiBhbmQgY29weSBzY2hlbWFcbiAgICBsZXQgdGVtcGxhdGVTY2hlbWEgPSBjb3B5KHJlc29sdmVSZWYoZHJhZnQsIHNjaGVtYSwgcG9pbnRlcikpO1xuICAgIC8vIEBmZWF0dXJlIGFueU9mXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSAmJiBzY2hlbWEuYW55T2YubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB0ZXN0IGlmIHdlIG1heSByZXNvbHZlXG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlUmVmKHNjaGVtYS5hbnlPZlswXSwgYCR7cG9pbnRlcn0vYW55T2YvMGApKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFueU9mID0gcmVzb2x2ZVJlZihkcmFmdCwgc2NoZW1hLmFueU9mWzBdLCBgJHtwb2ludGVyfS9hbnlPZi8wYCk7XG4gICAgICAgICAgICB0ZW1wbGF0ZVNjaGVtYSA9IG1lcmdlKHRlbXBsYXRlU2NoZW1hLCByZXNvbHZlZEFueU9mKTtcbiAgICAgICAgICAgIC8vIGFkZCBwb2ludGVyIHJldHVybi12YWx1ZSwgaWYgYW55XG4gICAgICAgICAgICB0ZW1wbGF0ZVNjaGVtYS5wb2ludGVyID0gc2NoZW1hLmFueU9mWzBdLiRyZWYgfHwgdGVtcGxhdGVTY2hlbWEucG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGVtcGxhdGVTY2hlbWEuYW55T2Y7XG4gICAgfVxuICAgIC8vIEBmZWF0dXJlIGFsbE9mXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICBjb25zdCBtYXlSZXNvbHZlID0gc2NoZW1hLmFsbE9mXG4gICAgICAgICAgICAubWFwKChhbGxPZiwgaW5kZXgpID0+IHNob3VsZFJlc29sdmVSZWYoYWxsT2YsIGAke3BvaW50ZXJ9L2FsbE9mLyR7aW5kZXh9YCkpXG4gICAgICAgICAgICAucmVkdWNlUmlnaHQoKG5leHQsIGJlZm9yZSkgPT4gbmV4dCAmJiBiZWZvcmUsIHRydWUpO1xuICAgICAgICBpZiAobWF5UmVzb2x2ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZUFsbE9mU2NoZW1hKGRyYWZ0LCBzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVTY2hlbWEgPSBtZXJnZVNjaGVtYSh0ZW1wbGF0ZVNjaGVtYSwgcmVzb2x2ZWRTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRlbXBsYXRlU2NoZW1hLnBvaW50ZXIgPSB0ZW1wbGF0ZVNjaGVtYS5wb2ludGVyIHx8IHNjaGVtYS4kcmVmIHx8IHBvaW50ZXI7XG4gICAgcmV0dXJuIHRlbXBsYXRlU2NoZW1hO1xufVxuY29uc3QgaXNKc29uU2NoZW1hID0gKHRlbXBsYXRlKSA9PiB0ZW1wbGF0ZSAmJiB0eXBlb2YgdGVtcGxhdGUgPT09IFwib2JqZWN0XCI7XG4vKipcbiAqIENyZWF0ZSBkYXRhIG9iamVjdCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2NoZW1hXG4gKlxuICogQHBhcmFtIGRyYWZ0IC0ganNvbiBzY2hlbWEgZHJhZnRcbiAqIEBwYXJhbSBbZGF0YV0gLSBvcHRpb25hbCB0ZW1wbGF0ZSBkYXRhXG4gKiBAcGFyYW0gW3NjaGVtYV0gLSBqc29uIHNjaGVtYSwgZGVmYXVsdHMgdG8gcm9vdFNjaGVtYVxuICogQHJldHVybiBjcmVhdGVkIHRlbXBsYXRlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0VGVtcGxhdGUoZHJhZnQsIGRhdGEsIF9zY2hlbWEsIHBvaW50ZXIsIG9wdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKF9zY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFRlbXBsYXRlOiBtaXNzaW5nIHNjaGVtYSBmb3IgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICB9XG4gICAgaWYgKHBvaW50ZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHBvaW50ZXJcIik7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgJHJlZiByZWZlcmVuY2VzLCBhbGxPZiBhbmQgZmlyc3QgYW55T2YgZGVmaW5pdGlvbnNcbiAgICBsZXQgc2NoZW1hID0gY3JlYXRlVGVtcGxhdGVTY2hlbWEoZHJhZnQsIF9zY2hlbWEsIGRhdGEsIHBvaW50ZXIpO1xuICAgIGlmICghaXNKc29uU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcG9pbnRlciA9IHNjaGVtYS5wb2ludGVyO1xuICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuY29uc3QpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jb25zdDtcbiAgICB9XG4gICAgLy8gQGZlYXR1cmUgb25lT2ZcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgIGlmIChpc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm9uZU9mWzBdLnR5cGUgfHxcbiAgICAgICAgICAgICAgICBzY2hlbWEudHlwZSB8fFxuICAgICAgICAgICAgICAgIChzY2hlbWEuY29uc3QgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCkgfHxcbiAgICAgICAgICAgICAgICBnZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgICAgICBzY2hlbWEgPSB7IC4uLnNjaGVtYS5vbmVPZlswXSwgdHlwZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmluZCBjb3JyZWN0IHNjaGVtYSBmb3IgZGF0YVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlT25lT2ZGdXp6eShkcmFmdCwgZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25FcnJvcihyZXNvbHZlZFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsICYmIG9wdHMucmVtb3ZlSW52YWxpZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLm9uZU9mWzBdO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFNjaGVtYS50eXBlID0gKF9hID0gcmVzb2x2ZWRTY2hlbWEudHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQHRvZG8gQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSlcbiAgICAvLyAtPiBoYXNEZWZhdWx0PyByZXR1cm5cbiAgICAvLyBpZiBub3QgLT4gcGljayBmaXJzdCB0eXBlc1xuICAgIGlmICghaXNKc29uU2NoZW1hKHNjaGVtYSkgfHwgc2NoZW1hLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSlcbiAgICAgICAgPyBzZWxlY3RUeXBlKHNjaGVtYS50eXBlLCBkYXRhLCBzY2hlbWEuZGVmYXVsdClcbiAgICAgICAgOiBzY2hlbWEudHlwZTtcbiAgICAvLyByZXNldCBpbnZhbGlkIHR5cGVcbiAgICBjb25zdCBqYXZhc2NyaXB0VHlwZU9mRGF0YSA9IGdldFR5cGVPZihkYXRhKTtcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmXG4gICAgICAgIGphdmFzY3JpcHRUeXBlT2ZEYXRhICE9PSB0eXBlICYmXG4gICAgICAgICEoamF2YXNjcmlwdFR5cGVPZkRhdGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZSA9PT0gXCJpbnRlZ2VyXCIpKSB7XG4gICAgICAgIGRhdGEgPSBjb252ZXJ0VmFsdWUodHlwZSwgZGF0YSk7XG4gICAgfVxuICAgIGlmIChUWVBFW3R5cGVdID09IG51bGwpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB3ZSBjb3VsZCBub3QgcmVzb2x2ZSB0aGUgdHlwZVxuICAgICAgICAvLyAoc2NoZW1hLXR5cGUgY291bGQgbm90IGJlIHJlc29sdmVkIGFuZCByZXR1cm5lZCBhbiBlcnJvcilcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlSW52YWxpZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IFRZUEVbdHlwZV0oZHJhZnQsIHNjaGVtYSwgZGF0YSwgcG9pbnRlciwgb3B0cyk7XG4gICAgcmV0dXJuIHRlbXBsYXRlRGF0YTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFR5cGUodHlwZXMsIGRhdGEsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChkYXRhID09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRUeXBlID0gZ2V0VHlwZU9mKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoZGVmYXVsdFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlc1swXTtcbiAgICB9XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZXRUeXBlT2YoZGF0YSk7XG4gICAgaWYgKHR5cGVzLmluY2x1ZGVzKGRhdGFUeXBlKSkge1xuICAgICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlc1swXTtcbn1cbmNvbnN0IFRZUEUgPSB7XG4gICAgbnVsbDogKGRyYWZ0LCBzY2hlbWEsIGRhdGEpID0+IGdldERlZmF1bHQoc2NoZW1hLCBkYXRhLCBudWxsKSxcbiAgICBzdHJpbmc6IChkcmFmdCwgc2NoZW1hLCBkYXRhKSA9PiBnZXREZWZhdWx0KHNjaGVtYSwgZGF0YSwgXCJcIiksXG4gICAgbnVtYmVyOiAoZHJhZnQsIHNjaGVtYSwgZGF0YSkgPT4gZ2V0RGVmYXVsdChzY2hlbWEsIGRhdGEsIDApLFxuICAgIGludGVnZXI6IChkcmFmdCwgc2NoZW1hLCBkYXRhKSA9PiBnZXREZWZhdWx0KHNjaGVtYSwgZGF0YSwgMCksXG4gICAgYm9vbGVhbjogKGRyYWZ0LCBzY2hlbWEsIGRhdGEpID0+IGdldERlZmF1bHQoc2NoZW1hLCBkYXRhLCBmYWxzZSksXG4gICAgb2JqZWN0OiAoZHJhZnQsIHNjaGVtYSwgZGF0YSwgcG9pbnRlciwgb3B0cykgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gc2NoZW1hLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IHt9IDogc2NoZW1hLmRlZmF1bHQ7XG4gICAgICAgIGNvbnN0IGQgPSB7fTsgLy8gZG8gbm90IGFzc2lnbiBkYXRhIGhlcmUsIHRvIGtlZXAgb3JkZXJpbmcgZnJvbSBqc29uLXNjaGVtYVxuICAgICAgICBjb25zdCByZXF1aXJlZCA9IChvcHRzLmV4dGVuZERlZmF1bHRzID09PSBmYWxzZSAmJiBzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSA/IFtdIDogKChfYSA9IHNjaGVtYS5yZXF1aXJlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pO1xuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEgPT0gbnVsbCB8fCBkYXRhW2tleV0gPT0gbnVsbCA/IHRlbXBsYXRlW2tleV0gOiBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXF1aXJlZCA9IHJlcXVpcmVkLmluY2x1ZGVzKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gT21pdCBhZGRpbmcgYSBwcm9wZXJ0eSBpZiBpdCBpcyBub3QgcmVxdWlyZWQgb3Igb3B0aW9uYWwgcHJvcHMgc2hvdWxkIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgfHwgaXNSZXF1aXJlZCB8fCBvcHRzLmFkZE9wdGlvbmFsUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZFtrZXldID0gZ2V0VGVtcGxhdGUoZHJhZnQsIHZhbHVlLCBzY2hlbWEucHJvcGVydGllc1trZXldLCBgJHtwb2ludGVyfS9wcm9wZXJ0aWVzLyR7a2V5fWAsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBmZWF0dXJlIGRlcGVuZGVuY2llc1xuICAgICAgICAvLyBoYXMgdG8gYmUgZG9uZSBhZnRlciByZXNvbHZpbmcgcHJvcGVydGllcyBzbyBkZXBlbmRlbmN5IG1heSB0cmlnZ2VyXG4gICAgICAgIGxldCBkZXBlbmRlbmNpZXNTY2hlbWEgPSByZXNvbHZlRGVwZW5kZW5jaWVzKGRyYWZ0LCBzY2hlbWEsIGQpO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzU2NoZW1hKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXNTY2hlbWEgPSBtZXJnZVNjaGVtYShzY2hlbWEsIGRlcGVuZGVuY2llc1NjaGVtYSk7XG4gICAgICAgICAgICBkZWxldGUgZGVwZW5kZW5jaWVzU2NoZW1hLmRlcGVuZGVuY2llcztcbiAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY3lEYXRhID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGRhdGEsIGRlcGVuZGVuY2llc1NjaGVtYSwgYCR7cG9pbnRlcn0vZGVwZW5kZW5jaWVzYCwgb3B0cyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGQsIGRlcGVuZGVuY3lEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlSW52YWxpZERhdGEgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICBnZXRUeXBlT2Yoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB2YWxpZCBtaXNzaW5nIGRhdGEgKGFkZGl0aW9uYWxzKSB0byByZXN1bHRpbmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWZ0LmlzVmFsaWQoZGF0YVtrZXldLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFueSBtaXNzaW5nIGRhdGEgKGFkZGl0aW9uYWxzKSB0byByZXN1bHRpbmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiBkW2tleV0gPT0gbnVsbCAmJiAoZFtrZXldID0gZGF0YVtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQGZlYXR1cmUgaWYtdGhlbi1lbHNlXG4gICAgICAgIGNvbnN0IGlmU2NoZW1hID0gcmVzb2x2ZUlmU2NoZW1hKGRyYWZ0LCBzY2hlbWEsIGQpO1xuICAgICAgICBpZiAoaWZTY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxEYXRhID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGQsIHsgdHlwZTogXCJvYmplY3RcIiwgLi4uaWZTY2hlbWEgfSwgcG9pbnRlciwgb3B0cyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGQsIGFkZGl0aW9uYWxEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm5zIG9iamVjdCwgd2hpY2ggaXMgb3JkZXJlZCBieSBqc29uLXNjaGVtYVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9LFxuICAgIC8vIGJ1aWxkIGFycmF5IHR5cGUgb2YgaXRlbXMsIGlnbm9yZXMgYWRkaXRpb25hbEl0ZW1zXG4gICAgYXJyYXk6IChkcmFmdCwgc2NoZW1hLCBkYXRhLCBwb2ludGVyLCBvcHRzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChzY2hlbWEuaXRlbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEgfHwgW107IC8vIGl0ZW1zIGFyZSB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHNjaGVtYS5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBbXSA6IHNjaGVtYS5kZWZhdWx0O1xuICAgICAgICBjb25zdCBkID0gZGF0YSB8fCB0ZW1wbGF0ZTtcbiAgICAgICAgY29uc3QgbWluSXRlbXMgPSAob3B0cy5leHRlbmREZWZhdWx0cyA9PT0gZmFsc2UgJiYgc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkgPyAwIDogKHNjaGVtYS5taW5JdGVtcyB8fCAwKTtcbiAgICAgICAgLy8gYnVpbGQgZGVmaW5lZCBzZXQgb2YgaXRlbXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBNYXRoLm1heChtaW5JdGVtcyAhPT0gbnVsbCAmJiBtaW5JdGVtcyAhPT0gdm9pZCAwID8gbWluSXRlbXMgOiAwLCAoX2IgPSAoX2EgPSBzY2hlbWEuaXRlbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZFtpXSA9IGdldFRlbXBsYXRlKGRyYWZ0LCBkW2ldID09IG51bGwgPyB0ZW1wbGF0ZVtpXSA6IGRbaV0sIHNjaGVtYS5pdGVtc1tpXSwgYCR7cG9pbnRlcn0vaXRlbXMvJHtpfWAsIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWJvcnQgaWYgdGhlIHNjaGVtYSBpcyBpbnZhbGlkXG4gICAgICAgIGlmIChnZXRUeXBlT2Yoc2NoZW1hLml0ZW1zKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGxPZiBhbmQgZmlyc3QgYW55T2YgZGVmaW5pdGlvblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZVNjaGVtYSA9IGNyZWF0ZVRlbXBsYXRlU2NoZW1hKGRyYWZ0LCBzY2hlbWEuaXRlbXMsIGRhdGEsIHBvaW50ZXIpO1xuICAgICAgICBpZiAodGVtcGxhdGVTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICBwb2ludGVyID0gdGVtcGxhdGVTY2hlbWEucG9pbnRlciB8fCBwb2ludGVyO1xuICAgICAgICAvLyBidWlsZCBkYXRhIGZvciBmaXJzdCBvbmVPZi1zY2hlbWFcbiAgICAgICAgaWYgKHRlbXBsYXRlU2NoZW1hLm9uZU9mICYmIGQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVPZlNjaGVtYSA9IHRlbXBsYXRlU2NoZW1hLm9uZU9mWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5JdGVtczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZFtpXSA9IGdldFRlbXBsYXRlKGRyYWZ0LCBkW2ldID09IG51bGwgPyB0ZW1wbGF0ZVtpXSA6IGRbaV0sIG9uZU9mU2NoZW1hLCBgJHtwb2ludGVyfS9vbmVPZi8wYCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wbGV0ZSBkYXRhIHNlbGVjdGluZyBjb3JyZWN0IG9uZU9mLXNjaGVtYVxuICAgICAgICBpZiAodGVtcGxhdGVTY2hlbWEub25lT2YgJiYgZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQ291bnQgPSBNYXRoLm1heChtaW5JdGVtcywgZC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRbaV0gPT0gbnVsbCA/IHRlbXBsYXRlW2ldIDogZFtpXTtcbiAgICAgICAgICAgICAgICBsZXQgb25lID0gcmVzb2x2ZU9uZU9mRnV6enkoZHJhZnQsIHZhbHVlLCB0ZW1wbGF0ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uZSA9PSBudWxsIHx8IGlzSnNvbkVycm9yKG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NoZW1hIGNvdWxkIG5vdCBiZSByZXNvbHZlZCBvciBkYXRhIGlzIGludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb3B0cy5yZW1vdmVJbnZhbGlkRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBpbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBkW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGludmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lID0gdGVtcGxhdGVTY2hlbWEub25lT2ZbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkW2ldID0gZ2V0VGVtcGxhdGUoZHJhZnQsIHZhbHVlLCBvbmUsIGAke3BvaW50ZXJ9L29uZU9mLyR7aX1gLCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NoZW1hIGlzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIGRbaV0gPSBnZXRUZW1wbGF0ZShkcmFmdCwgdmFsdWUsIG9uZSwgYCR7cG9pbnRlcn0vb25lT2YvJHtpfWAsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIGRhdGEgZnJvbSBpdGVtcy1kZWZpbml0aW9uXG4gICAgICAgIGlmICh0ZW1wbGF0ZVNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KG1pbkl0ZW1zLCBkLmxlbmd0aCk7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBkW2ldID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGRbaV0gPT0gbnVsbCA/IHRlbXBsYXRlW2ldIDogZFtpXSwgdGVtcGxhdGVTY2hlbWEsIGAke3BvaW50ZXJ9L2l0ZW1zYCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEsIHRlbXBsYXRlVmFsdWUsIGluaXRWYWx1ZSkge1xuICAgIGlmICh0ZW1wbGF0ZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYS5jb25zdCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNvbnN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEuZGVmYXVsdCA9PT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZW51bVswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5pdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLmRlZmF1bHQ7XG59XG5leHBvcnQgZGVmYXVsdCAoZHJhZnQsIGRhdGEsIHNjaGVtYSA9IGRyYWZ0LnJvb3RTY2hlbWEsIG9wdHMpID0+IHtcbiAgICBjYWNoZSA9IHt9O1xuICAgIGlmIChvcHRzKSB7XG4gICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZShkcmFmdCwgZGF0YSwgc2NoZW1hLCBcIiNcIiwgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFRlbXBsYXRlKGRyYWZ0LCBkYXRhLCBzY2hlbWEsIFwiI1wiLCBkZWZhdWx0T3B0aW9ucyk7XG59O1xuIiwiLyoqXG4gKiBUZXN0IGlmIHRoZSBkYXRhIGlzIHZhbGlkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gc2NoZW1hXG4gKlxuICogQHBhcmFtIGRyYWZ0IC0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIFtzY2hlbWFdIC0ganNvbiBzY2hlbWFcbiAqIEBwYXJhbSBbcG9pbnRlcl0gLSBqc29uIHBvaW50ZXIgcG9pbnRpbmcgdG8gdmFsdWVcbiAqIEByZXR1cm4gaWYgc2NoZW1hIGRvZXMgbWF0Y2ggZ2l2ZW4gdmFsdWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNWYWxpZChkcmFmdCwgdmFsdWUsIHNjaGVtYSA9IGRyYWZ0LnJvb3RTY2hlbWEsIHBvaW50ZXIgPSBcIiNcIikge1xuICAgIHJldHVybiBkcmFmdC52YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hLCBwb2ludGVyKS5sZW5ndGggPT09IDA7XG59XG4iLCIvKiBlc2xpbnQgbm8tYml0d2lzZTogMCAqL1xuLyoqXG4gKiB0YWtlbiBmcm9tIHB1bnljb2RlQDIuMS4wXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweGZjMDApID09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIC8vIExvdyBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M2ZmKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNmZikgKyAweDEwMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyoqXG4gKiByZXR1cm5zIHRoZSBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gb2YgYSBkZWNpbWFsIG51bWJlciBvciAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVjaXNpb24odmFsdWUpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBgJHt2YWx1ZX1gO1xuICAgIGNvbnN0IGluZGV4ID0gc3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyAwIDogc3RyaW5nLmxlbmd0aCAtIChpbmRleCArIDEpO1xufVxuIiwiaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi4vZ2V0VHlwZU9mXCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4uL2NvbmZpZy9zZXR0aW5nc1wiO1xuaW1wb3J0IHVjczJkZWNvZGUgZnJvbSBcIi4uL3V0aWxzL3B1bnljb2RlLnVjczJkZWNvZGVcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4uL3V0aWxzL2lzT2JqZWN0XCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVBbGxPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbGxPZlwiO1xuaW1wb3J0IHsgdmFsaWRhdGVBbnlPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgdmFsaWRhdGVEZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi4vZmVhdHVyZXMvZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZU9uZU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgeyBnZXRQcmVjaXNpb24gfSBmcm9tIFwiLi4vdXRpbHMvZ2V0UHJlY2lzaW9uXCI7XG5pbXBvcnQgZGVlcEVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIjtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc1Byb3BlcnR5ID0gKHZhbHVlLCBwcm9wZXJ0eSkgPT4gISh2YWx1ZVtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcHJvcGVydHkpKTtcbi8vIGxpc3Qgb2YgdmFsaWRhdGlvbiBrZXl3b3JkczogaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjVcbmNvbnN0IEtleXdvcmRWYWxpZGF0aW9uID0ge1xuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdHJ1ZSB8fCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gYXJyYW5nZW1lbnQgd2l0aCBwYXR0ZXJuUHJvcGVydGllcy4gcGF0dGVyblByb3BlcnRpZXMgdmFsaWRhdGUgYmVmb3JlIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9zcGFjZXRlbGVzY29wZS5naXRodWIuaW8vdW5kZXJzdGFuZGluZy1qc29uLXNjaGVtYS9yZWZlcmVuY2Uvb2JqZWN0Lmh0bWwjaW5kZXgtNVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgbGV0IHJlY2VpdmVkUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoKHByb3ApID0+IHNldHRpbmdzLnByb3BlcnR5QmxhY2tsaXN0LmluY2x1ZGVzKHByb3ApID09PSBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICAgICAgaWYgKGdldFR5cGVPZihzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgcmVjZWl2ZWQgcHJvcGVydGllcyBieSBtYXRjaGluZyBwYXR0ZXJuUHJvcGVydGllc1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybnMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpLm1hcCgocGF0dGVybikgPT4gbmV3IFJlZ0V4cChwYXR0ZXJuKSk7XG4gICAgICAgICAgICByZWNlaXZlZFByb3BlcnRpZXMgPSByZWNlaXZlZFByb3BlcnRpZXMuZmlsdGVyKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVybnNbaV0udGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZHMgYW4gZXJyb3IgZm9yIGVhY2ggYW4gdW5leHBlY3RlZCBwcm9wZXJ0eVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlY2VpdmVkUHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcmVjZWl2ZWRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsSXNPYmplY3QgPSBpc09iamVjdChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIHsgb25lT2Y6IFtdIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbElzT2JqZWN0ICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLm9uZU9mKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkcmFmdC5yZXNvbHZlT25lT2YodmFsdWVbcHJvcGVydHldLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIGAke3BvaW50ZXJ9LyR7cHJvcGVydHl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0pzb25FcnJvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMuYWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcmVjZWl2ZWRQcm9wZXJ0aWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGV4cGVjdGVkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIGFsbCB2YWxpZGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogcmVzdWx0LmRhdGEuZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5kcmFmdC52YWxpZGF0ZSh2YWx1ZVtwcm9wZXJ0eV0sIHJlc3VsdCwgcG9pbnRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZGl0aW9uYWxJc09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5kcmFmdC52YWxpZGF0ZSh2YWx1ZVtwcm9wZXJ0eV0sIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcywgYCR7cG9pbnRlcn0vJHtwcm9wZXJ0eX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMubm9BZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiByZWNlaXZlZFByb3BlcnRpZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBleHBlY3RlZFByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgYWxsT2Y6IHZhbGlkYXRlQWxsT2YsXG4gICAgYW55T2Y6IHZhbGlkYXRlQW55T2YsXG4gICAgZGVwZW5kZW5jaWVzOiB2YWxpZGF0ZURlcGVuZGVuY2llcyxcbiAgICBlbnVtOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGVPZih2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVTdHIgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5lbnVtLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHNjaGVtYS5lbnVtW2ldKSA9PT0gdmFsdWVTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmVudW0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZW51bUVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSwgdmFsdWVzOiBzY2hlbWEuZW51bSB9KTtcbiAgICB9LFxuICAgIGZvcm1hdDogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChkcmFmdC52YWxpZGF0ZUZvcm1hdFtzY2hlbWEuZm9ybWF0XSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZHJhZnQudmFsaWRhdGVGb3JtYXRbc2NoZW1hLmZvcm1hdF0oZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWlsIHNpbGVudGx5IGlmIGdpdmVuIGZvcm1hdCBpcyBub3QgZGVmaW5lZFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgaXRlbXM6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICAvLyBAZHJhZnQgPj0gNyBib29sIHNjaGVtYVxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmludmFsaWREYXRhRXJyb3IoeyBwb2ludGVyLCB2YWx1ZSwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRGF0YSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgLy8gQHRvZG8gcmVldmFsdWF0ZTogaW5jb21wbGV0ZSBzY2hlbWEgaXMgY3JlYXRlZCBoZXJlXG4gICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gZHJhZnQuc3RlcChpLCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25FcnJvcihpdGVtU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbaXRlbVNjaGVtYV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtRXJyb3JzID0gZHJhZnQudmFsaWRhdGUoaXRlbURhdGEsIGl0ZW1TY2hlbWEsIGAke3BvaW50ZXJ9LyR7aX1gKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLml0ZW1FcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSxcbiAgICBtYXhpbXVtOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5tYXhpbXVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm1heGltdW0gJiYgc2NoZW1hLm1heGltdW0gPCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhpbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5tYXhpbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWF4aW11bSAmJiBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gdHJ1ZSAmJiBzY2hlbWEubWF4aW11bSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWF4aW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBzY2hlbWEubWF4aW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWF4SXRlbXM6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLm1heEl0ZW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm1heEl0ZW1zIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1heEl0ZW1zRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5tYXhJdGVtcyxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1heExlbmd0aDogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWF4TGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhPZlN0cmluZyA9IHVjczJkZWNvZGUodmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXhMZW5ndGggPCBsZW5ndGhPZlN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhMZW5ndGhFcnJvcih7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoOiBzY2hlbWEubWF4TGVuZ3RoLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoT2ZTdHJpbmcsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtYXhQcm9wZXJ0aWVzOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlDb3VudCA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWF4UHJvcGVydGllcykgPT09IGZhbHNlICYmIHNjaGVtYS5tYXhQcm9wZXJ0aWVzIDwgcHJvcGVydHlDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhQcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heFByb3BlcnRpZXM6IHNjaGVtYS5tYXhQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogcHJvcGVydHlDb3VudCxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1pbkxlbmd0aDogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWluTGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhPZlN0cmluZyA9IHVjczJkZWNvZGUodmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVtYS5taW5MZW5ndGggPiBsZW5ndGhPZlN0cmluZykge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5taW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1pbkxlbmd0aE9uZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiBzY2hlbWEubWluTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aE9mU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1pbkxlbmd0aEVycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IHNjaGVtYS5taW5MZW5ndGgsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhPZlN0cmluZyxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1pbmltdW06IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLm1pbmltdW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWluaW11bSA+IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1pbmltdW1FcnJvcih7XG4gICAgICAgICAgICAgICAgbWluaW11bTogc2NoZW1hLm1pbmltdW0sXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID09PSB0cnVlICYmIHNjaGVtYS5taW5pbXVtID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taW5pbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1pbmltdW06IHNjaGVtYS5taW5pbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtaW5JdGVtczogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWluSXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWluSXRlbXMgPiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEubWluSXRlbXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1pbkl0ZW1zT25lRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtaW5JdGVtczogc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taW5JdGVtc0Vycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5JdGVtczogc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWluUHJvcGVydGllczogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWluUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydHlDb3VudCA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChzY2hlbWEubWluUHJvcGVydGllcyA+IHByb3BlcnR5Q291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluUHJvcGVydGllc0Vycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5Qcm9wZXJ0aWVzOiBzY2hlbWEubWluUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHByb3BlcnR5Q291bnQsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtdWx0aXBsZU9mOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5tdWx0aXBsZU9mKSB8fCB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVQcmVjaXNpb24gPSBnZXRQcmVjaXNpb24odmFsdWUpO1xuICAgICAgICBjb25zdCBtdWx0aXBsZVByZWNpc2lvbiA9IGdldFByZWNpc2lvbihzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgIGlmICh2YWx1ZVByZWNpc2lvbiA+IG11bHRpcGxlUHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAvLyB2YWx1ZSB3aXRoIGhpZ2hlciBwcmVjaXNpb24gdGhlbiBtdWx0aXBsZU9mLXByZWNpc2lvbiBjYW4gbmV2ZXIgYmUgbXVsdGlwbGVcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubXVsdGlwbGVPZkVycm9yKHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBzY2hlbWEubXVsdGlwbGVPZixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIG11bHRpcGxlUHJlY2lzaW9uKTtcbiAgICAgICAgY29uc3QgdmFsID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHByZWNpc2lvbik7XG4gICAgICAgIGNvbnN0IG11bHRpcGxlID0gTWF0aC5yb3VuZChzY2hlbWEubXVsdGlwbGVPZiAqIHByZWNpc2lvbik7XG4gICAgICAgIGlmICgodmFsICUgbXVsdGlwbGUpIC8gcHJlY2lzaW9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm11bHRpcGxlT2ZFcnJvcih7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogc2NoZW1hLm11bHRpcGxlT2YsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1heWJlIGFsc28gY2hlY2sgb3ZlcmZsb3dcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxNTM2Ny9jYXRjaC1hbmQtY29tcHV0ZS1vdmVyZmxvdy1kdXJpbmctbXVsdGlwbGljYXRpb24tb2YtdHdvLWxhcmdlLWludGVnZXJzXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBub3Q6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgaWYgKGRyYWZ0LnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEubm90LCBwb2ludGVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy5ub3RFcnJvcih7IHZhbHVlLCBub3Q6IHNjaGVtYS5ub3QsIHBvaW50ZXIsIHNjaGVtYSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9LFxuICAgIG9uZU9mOiB2YWxpZGF0ZU9uZU9mLFxuICAgIHBhdHRlcm46IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChzY2hlbWEucGF0dGVybiwgXCJ1XCIpO1xuICAgICAgICBpZiAocGF0dGVybi50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMucGF0dGVybkVycm9yKHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBzY2hlbWEucGF0dGVybixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hLnBhdHRlcm5FeGFtcGxlIHx8IHNjaGVtYS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICBjb25zdCBwcCA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcztcbiAgICAgICAgaWYgKGdldFR5cGVPZihwcCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gT2JqZWN0LmtleXMocHApLm1hcCgoZXhwcikgPT4gKHtcbiAgICAgICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKGV4cHIpLFxuICAgICAgICAgICAgcGF0dGVyblNjaGVtYTogcHBbZXhwcl1cbiAgICAgICAgfSkpO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybnNbaV0ucmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbEVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKHZhbHVlW2tleV0sIHBhdHRlcm5zW2ldLnBhdHRlcm5TY2hlbWEsIGAke3BvaW50ZXJ9LyR7a2V5fWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsRXJyb3JzICYmIHZhbEVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi52YWxFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXR0ZXJuRm91bmQgPT09IGZhbHNlICYmIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGFycmFuZ2VtZW50IHdpdGggYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMucGF0dGVyblByb3BlcnRpZXNFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybnM6IE9iamVjdC5rZXlzKHBwKS5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyB8fCB7fSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wZXJ0eSh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSBkcmFmdC5zdGVwKGtleSwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcik7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RXJyb3JzID0gZHJhZnQudmFsaWRhdGUodmFsdWVba2V5XSwgaXRlbVNjaGVtYSwgYCR7cG9pbnRlcn0vJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ua2V5RXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgLy8gQHRvZG8gbW92ZSB0byBzZXBhcmF0ZSBmaWxlOiB0aGlzIGlzIGN1c3RvbSBrZXl3b3JkIHZhbGlkYXRpb24gZm9yIEpzb25FZGl0b3IucHJvcGVydGllcyBrZXl3b3JkXG4gICAgcHJvcGVydGllc1JlcXVpcmVkOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyB8fCB7fSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMucmVxdWlyZWRQcm9wZXJ0eUVycm9yKHsga2V5LCBwb2ludGVyLCBzY2hlbWEsIHZhbHVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSBkcmFmdC5zdGVwKGtleSwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcik7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RXJyb3JzID0gZHJhZnQudmFsaWRhdGUodmFsdWVba2V5XSwgaXRlbVNjaGVtYSwgYCR7cG9pbnRlcn0vJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ua2V5RXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgcmVxdWlyZWQ6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLnJlcXVpcmVkLm1hcCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcGVydHkodmFsdWUsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMucmVxdWlyZWRQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBAdG9kbyBtb3ZlIHRvIHNlcGFyYXRlIGZpbGU6IHRoaXMgaXMgY3VzdG9tIGtleXdvcmQgdmFsaWRhdGlvbiBmb3IgSnNvbkVkaXRvci5yZXF1aXJlZCBrZXl3b3JkXG4gICAgcmVxdWlyZWROb3RFbXB0eTogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEucmVxdWlyZWQubWFwKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlW3Byb3BlcnR5XSA9PSBudWxsIHx8IHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMudmFsdWVOb3RFbXB0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXI6IGAke3BvaW50ZXJ9LyR7cHJvcGVydHl9YCxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmlxdWVJdGVtczogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgc2NoZW1hLnVuaXF1ZUl0ZW1zKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHVwbGljYXRlcyA9IFtdO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWVwRXF1YWwoaXRlbSwgdmFsdWVbaV0pICYmICFkdXBsaWNhdGVzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy51bmlxdWVJdGVtc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXI6IGAke3BvaW50ZXJ9LyR7aX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlUG9pbnRlcjogYCR7cG9pbnRlcn0vJHtpbmRleH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlQb2ludGVyOiBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEtleXdvcmRWYWxpZGF0aW9uO1xuIiwiaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi9nZXRUeXBlT2ZcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHMvaXNPYmplY3RcIjtcbi8qKlxuICogQ3JlYXRlIGEgc2ltcGxlIGpzb24gc2NoZW1hIGZvciB0aGUgZ2l2ZW4gaW5wdXQgZGF0YVxuICogQHBhcmFtICBkYXRhIC0gZGF0YSB0byBnZXQganNvbiBzY2hlbWEgZm9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYU9mKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgdHlwZTogZ2V0VHlwZU9mKGRhdGEpXG4gICAgfTtcbiAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiAoc2NoZW1hLnByb3BlcnRpZXNba2V5XSA9IGNyZWF0ZVNjaGVtYU9mKGRhdGFba2V5XSkpKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS50eXBlID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHNjaGVtYS5pdGVtcyA9IGNyZWF0ZVNjaGVtYU9mKGRhdGFbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NoZW1hLml0ZW1zID0gZGF0YS5tYXAoY3JlYXRlU2NoZW1hT2YpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IGNyZWF0ZVNjaGVtYU9mIGZyb20gXCIuL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyByZWR1Y2VTY2hlbWEgfSBmcm9tIFwiLi9yZWR1Y2VTY2hlbWFcIjtcbmNvbnN0IHN0ZXBUeXBlID0ge1xuICAgIGFycmF5OiAoZHJhZnQsIGtleSwgc2NoZW1hLCBkYXRhLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1WYWx1ZSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YVtrZXldO1xuICAgICAgICBjb25zdCBpdGVtc1R5cGUgPSBnZXRUeXBlT2Yoc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQHNwZWM6IGlnbm9yZSBhZGRpdGlvbmFsSXRlbXMsIHdoZW4gaXRlbXMgaXMgc2NoZW1hLW9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIChyZWR1Y2VTY2hlbWEoZHJhZnQsIHNjaGVtYS5pdGVtcywgaXRlbVZhbHVlLCBgJHtwb2ludGVyfS8ke2tleX1gKSB8fFxuICAgICAgICAgICAgICAgIGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hLml0ZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1zVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAvLyBAZHJhZnQgPj0gNyBib29sIHNjaGVtYSwgaXRlbXM6W3RydWUsIGZhbHNlXVxuICAgICAgICAgICAgaWYgKHNjaGVtYS5pdGVtc1trZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNjaGVtYU9mKGl0ZW1WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAZHJhZnQgPj0gNyBib29sIHNjaGVtYSwgaXRlbXM6W3RydWUsIGZhbHNlXVxuICAgICAgICAgICAgaWYgKHNjaGVtYS5pdGVtc1trZXldID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuaW52YWxpZERhdGFFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hLml0ZW1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQucmVzb2x2ZVJlZihzY2hlbWEuaXRlbXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmFkZGl0aW9uYWxJdGVtc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSB0cnVlIHx8IHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTY2hlbWFPZihpdGVtVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFR5cGVPZihzY2hlbWEuYWRkaXRpb25hbEl0ZW1zKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYSAke0pTT04uc3RyaW5naWZ5KHNjaGVtYSwgbnVsbCwgMil9IGZvciAke0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zICE9PSBmYWxzZSAmJiBpdGVtVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIHJlZXZhbHVhdGU6IGluY29tcGxldGUgc2NoZW1hIGlzIGNyZWF0ZWQgaGVyZVxuICAgICAgICAgICAgLy8gQHRvZG8gc3VwcG9ydCBhZGRpdGlvbmFsSXRlbXM6IHtzY2hlbWF9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2NoZW1hT2YoaXRlbVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IHNjaGVtYSBmb3IgJHtrZXl9IGF0ICR7cG9pbnRlcn1gKTtcbiAgICB9LFxuICAgIG9iamVjdDogKGRyYWZ0LCBrZXksIHNjaGVtYSwgZGF0YSwgcG9pbnRlcikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHNjaGVtYSA9IHJlZHVjZVNjaGVtYShkcmFmdCwgc2NoZW1hLCBkYXRhLCBwb2ludGVyKTtcbiAgICAgICAgLy8gQGZlYXR1cmUgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IChfYSA9IHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS5wcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fba2V5XTtcbiAgICAgICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIHBhdHRlcm5Qcm9wZXJ0aWVzIGFsc28gdmFsaWRhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gQGZlYXR1cmUgYm9vbGVhbiBzY2hlbWFcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcmJpZGRlblByb3BlcnR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTY2hlbWFPZihkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRTY2hlbWEgPSBkcmFmdC5yZXNvbHZlUmVmKHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChpc0pzb25FcnJvcih0YXJnZXRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgb25lT2Ygc2VsZWN0aW9uLCB3aGljaCBtdXN0IGJlIHJlc29sdmVkXG4gICAgICAgICAgICBpZiAodGFyZ2V0U2NoZW1hICYmIEFycmF5LmlzQXJyYXkodGFyZ2V0U2NoZW1hLm9uZU9mKSkge1xuICAgICAgICAgICAgICAgIC8vIEBzcGVjaWFsIGNhc2U6IHRoaXMgaXMgYSBtaXggb2YgYSBzY2hlbWEgYW5kIG9wdGlvbmFsIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2UgcmVzb2x2ZSB0aGUgc2NoZW1hIGhlcmUgYW5kIGFkZCB0aGUgb3JpZ2luYWwgc2NoZW1hIHRvIGBvbmVPZlNjaGVtYWBcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQucmVzb2x2ZU9uZU9mKGRhdGFba2V5XSwgdGFyZ2V0U2NoZW1hLCBgJHtwb2ludGVyfS8ke2tleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc29sdmVkIHNjaGVtYSBvciBlcnJvclxuICAgICAgICAgICAgaWYgKHRhcmdldFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQGZlYXR1cmUgcGF0dGVyblByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgeyBwYXR0ZXJuUHJvcGVydGllcyB9ID0gc2NoZW1hO1xuICAgICAgICBpZiAoZ2V0VHlwZU9mKHBhdHRlcm5Qcm9wZXJ0aWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gZmluZCBtYXRjaGluZyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgIGxldCByZWdleDtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5zID0gT2JqZWN0LmtleXMocGF0dGVyblByb3BlcnRpZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5zW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQGZlYXR1cmUgYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgeyBhZGRpdGlvbmFsUHJvcGVydGllcyB9ID0gc2NoZW1hO1xuICAgICAgICBpZiAoZ2V0VHlwZU9mKGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAmJiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCB8fCBhZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTY2hlbWFPZihkYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMudW5rbm93blByb3BlcnR5RXJyb3Ioe1xuICAgICAgICAgICAgcHJvcGVydHk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgcG9pbnRlcjogYCR7cG9pbnRlcn1gLFxuICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGpzb24tc2NoZW1hIG9mIHRoZSBnaXZlbiBvYmplY3QgcHJvcGVydHkgb3IgYXJyYXkgaXRlbS5cbiAqIGUuZy4gaXQgc3RlcHMgYnkgb25lIGtleSBpbnRvIHRoZSBkYXRhXG4gKlxuICogIFRoaXMgaGVscGVyIGRldGVybWluZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBwcm9wZXJ0eSB3aXRoaW4gdGhlIHNjaGVtYSAoYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCBvbmVPZiwgLi4uKSBhbmRcbiAqICByZXR1cm5zIHRoZSBjb3JyZWN0IHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0gIGRyYWZ0ICAgICAgLSB2YWxpZGF0b3JcbiAqIEBwYXJhbSAga2V5ICAgICAgIC0gcHJvcGVydHktbmFtZSBvciBhcnJheS1pbmRleFxuICogQHBhcmFtICBzY2hlbWEgICAgLSBqc29uIHNjaGVtYSBvZiBjdXJyZW50IGRhdGFcbiAqIEBwYXJhbSAgZGF0YSAgICAgIC0gcGFyZW50IG9mIGtleVxuICogQHBhcmFtICBbcG9pbnRlcl0gLSBwb2ludGVyIHRvIHNjaGVtYSBhbmQgZGF0YSAocGFyZW50IG9mIGtleSlcbiAqIEByZXR1cm4gU2NoZW1hIG9yIEVycm9yIGlmIGZhaWxlZCByZXNvbHZpbmcga2V5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0ZXAoZHJhZnQsIGtleSwgc2NoZW1hLCBkYXRhLCBwb2ludGVyID0gXCIjXCIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZU9mRGF0YSA9IGdldFR5cGVPZihkYXRhKTtcbiAgICBsZXQgc2NoZW1hVHlwZSA9IChfYSA9IHNjaGVtYS50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlT2ZEYXRhO1xuICAgIC8vIEBkcmFmdCA+PSA0ID9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSkge1xuICAgICAgICBpZiAoIXNjaGVtYVR5cGUuaW5jbHVkZXModHlwZU9mRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMudHlwZUVycm9yKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBzY2hlbWEudHlwZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogdHlwZU9mRGF0YSxcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYVR5cGUgPSB0eXBlT2ZEYXRhO1xuICAgIH1cbiAgICBjb25zdCBzdGVwRnVuY3Rpb24gPSBzdGVwVHlwZVtzY2hlbWFUeXBlXTtcbiAgICBpZiAoc3RlcEZ1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVJlc3VsdCA9IHN0ZXBGdW5jdGlvbihkcmFmdCwgYCR7a2V5fWAsIHNjaGVtYSwgZGF0YSwgcG9pbnRlcik7XG4gICAgICAgIGlmIChzY2hlbWFSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5zY2hlbWFXYXJuaW5nKHtcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNjaGVtYSB0eXBlICR7c2NoZW1hLnR5cGV9IGZvciBrZXkgJHtrZXl9YCk7XG59XG4iLCJpbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIHBvc3NpYmxlIGNoaWxkLXNjaGVtYXMgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBrZXkuIEluIGNhc2Ugb2YgYSBvbmVPZiBzZWxlY3Rpb24sIG11bHRpcGxlIHNjaGVtYXNcbiAqIGNvdWxkIGJlIGFkZGVkIGF0IHRoZSBnaXZlbiBwcm9wZXJ0eSAoZS5nLiBpdGVtLWluZGV4KSwgdGh1cyBhbiBhcnJheSBvZiBvcHRpb25zIGlzIHJldHVybmVkLiBJbiBhbGwgb3RoZXIgY2FzZXNcbiAqIGEgbGlzdCB3aXRoIGEgc2luZ2xlIGl0ZW0gd2lsbCBiZSByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSBkcmFmdCAgICAgICAgLSBkcmFmdCB0byB1c2VcbiAqIEBwYXJhbSBwcm9wZXJ0eSAgICAtIHBhcmVudCBzY2hlbWEgb2YgZm9sbG93aW5nIHByb3BlcnR5XG4gKiBAcGFyYW0gW3NjaGVtYV0gICAgLSBwYXJlbnQgc2NoZW1hIG9mIGZvbGxvd2luZyBwcm9wZXJ0eVxuICogQHJldHVyblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbihkcmFmdCwgcHJvcGVydHksIHNjaGVtYSA9IGRyYWZ0LnJvb3RTY2hlbWEpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHNjaGVtYS5vbmVPZikge1xuICAgICAgICByZXR1cm4gc2NoZW1hLm9uZU9mLm1hcCgoaXRlbSkgPT4gZHJhZnQucmVzb2x2ZVJlZihpdGVtKSk7XG4gICAgfVxuICAgIGlmICgoX2EgPSBzY2hlbWEuaXRlbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbmVPZikge1xuICAgICAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm9uZU9mLm1hcCgoaXRlbSkgPT4gZHJhZnQucmVzb2x2ZVJlZihpdGVtKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRyYWZ0LnN0ZXAocHJvcGVydHksIHNjaGVtYSwge30sIFwiI1wiKTtcbiAgICBpZiAoaXNKc29uRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3VsdF07XG59XG4iLCIvKipcbiAqIEB0b2RvOiB0eXBlIGlzIGFsc28gYSBrZXl3b3JkLCBhcyBpcyBwcm9wZXJ0aWVzLCBpdGVtcywgZXRjXG4gKlxuICogQW4gaW5zdGFuY2UgaGFzIG9uZSBvZiBzaXggcHJpbWl0aXZlIHR5cGVzIChodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS1kcmFmdC5odG1sI3JmYy5zZWN0aW9uLjQuMilcbiAqIG9yIHNldmVuIGluIGNhc2Ugb2YgYWp2IGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9hanYvYmxvYi9tYXN0ZXIvS0VZV09SRFMubWQjdHlwZVxuICogMSBudWxsLCAyIGJvb2xlYW4sIDMgb2JqZWN0LCA0IGFycmF5LCA1IG51bWJlciwgNiBzdHJpbmcgKDcgaW50ZWdlcilcbiAqL1xuY29uc3QgdHlwZVZhbGlkYXRvcnMgPSB7XG4gICAgYXJyYXk6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLmFycmF5XG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4gc2NoZW1hICYmIHNjaGVtYVtrZXldICE9IG51bGwpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gZHJhZnQudmFsaWRhdGVLZXl3b3JkW2tleV0oZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpKSxcbiAgICBvYmplY3Q6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLm9iamVjdFxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHNjaGVtYSAmJiBzY2hlbWFba2V5XSAhPSBudWxsKVxuICAgICAgICAubWFwKChrZXkpID0+IGRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSksXG4gICAgc3RyaW5nOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IGRyYWZ0LnR5cGVLZXl3b3Jkcy5zdHJpbmdcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpLFxuICAgIGludGVnZXI6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLm51bWJlclxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHNjaGVtYSAmJiBzY2hlbWFba2V5XSAhPSBudWxsKVxuICAgICAgICAubWFwKChrZXkpID0+IGRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSksXG4gICAgbnVtYmVyOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IGRyYWZ0LnR5cGVLZXl3b3Jkcy5udW1iZXJcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpLFxuICAgIGJvb2xlYW46IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLmJvb2xlYW5cbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpLFxuICAgIG51bGw6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLm51bGxcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpXG59O1xuZXhwb3J0IGRlZmF1bHQgdHlwZVZhbGlkYXRvcnM7XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgZXJyb3JPclByb21pc2UgfSBmcm9tIFwiLi91dGlscy9maWx0ZXJcIjtcbmltcG9ydCBmbGF0dGVuQXJyYXkgZnJvbSBcIi4vdXRpbHMvZmxhdHRlbkFycmF5XCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgZXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbFwiO1xuZnVuY3Rpb24gZ2V0SnNvblNjaGVtYVR5cGUodmFsdWUsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IGpzVHlwZSA9IGdldFR5cGVPZih2YWx1ZSk7XG4gICAgaWYgKGpzVHlwZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAoZXhwZWN0ZWRUeXBlID09PSBcImludGVnZXJcIiB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlKSAmJiBleHBlY3RlZFR5cGUuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKSkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IGlzTmFOKHZhbHVlKSA/IFwiaW50ZWdlclwiIDogXCJudW1iZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGpzVHlwZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGRhdGEgd2l0aCBqc29uIHNjaGVtYVxuICpcbiAqIEBwYXJhbSBkcmFmdCAtIHZhbGlkYXRvclxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBbc2NoZW1hXSAtIGpzb24gc2NoZW1hLCBkZWZhdWx0cyB0byByb290U2NoZW1hXG4gKiBAcGFyYW0gW3BvaW50ZXJdIC0ganNvbiBwb2ludGVyIHBvaW50aW5nIHRvIHZhbHVlICh1c2VkIGZvciBlcnJvci1tZXNzYWdlcyBvbmx5KVxuICogQHJldHVybiBsaXN0IG9mIGVycm9ycyBvciBlbXB0eVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YWxpZGF0ZShkcmFmdCwgdmFsdWUsIHNjaGVtYSA9IGRyYWZ0LnJvb3RTY2hlbWEsIHBvaW50ZXIgPSBcIiNcIikge1xuICAgIHNjaGVtYSA9IGRyYWZ0LnJlc29sdmVSZWYoc2NoZW1hKTtcbiAgICAvLyBAZHJhZnQgPj0gMDdcbiAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2RyYWZ0LmVycm9ycy5pbnZhbGlkRGF0YUVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSB9KV07XG4gICAgfVxuICAgIGlmIChpc0pzb25FcnJvcihzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBbc2NoZW1hXTtcbiAgICB9XG4gICAgLy8gQGRyYWZ0ID49IDYgY29uc3RcbiAgICBpZiAoc2NoZW1hLmNvbnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGVxdWFsKHNjaGVtYS5jb25zdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtkcmFmdC5lcnJvcnMuY29uc3RFcnJvcih7IHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUsIGV4cGVjdGVkOiBzY2hlbWEuY29uc3QgfSldO1xuICAgIH1cbiAgICBjb25zdCByZWNlaXZlZFR5cGUgPSBnZXRKc29uU2NoZW1hVHlwZSh2YWx1ZSwgc2NoZW1hLnR5cGUpO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IHNjaGVtYS50eXBlIHx8IHJlY2VpdmVkVHlwZTtcbiAgICBpZiAocmVjZWl2ZWRUeXBlICE9PSBleHBlY3RlZFR5cGUgJiZcbiAgICAgICAgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZSkgfHwgIWV4cGVjdGVkVHlwZS5pbmNsdWRlcyhyZWNlaXZlZFR5cGUpKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZHJhZnQuZXJyb3JzLnR5cGVFcnJvcih7XG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHJlY2VpdmVkVHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRUeXBlXG4gICAgICAgICAgICB9KVxuICAgICAgICBdO1xuICAgIH1cbiAgICBpZiAoZHJhZnQudmFsaWRhdGVUeXBlW3JlY2VpdmVkVHlwZV0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2RyYWZ0LmVycm9ycy5pbnZhbGlkVHlwZUVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSwgcmVjZWl2ZWRUeXBlIH0pXTtcbiAgICB9XG4gICAgLy8gZ2V0IHR5cGUgdmFsaWRhdGlvbiByZXN1bHRzXG4gICAgY29uc3QgZXJyb3JzID0gZmxhdHRlbkFycmF5KGRyYWZ0LnZhbGlkYXRlVHlwZVtyZWNlaXZlZFR5cGVdKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSk7XG4gICAgcmV0dXJuIGVycm9ycy5maWx0ZXIoZXJyb3JPclByb21pc2UpOyAvLyBpZ25vcmUgcHJvbWlzZXMgaGVyZVxufVxuIiwiaW1wb3J0IGFkZFJlbW90ZVNjaGVtYSBmcm9tIFwiLi4vYWRkUmVtb3RlU2NoZW1hXCI7XG5pbXBvcnQgY29tcGlsZVNjaGVtYSBmcm9tIFwiLi4vY29tcGlsZVNjaGVtYVwiO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gXCIuLi9lYWNoXCI7XG5pbXBvcnQgeyBlYWNoU2NoZW1hIH0gZnJvbSBcIi4uL2VhY2hTY2hlbWFcIjtcbmltcG9ydCBFUlJPUlMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vZXJyb3JzXCI7XG5pbXBvcnQgRk9STUFUUyBmcm9tIFwiLi4vdmFsaWRhdGlvbi9mb3JtYXRcIjtcbmltcG9ydCBnZXRTY2hlbWEgZnJvbSBcIi4uL2dldFNjaGVtYVwiO1xuaW1wb3J0IGdldFRlbXBsYXRlIGZyb20gXCIuLi9nZXRUZW1wbGF0ZVwiO1xuaW1wb3J0IGlzVmFsaWQgZnJvbSBcIi4uL2lzVmFsaWRcIjtcbmltcG9ydCBLRVlXT1JEUyBmcm9tIFwiLi4vdmFsaWRhdGlvbi9rZXl3b3JkXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4uL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgeyByZXNvbHZlQWxsT2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCB7IHJlc29sdmVBbnlPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZU9uZU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZi5zdHJpY3RcIjtcbmltcG9ydCBzdGVwIGZyb20gXCIuLi9zdGVwXCI7XG5pbXBvcnQgY3JlYXRlU2NoZW1hT2YgZnJvbSBcIi4uL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24gZnJvbSBcIi4uL2dldENoaWxkU2NoZW1hU2VsZWN0aW9uXCI7XG5pbXBvcnQgVFlQRVMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vdHlwZVwiO1xuaW1wb3J0IHZhbGlkYXRlIGZyb20gXCIuLi92YWxpZGF0ZVwiO1xuaW1wb3J0IHsgRHJhZnQgfSBmcm9tIFwiLi4vZHJhZnRcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vY29uZmlnL3NldHRpbmdzXCI7XG5jb25zdCBkcmFmdDA0Q29uZmlnID0ge1xuICAgIHR5cGVLZXl3b3Jkczoge1xuICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCIsXG4gICAgICAgICAgICBcIm1heEl0ZW1zXCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiXG4gICAgICAgIF0sXG4gICAgICAgIGJvb2xlYW46IFtcImVudW1cIiwgXCJub3RcIiwgXCJhbGxPZlwiLCBcImFueU9mXCIsIFwib25lT2ZcIl0sXG4gICAgICAgIG9iamVjdDogW1xuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCIsXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCJcbiAgICAgICAgXSxcbiAgICAgICAgc3RyaW5nOiBbXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCIsXG4gICAgICAgICAgICBcImVudW1cIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICBcIm1heExlbmd0aFwiLFxuICAgICAgICAgICAgXCJtaW5MZW5ndGhcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCIsXG4gICAgICAgICAgICBcInBhdHRlcm5cIlxuICAgICAgICBdLFxuICAgICAgICBudW1iZXI6IFtcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwibWF4aW11bVwiLFxuICAgICAgICAgICAgXCJtaW5pbXVtXCIsXG4gICAgICAgICAgICBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVsbDogW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcImVudW1cIiwgXCJmb3JtYXRcIiwgXCJub3RcIiwgXCJvbmVPZlwiXVxuICAgIH0sXG4gICAgdmFsaWRhdGVLZXl3b3JkOiBLRVlXT1JEUyxcbiAgICB2YWxpZGF0ZVR5cGU6IFRZUEVTLFxuICAgIHZhbGlkYXRlRm9ybWF0OiBGT1JNQVRTLFxuICAgIGVycm9yczogRVJST1JTLFxuICAgIGFkZFJlbW90ZVNjaGVtYSxcbiAgICBjb21waWxlU2NoZW1hLFxuICAgIGNyZWF0ZVNjaGVtYU9mLFxuICAgIGVhY2gsXG4gICAgZWFjaFNjaGVtYSxcbiAgICBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbixcbiAgICBnZXRTY2hlbWEsXG4gICAgZ2V0VGVtcGxhdGUsXG4gICAgaXNWYWxpZCxcbiAgICByZXNvbHZlQWxsT2YsXG4gICAgcmVzb2x2ZUFueU9mLFxuICAgIHJlc29sdmVPbmVPZixcbiAgICByZXNvbHZlUmVmLFxuICAgIHN0ZXAsXG4gICAgdmFsaWRhdGUsXG4gICAgdGVtcGxhdGVEZWZhdWx0T3B0aW9uczogc2V0dGluZ3MudGVtcGxhdGVEZWZhdWx0T3B0aW9uc1xufTtcbmNsYXNzIERyYWZ0MDQgZXh0ZW5kcyBEcmFmdCB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihtZXJnZShkcmFmdDA0Q29uZmlnLCBjb25maWcpLCBzY2hlbWEpO1xuICAgIH1cbn1cbmV4cG9ydCB7IERyYWZ0MDQsIGRyYWZ0MDRDb25maWcgfTtcbiIsImltcG9ydCB7IGVhY2hTY2hlbWEgfSBmcm9tIFwiLi4vLi4vZWFjaFNjaGVtYVwiO1xuLy8gaW1wb3J0IHJlbW90ZXMgZnJvbSBcIi4uLy4uLy4uL3JlbW90ZXNcIjtcbmltcG9ydCBqb2luU2NvcGUgZnJvbSBcIi4uLy4uL2NvbXBpbGUvam9pblNjb3BlXCI7XG5pbXBvcnQgZ2V0UmVmIGZyb20gXCIuLi8uLi9jb21waWxlL2dldFJlZlwiO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSBcIkBzYWdvbGQvanNvbi1wb2ludGVyXCI7XG5jb25zdCBDT01QSUxFRCA9IFwiX19jb21waWxlZFwiO1xuY29uc3QgQ09NUElMRURfUkVGID0gXCJfX3JlZlwiO1xuY29uc3QgR0VUX1JFRiA9IFwiZ2V0UmVmXCI7XG5jb25zdCBHRVRfUk9PVCA9IFwiZ2V0Um9vdFwiO1xuY29uc3Qgc3VmZml4ZXMgPSAvKCN8XFwvKSskL2c7XG4vKipcbiAqIEBkcmFmdCBzdGFydGluZyB3aXRoIF9kcmFmdCAwNl8ga2V5d29yZCBgaWRgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYCRpZGBcbiAqXG4gKiBjb21waWxlcyB0aGUgaW5wdXQgcm9vdCBzY2hlbWEgZm9yICRyZWYgcmVzb2x1dGlvbiBhbmQgcmV0dXJucyBpdCBhZ2FpblxuICogQGF0dGVudGlvbiB0aGlzIG1vZGlmaWVzIGlucHV0IHNjaGVtYSBidXQgbWFpbnRhaW5zIG9iamVjdC1zdHJ1Y3R1cmVcbiAqXG4gKiBmb3IgYSBjb21waWxlZCBqc29uLXNjaGVtYSB5b3UgY2FuIGNhbGwgZ2V0UmVmIG9uIGFueSBjb250YWluZWQgc2NoZW1hIChsb2NhdGlvbiBvZiB0eXBlKS5cbiAqIHRoaXMgcmVzb2x2ZXMgYSAkcmVmIHRhcmdldCB0byBhIHZhbGlkIHNjaGVtYSAoZm9yIGEgdmFsaWQgJHJlZilcbiAqXG4gKiBAcGFyYW0gcm9vdFNjaGVtYSByb290IGpzb24tc2NoZW1hICgkaWQsIGRlZnMsIC4uLiApIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSBbZm9yY2VdID0gZmFsc2UgZm9yY2UgY29tcGlsZSBqc29uLXNjaGVtYVxuICogQHJldHVybiBjb21waWxlZCBqc29uLXNjaGVtYVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21waWxlU2NoZW1hKGRyYWZ0LCBzY2hlbWFUb0NvbXBpbGUsIHJvb3RTY2hlbWEgPSBzY2hlbWFUb0NvbXBpbGUsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGluY29tcGxldGUgSnNvblNjaGVtYSB0eXBlXG4gICAgaWYgKHNjaGVtYVRvQ29tcGlsZSA9PT0gdHJ1ZSB8fCBzY2hlbWFUb0NvbXBpbGUgPT09IGZhbHNlIHx8IHNjaGVtYVRvQ29tcGlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFUb0NvbXBpbGU7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUb0NvbXBpbGVbQ09NUElMRURdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVRvQ29tcGlsZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBjb25zdCBjb250ZXh0ID0geyBpZHM6IHt9LCByZW1vdGVzOiBkcmFmdC5yZW1vdGVzIH07XG4gICAgY29uc3Qgcm9vdFNjaGVtYUFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc2NoZW1hVG9Db21waWxlKTtcbiAgICBjb25zdCBjb21waWxlZFNjaGVtYSA9IEpTT04ucGFyc2Uocm9vdFNjaGVtYUFzU3RyaW5nKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcGlsZWRTY2hlbWEsIENPTVBJTEVELCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcGlsZWRTY2hlbWEsIEdFVF9SRUYsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBnZXRSZWYuYmluZChudWxsLCBjb250ZXh0LCBjb21waWxlZFNjaGVtYSlcbiAgICB9KTtcbiAgICAvLyBiYWlsIGVhcmx5LCB3aGVuIG5vICRyZWZzIGFyZSBkZWZpbmVkXG4gICAgaWYgKGZvcmNlID09PSBmYWxzZSAmJiByb290U2NoZW1hQXNTdHJpbmcuaW5jbHVkZXMoXCIkcmVmXCIpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gY29tcGlsZWRTY2hlbWE7XG4gICAgfVxuICAgIC8vIGNvbXBpbGUgdGhpcyBzY2hlbWEgdW5kZXIgcm9vdFNjaGVtYSwgbWFraW5nIGRlZmluaXRpb25zIGF2YWlsYWJsZSB0byAkcmVmLXJlc29sdXRpb25cbiAgICBpZiAoY29tcGlsZWRTY2hlbWEgIT09IHJvb3RTY2hlbWEpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBpbGVkU2NoZW1hLCBcIiRkZWZzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgcm9vdFNjaGVtYS5kZWZpbml0aW9ucywgcm9vdFNjaGVtYS4kZGVmcywgY29tcGlsZWRTY2hlbWEuZGVmaW5pdGlvbnMsIGNvbXBpbGVkU2NoZW1hLiRkZWZzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0ge307XG4gICAgY29uc3QgZ2V0Um9vdCA9ICgpID0+IGNvbXBpbGVkU2NoZW1hO1xuICAgIGVhY2hTY2hlbWEoY29tcGlsZWRTY2hlbWEsIChzY2hlbWEsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc2NoZW1hLiRpZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHNjaGVtYSBiZWluZyBtZXJnZWQgb24gcm9vdCBvYmplY3QsIHdlIGNhbm5vdCBvdmVycmlkZVxuICAgICAgICAgICAgLy8gcGFyZW50cyBsb2NhdGlvbnMsIGJ1dCBtdXN0IHJldXNlIGl0XG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRpZC5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAvKGFsbE9mfGFueU9mfG9uZU9mKVxcL1xcZCskLy50ZXN0KHBvaW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UG9pbnRlciA9IHBvaW50ZXIucmVwbGFjZSgvXFwvKGFsbE9mfGFueU9mfG9uZU9mKVxcL1xcZCskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gZ2V0KGNvbXBpbGVkU2NoZW1hLCBwYXJlbnRQb2ludGVyKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJGlkID0gKF9hID0gcGFyZW50U2NoZW1hLiRpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2NoZW1hLiRpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuaWRzW3NjaGVtYS4kaWQucmVwbGFjZShzdWZmaXhlcywgXCJcIildID0gcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB1cCBzY29wZXMgYW5kIGFkZCB0aGVtIHRvICRyZWYtcmVzb2x1dGlvbiBtYXBcbiAgICAgICAgcG9pbnRlciA9IGAjJHtwb2ludGVyfWAucmVwbGFjZSgvIyMrLywgXCIjXCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1BvaW50ZXIgPSBwb2ludGVyLnJlcGxhY2UoL1xcL1teL10rJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBwYXJlbnRQb2ludGVyID0gcG9pbnRlci5yZXBsYWNlKC9cXC9bXi9dK1xcL1teL10rJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1Njb3BlID0gc2NvcGVzW3ByZXZpb3VzUG9pbnRlcl0gfHwgc2NvcGVzW3BhcmVudFBvaW50ZXJdO1xuICAgICAgICBjb25zdCBzY29wZSA9IGpvaW5TY29wZShwcmV2aW91c1Njb3BlLCBzY2hlbWEuJGlkKTtcbiAgICAgICAgc2NvcGVzW3BvaW50ZXJdID0gc2NvcGU7XG4gICAgICAgIGlmIChjb250ZXh0Lmlkc1tzY29wZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC5pZHNbc2NvcGVdID0gcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLiRyZWYgJiYgIXNjaGVtYVtDT01QSUxFRF9SRUZdKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCBDT01QSUxFRF9SRUYsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogam9pblNjb3BlKHNjb3BlLCBzY2hlbWEuJHJlZilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQHRvZG8gY3VycmVudGx5IG5vdCB1c2VkOlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYSwgR0VUX1JPT1QsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBnZXRSb290IH0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJjb21waWxlZCByZWZcIiwgc2NvcGUsIHNjaGVtYS4kcmVmLCBcIj0+XCIsIGpvaW5TY29wZShzY29wZSwgc2NoZW1hLiRyZWYpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb21waWxlZFNjaGVtYTtcbn1cbiIsImltcG9ydCBLZXl3b3JkcyBmcm9tIFwiLi4vLi4vdmFsaWRhdGlvbi9rZXl3b3JkXCI7XG5pbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi8uLi9nZXRUeXBlT2ZcIjtcbmltcG9ydCB7IHZhbGlkYXRlSWYgfSBmcm9tIFwiLi4vLi4vZmVhdHVyZXMvaWZcIjtcbmNvbnN0IEtleXdvcmRWYWxpZGF0aW9uID0ge1xuICAgIC4uLktleXdvcmRzLFxuICAgIC8vIEBkcmFmdCA+PSA2XG4gICAgY29udGFpbnM6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAoc2NoZW1hLmNvbnRhaW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5jb250YWluc0FycmF5RXJyb3IoeyBwb2ludGVyLCB2YWx1ZSwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuY29udGFpbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmNvbnRhaW5zQW55RXJyb3IoeyBwb2ludGVyLCB2YWx1ZSwgc2NoZW1hIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYS5jb250YWlucykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBpbnZhbGlkIHNjaGVtYVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoZHJhZnQuaXNWYWxpZCh2YWx1ZVtpXSwgc2NoZW1hLmNvbnRhaW5zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5jb250YWluc0Vycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSB9KTtcbiAgICB9LFxuICAgIGV4Y2x1c2l2ZU1heGltdW06IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhpbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPj0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluaW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgLy8gQGZlYXR1cmUgaWYtdGhlbi1lbHNlXG4gICAgaWY6IHZhbGlkYXRlSWYsXG4gICAgbWF4aW11bTogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWF4aW11bSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5tYXhpbXVtICYmIHNjaGVtYS5tYXhpbXVtIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWF4aW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBzY2hlbWEubWF4aW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWluaW11bTogKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSA9PiB7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWluaW11bSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5taW5pbXVtID4gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluaW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBzY2hlbWEubWluaW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgIGNvbnN0IHBwID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoZ2V0VHlwZU9mKHBwKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSBPYmplY3Qua2V5cyhwcCkubWFwKChleHByKSA9PiAoe1xuICAgICAgICAgICAgcmVnZXg6IG5ldyBSZWdFeHAoZXhwciksXG4gICAgICAgICAgICBwYXR0ZXJuU2NoZW1hOiBwcFtleHByXVxuICAgICAgICB9KSk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuc1tpXS5yZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGEgYm9vbGVhbiBzY2hlbWEgYGZhbHNlYCwgYWx3YXlzIGludmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5zW2ldLnBhdHRlcm5TY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMucGF0dGVyblByb3BlcnRpZXNFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybnM6IE9iamVjdC5rZXlzKHBwKS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxFcnJvcnMgPSBkcmFmdC52YWxpZGF0ZSh2YWx1ZVtrZXldLCBwYXR0ZXJuc1tpXS5wYXR0ZXJuU2NoZW1hLCBgJHtwb2ludGVyfS8ke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbEVycm9ycyAmJiB2YWxFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0dGVybkZvdW5kID09PSBmYWxzZSAmJiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBhcnJhbmdlbWVudCB3aXRoIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLnBhdHRlcm5Qcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5zOiBPYmplY3Qua2V5cyhwcCkuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgLy8gQGRyYWZ0ID49IDZcbiAgICBwcm9wZXJ0eU5hbWVzOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgLy8gYm9vbCBzY2hlbWFcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0eU5hbWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gZW1wdHkgb2JqZWN0cyBhcmUgdmFsaWRcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuaW52YWxpZFByb3BlcnR5TmFtZUVycm9yKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogT2JqZWN0LmtleXModmFsdWUpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnR5TmFtZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFR5cGVPZihzY2hlbWEucHJvcGVydHlOYW1lcykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBpbnZhbGlkIHNjaGVtYVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSB7IC4uLnNjaGVtYS5wcm9wZXJ0eU5hbWVzLCB0eXBlOiBcInN0cmluZ1wiIH07XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGRyYWZ0LnZhbGlkYXRlKHByb3AsIHByb3BlcnR5U2NoZW1hLCBgJHtwb2ludGVyfS8ke3Byb3B9YCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLmludmFsaWRQcm9wZXJ0eU5hbWVFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3I6IHZhbGlkYXRpb25SZXN1bHRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtwcm9wXSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgS2V5d29yZFZhbGlkYXRpb247XG4iLCIvKipcbiAqIEB0b2RvOiB0eXBlIGlzIGFsc28gYSBrZXl3b3JkLCBhcyBpcyBwcm9wZXJ0aWVzLCBpdGVtcywgZXRjXG4gKlxuICogQW4gaW5zdGFuY2UgaGFzIG9uZSBvZiBzaXggcHJpbWl0aXZlIHR5cGVzIChodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS1kcmFmdC5odG1sI3JmYy5zZWN0aW9uLjQuMilcbiAqIG9yIHNldmVuIGluIGNhc2Ugb2YgYWp2IGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9hanYvYmxvYi9tYXN0ZXIvS0VZV09SRFMubWQjdHlwZVxuICogMSBudWxsLCAyIGJvb2xlYW4sIDMgb2JqZWN0LCA0IGFycmF5LCA1IG51bWJlciwgNiBzdHJpbmcgKDcgaW50ZWdlcilcbiAqL1xuY29uc3QgdmFsaWRhdGlvblR5cGUgPSB7XG4gICAgYXJyYXk6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLmFycmF5XG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4gc2NoZW1hICYmIHNjaGVtYVtrZXldICE9IG51bGwpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gZHJhZnQudmFsaWRhdGVLZXl3b3JkW2tleV0oZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpKSxcbiAgICBvYmplY3Q6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLm9iamVjdFxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHNjaGVtYSAmJiBzY2hlbWFba2V5XSAhPSBudWxsKVxuICAgICAgICAubWFwKChrZXkpID0+IGRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSksXG4gICAgc3RyaW5nOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IGRyYWZ0LnR5cGVLZXl3b3Jkcy5zdHJpbmdcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpLFxuICAgIGludGVnZXI6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLm51bWJlclxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHNjaGVtYSAmJiBzY2hlbWFba2V5XSAhPSBudWxsKVxuICAgICAgICAubWFwKChrZXkpID0+IGRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKGRyYWZ0LCBzY2hlbWEsIHZhbHVlLCBwb2ludGVyKSksXG4gICAgbnVtYmVyOiAoZHJhZnQsIHNjaGVtYSwgdmFsdWUsIHBvaW50ZXIpID0+IGRyYWZ0LnR5cGVLZXl3b3Jkcy5udW1iZXJcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpLFxuICAgIGJvb2xlYW46IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLmJvb2xlYW5cbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpLFxuICAgIG51bGw6IChkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikgPT4gZHJhZnQudHlwZUtleXdvcmRzLm51bGxcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBkcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShkcmFmdCwgc2NoZW1hLCB2YWx1ZSwgcG9pbnRlcikpXG59O1xuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGlvblR5cGU7XG4iLCJpbXBvcnQgYWRkUmVtb3RlU2NoZW1hIGZyb20gXCIuLi9hZGRSZW1vdGVTY2hlbWFcIjtcbmltcG9ydCBjb21waWxlU2NoZW1hIGZyb20gXCIuLi9kcmFmdDA2L2NvbXBpbGVcIjtcbmltcG9ydCB7IGVhY2ggfSBmcm9tIFwiLi4vZWFjaFwiO1xuaW1wb3J0IHsgZWFjaFNjaGVtYSB9IGZyb20gXCIuLi9lYWNoU2NoZW1hXCI7XG5pbXBvcnQgRVJST1JTIGZyb20gXCIuLi92YWxpZGF0aW9uL2Vycm9yc1wiO1xuaW1wb3J0IEZPUk1BVFMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vZm9ybWF0XCI7XG5pbXBvcnQgZ2V0U2NoZW1hIGZyb20gXCIuLi9nZXRTY2hlbWFcIjtcbmltcG9ydCBnZXRUZW1wbGF0ZSBmcm9tIFwiLi4vZ2V0VGVtcGxhdGVcIjtcbmltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkXCI7XG5pbXBvcnQgS0VZV09SRFMgZnJvbSBcIi4uL2RyYWZ0MDYvdmFsaWRhdGlvbi9rZXl3b3JkXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4uL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgeyByZXNvbHZlQWxsT2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCB7IHJlc29sdmVBbnlPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZU9uZU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZi5zdHJpY3RcIjtcbmltcG9ydCBjcmVhdGVTY2hlbWFPZiBmcm9tIFwiLi4vY3JlYXRlU2NoZW1hT2ZcIjtcbmltcG9ydCBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbiBmcm9tIFwiLi4vZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb25cIjtcbmltcG9ydCBzdGVwIGZyb20gXCIuLi9zdGVwXCI7XG5pbXBvcnQgVFlQRVMgZnJvbSBcIi4uL2RyYWZ0MDYvdmFsaWRhdGlvbi90eXBlXCI7XG5pbXBvcnQgdmFsaWRhdGUgZnJvbSBcIi4uL3ZhbGlkYXRlXCI7XG5pbXBvcnQgeyBEcmFmdCB9IGZyb20gXCIuLi9kcmFmdFwiO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gXCIuLi9jb25maWcvc2V0dGluZ3NcIjtcbmNvbnN0IGRyYWZ0MDZDb25maWcgPSB7XG4gICAgdHlwZUtleXdvcmRzOiB7XG4gICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCIsXG4gICAgICAgICAgICBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICBcImVudW1cIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIixcbiAgICAgICAgICAgIFwibWF4SXRlbXNcIixcbiAgICAgICAgICAgIFwibWluSXRlbXNcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCIsXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9vbGVhbjogW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcImVudW1cIiwgXCJub3RcIiwgXCJvbmVPZlwiXSxcbiAgICAgICAgb2JqZWN0OiBbXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCIsXG4gICAgICAgICAgICBcImRlcGVuZGVuY2llc1wiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJpZlwiLFxuICAgICAgICAgICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCIsXG4gICAgICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHN0cmluZzogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJpZlwiLFxuICAgICAgICAgICAgXCJtYXhMZW5ndGhcIixcbiAgICAgICAgICAgIFwibWluTGVuZ3RoXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVtYmVyOiBbXG4gICAgICAgICAgICBcImVudW1cIixcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiLFxuICAgICAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJtYXhpbXVtXCIsXG4gICAgICAgICAgICBcIm1pbmltdW1cIixcbiAgICAgICAgICAgIFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIixcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiaWZcIlxuICAgICAgICBdLFxuICAgICAgICBudWxsOiBbXCJhbGxPZlwiLCBcImFueU9mXCIsIFwiZW51bVwiLCBcImZvcm1hdFwiLCBcIm5vdFwiLCBcIm9uZU9mXCJdXG4gICAgfSxcbiAgICB2YWxpZGF0ZUtleXdvcmQ6IEtFWVdPUkRTLFxuICAgIHZhbGlkYXRlVHlwZTogVFlQRVMsXG4gICAgdmFsaWRhdGVGb3JtYXQ6IEZPUk1BVFMsXG4gICAgZXJyb3JzOiBFUlJPUlMsXG4gICAgYWRkUmVtb3RlU2NoZW1hLFxuICAgIGNvbXBpbGVTY2hlbWEsXG4gICAgY3JlYXRlU2NoZW1hT2YsXG4gICAgZWFjaCxcbiAgICBlYWNoU2NoZW1hLFxuICAgIGdldENoaWxkU2NoZW1hU2VsZWN0aW9uLFxuICAgIGdldFNjaGVtYSxcbiAgICBnZXRUZW1wbGF0ZSxcbiAgICBpc1ZhbGlkLFxuICAgIHJlc29sdmVBbGxPZixcbiAgICByZXNvbHZlQW55T2YsXG4gICAgcmVzb2x2ZU9uZU9mLFxuICAgIHJlc29sdmVSZWYsXG4gICAgc3RlcCxcbiAgICB2YWxpZGF0ZSxcbiAgICB0ZW1wbGF0ZURlZmF1bHRPcHRpb25zOiBzZXR0aW5ncy50ZW1wbGF0ZURlZmF1bHRPcHRpb25zXG59O1xuY2xhc3MgRHJhZnQwNiBleHRlbmRzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKGRyYWZ0MDZDb25maWcsIGNvbmZpZyksIHNjaGVtYSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRHJhZnQwNiwgZHJhZnQwNkNvbmZpZyB9O1xuIiwiaW1wb3J0IGFkZFJlbW90ZVNjaGVtYSBmcm9tIFwiLi4vYWRkUmVtb3RlU2NoZW1hXCI7XG5pbXBvcnQgY29tcGlsZVNjaGVtYSBmcm9tIFwiLi4vZHJhZnQwNi9jb21waWxlXCI7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSBcIi4uL2VhY2hcIjtcbmltcG9ydCB7IGVhY2hTY2hlbWEgfSBmcm9tIFwiLi4vZWFjaFNjaGVtYVwiO1xuaW1wb3J0IEVSUk9SUyBmcm9tIFwiLi4vdmFsaWRhdGlvbi9lcnJvcnNcIjtcbmltcG9ydCBGT1JNQVRTIGZyb20gXCIuLi92YWxpZGF0aW9uL2Zvcm1hdFwiO1xuaW1wb3J0IGdldFNjaGVtYSBmcm9tIFwiLi4vZ2V0U2NoZW1hXCI7XG5pbXBvcnQgZ2V0VGVtcGxhdGUgZnJvbSBcIi4uL2dldFRlbXBsYXRlXCI7XG5pbXBvcnQgaXNWYWxpZCBmcm9tIFwiLi4vaXNWYWxpZFwiO1xuaW1wb3J0IEtFWVdPUkRTIGZyb20gXCIuLi9kcmFmdDA2L3ZhbGlkYXRpb24va2V5d29yZFwiO1xuaW1wb3J0IG1lcmdlIGZyb20gXCIuLi91dGlscy9tZXJnZVwiO1xuaW1wb3J0IHsgcmVzb2x2ZUFsbE9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL2FsbE9mXCI7XG5pbXBvcnQgeyByZXNvbHZlQW55T2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvYW55T2ZcIjtcbmltcG9ydCB7IHJlc29sdmVPbmVPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9vbmVPZlwiO1xuaW1wb3J0IHJlc29sdmVSZWYgZnJvbSBcIi4uL3Jlc29sdmVSZWYuc3RyaWN0XCI7XG5pbXBvcnQgY3JlYXRlU2NoZW1hT2YgZnJvbSBcIi4uL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24gZnJvbSBcIi4uL2dldENoaWxkU2NoZW1hU2VsZWN0aW9uXCI7XG5pbXBvcnQgc3RlcCBmcm9tIFwiLi4vc3RlcFwiO1xuaW1wb3J0IFRZUEVTIGZyb20gXCIuLi9kcmFmdDA2L3ZhbGlkYXRpb24vdHlwZVwiO1xuaW1wb3J0IHZhbGlkYXRlIGZyb20gXCIuLi92YWxpZGF0ZVwiO1xuaW1wb3J0IHsgRHJhZnQgfSBmcm9tIFwiLi4vZHJhZnRcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vY29uZmlnL3NldHRpbmdzXCI7XG5jb25zdCBkcmFmdDA3Q29uZmlnID0ge1xuICAgIHR5cGVLZXl3b3Jkczoge1xuICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJjb250YWluc1wiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImlmXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCIsXG4gICAgICAgICAgICBcIm1heEl0ZW1zXCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiXG4gICAgICAgIF0sXG4gICAgICAgIGJvb2xlYW46IFtcImFsbE9mXCIsIFwiYW55T2ZcIiwgXCJlbnVtXCIsIFwibm90XCIsIFwib25lT2ZcIl0sXG4gICAgICAgIG9iamVjdDogW1xuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzdHJpbmc6IFtcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgICAgICAgICBcIm1pbkxlbmd0aFwiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIixcbiAgICAgICAgICAgIFwicGF0dGVyblwiXG4gICAgICAgIF0sXG4gICAgICAgIG51bWJlcjogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIixcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4aW11bVwiLFxuICAgICAgICAgICAgXCJtaW5pbXVtXCIsXG4gICAgICAgICAgICBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVsbDogW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcImVudW1cIiwgXCJmb3JtYXRcIiwgXCJub3RcIiwgXCJvbmVPZlwiXVxuICAgIH0sXG4gICAgdmFsaWRhdGVLZXl3b3JkOiBLRVlXT1JEUyxcbiAgICB2YWxpZGF0ZVR5cGU6IFRZUEVTLFxuICAgIHZhbGlkYXRlRm9ybWF0OiBGT1JNQVRTLFxuICAgIGVycm9yczogRVJST1JTLFxuICAgIGFkZFJlbW90ZVNjaGVtYSxcbiAgICBjb21waWxlU2NoZW1hLFxuICAgIGNyZWF0ZVNjaGVtYU9mLFxuICAgIGVhY2gsXG4gICAgZWFjaFNjaGVtYSxcbiAgICBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbixcbiAgICBnZXRTY2hlbWEsXG4gICAgZ2V0VGVtcGxhdGUsXG4gICAgaXNWYWxpZCxcbiAgICByZXNvbHZlQWxsT2YsXG4gICAgcmVzb2x2ZUFueU9mLFxuICAgIHJlc29sdmVPbmVPZixcbiAgICByZXNvbHZlUmVmLFxuICAgIHN0ZXAsXG4gICAgdmFsaWRhdGUsXG4gICAgdGVtcGxhdGVEZWZhdWx0T3B0aW9uczogc2V0dGluZ3MudGVtcGxhdGVEZWZhdWx0T3B0aW9uc1xufTtcbmNsYXNzIERyYWZ0MDcgZXh0ZW5kcyBEcmFmdCB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihtZXJnZShkcmFmdDA3Q29uZmlnLCBjb25maWcpLCBzY2hlbWEpO1xuICAgIH1cbn1cbmV4cG9ydCB7IERyYWZ0MDcsIGRyYWZ0MDdDb25maWcgfTtcbiIsImltcG9ydCBtZXJnZSBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VcIjtcbmltcG9ydCB7IHJlc29sdmVPbmVPZkZ1enp5IH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZi5tZXJnZVwiO1xuaW1wb3J0IHsgRHJhZnQgfSBmcm9tIFwiLi4vZHJhZnRcIjtcbmltcG9ydCB7IGRyYWZ0MDdDb25maWcgfSBmcm9tIFwiLi4vZHJhZnQwN1wiO1xuY29uc3QgZHJhZnRKc29uRWRpdG9yQ29uZmlnID0ge1xuICAgIC4uLmRyYWZ0MDdDb25maWcsXG4gICAgcmVzb2x2ZU9uZU9mOiByZXNvbHZlT25lT2ZGdXp6eSxcbiAgICByZXNvbHZlUmVmXG59O1xuY2xhc3MgSnNvbkVkaXRvciBleHRlbmRzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKGRyYWZ0SnNvbkVkaXRvckNvbmZpZywgY29uZmlnKSwgc2NoZW1hKTtcbiAgICB9XG59XG5leHBvcnQgeyBKc29uRWRpdG9yLCBkcmFmdEpzb25FZGl0b3JDb25maWcgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUVycm9yLCBjcmVhdGVDdXN0b21FcnJvciB9IGZyb20gXCIuL2xpYi91dGlscy9jcmVhdGVDdXN0b21FcnJvclwiO1xuaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi9saWIvZ2V0VHlwZU9mXCI7XG5pbXBvcnQgeyByZXNvbHZlT25lT2YsIHJlc29sdmVPbmVPZkZ1enp5IH0gZnJvbSBcIi4vbGliL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgeyByZXNvbHZlQWxsT2YgfSBmcm9tIFwiLi9saWIvZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCByZXNvbHZlUmVmIGZyb20gXCIuL2xpYi9yZXNvbHZlUmVmLnN0cmljdFwiO1xuaW1wb3J0IHJlc29sdmVSZWZNZXJnZSBmcm9tIFwiLi9saWIvcmVzb2x2ZVJlZi5tZXJnZVwiO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gXCIuL2xpYi9jb25maWcvc2V0dGluZ3NcIjtcbmltcG9ydCBzdHJpbmdzIGZyb20gXCIuL2xpYi9jb25maWcvc3RyaW5nc1wiO1xuaW1wb3J0IHZhbGlkYXRlQXN5bmMgZnJvbSBcIi4vbGliL3ZhbGlkYXRlQXN5bmNcIjtcbmltcG9ydCB7IHJlZHVjZVNjaGVtYSB9IGZyb20gXCIuL2xpYi9yZWR1Y2VTY2hlbWFcIjtcbmltcG9ydCB7IHJlc29sdmVEeW5hbWljU2NoZW1hLCBpc0R5bmFtaWNTY2hlbWEgfSBmcm9tIFwiLi9saWIvcmVzb2x2ZUR5bmFtaWNTY2hlbWFcIjtcbmltcG9ydCB7IG1lcmdlU2NoZW1hIH0gZnJvbSBcIi4vbGliL21lcmdlU2NoZW1hXCI7XG5pbXBvcnQgcmVuZGVyIGZyb20gXCIuL2xpYi91dGlscy9yZW5kZXJcIjtcbmltcG9ydCB7IERyYWZ0IH0gZnJvbSBcIi4vbGliL2RyYWZ0XCI7XG5pbXBvcnQgeyBEcmFmdDA0LCBkcmFmdDA0Q29uZmlnIH0gZnJvbSBcIi4vbGliL2RyYWZ0MDRcIjtcbmltcG9ydCB7IERyYWZ0MDYsIGRyYWZ0MDZDb25maWcgfSBmcm9tIFwiLi9saWIvZHJhZnQwNlwiO1xuaW1wb3J0IHsgRHJhZnQwNywgZHJhZnQwN0NvbmZpZyB9IGZyb20gXCIuL2xpYi9kcmFmdDA3XCI7XG5pbXBvcnQgeyBKc29uRWRpdG9yLCBkcmFmdEpzb25FZGl0b3JDb25maWcgfSBmcm9tIFwiLi9saWIvanNvbmVkaXRvclwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi9saWIvdHlwZXNcIjtcbmNvbnN0IGNvbmZpZyA9IHsgc3RyaW5ncyB9O1xuZXhwb3J0IHsgY29uZmlnLCBjcmVhdGVDdXN0b21FcnJvciwgY3JlYXRlRXJyb3IsIERyYWZ0LCBEcmFmdDA0LCAvLyBjb3JlIGltcGxlbWVudGluZyBkcmFmdDA0IHNwZWNzXG5kcmFmdDA0Q29uZmlnLCAvLyBjb25maWcgaW1wbGVtZW50aW5nIGRyYWZ0MDQgc3BlY3NcbkRyYWZ0MDYsIC8vIGNvcmUgaW1wbGVtZW50aW5nIGRyYWZ0MDYgc3BlY3NcbmRyYWZ0MDZDb25maWcsIC8vIGNvbmZpZyBpbXBsZW1lbnRpbmcgZHJhZnQwNiBzcGVjc1xuRHJhZnQwNywgLy8gY29yZSBpbXBsZW1lbnRpbmcgZHJhZnQwNyBzcGVjc1xuZHJhZnQwN0NvbmZpZywgLy8gY29uZmlnIGltcGxlbWVudGluZyBkcmFmdDA3IHNwZWNzXG5kcmFmdEpzb25FZGl0b3JDb25maWcsIC8vIGFkanVzdGVkIGNvbmZpZyBvZiBkcmFmdDA0IHRvIGJldHRlciBzdXBwb3J0IHRoZSBqc29uLWVkaXRvclxuZ2V0VHlwZU9mLCAvLyByZXR1cm5zIHRoZSBqYXZhc2NyaXB0IGRhdGF0eXBlXG5pc0R5bmFtaWNTY2hlbWEsIC8vIE5FV1xuaXNKc29uRXJyb3IsIEpzb25FZGl0b3IsIC8vIGFkanVzdGVkIGNvcmUgb2YgZHJhZnQwNyB0byBiZXR0ZXIgc3VwcG9ydCB0aGUganNvbi1lZGl0b3Jcbm1lcmdlU2NoZW1hLCAvLyBORVdcbnJlZHVjZVNjaGVtYSwgLy8gTkVXXG5yZW5kZXIsIHJlc29sdmVBbGxPZiwgcmVzb2x2ZUR5bmFtaWNTY2hlbWEsIC8vIE5FV1xucmVzb2x2ZU9uZU9mLCByZXNvbHZlT25lT2ZGdXp6eSwgcmVzb2x2ZVJlZiwgcmVzb2x2ZVJlZk1lcmdlLCBzZXR0aW5ncywgdmFsaWRhdGVBc3luYyAvLyBhc3luYyB2YWxpZGF0aW9uIG9mIGRhdGEgYnkgYSBzY2hlbWFcbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6201\n')},6492:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n// https://www.ics.uci.edu/~pattis/ICS-33/lectures/ebnf.pdf\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = exports.findRuleByName = exports.parseRuleName = exports.escapeRegExp = exports.readToken = void 0;\nconst UPPER_SNAKE_RE = /^[A-Z0-9_]+$/;\nconst decorationRE = /(\\?|\\+|\\*)$/;\nconst preDecorationRE = /^(@|&|!)/;\nconst WS_RULE = 'WS';\nconst TokenError_1 = __webpack_require__(1594);\nfunction readToken(txt, expr) {\n    let result = expr.exec(txt);\n    if (result && result.index == 0) {\n        if (result[0].length == 0 && expr.source.length > 0)\n            return null;\n        return {\n            type: null,\n            text: result[0],\n            rest: txt.substr(result[0].length),\n            start: 0,\n            end: result[0].length - 1,\n            fullText: result[0],\n            errors: [],\n            children: [],\n            parent: null\n        };\n    }\n    return null;\n}\nexports.readToken = readToken;\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nexports.escapeRegExp = escapeRegExp;\nfunction fixRest(token) {\n    token.rest = '';\n    token.children && token.children.forEach(c => fixRest(c));\n}\nfunction fixPositions(token, start) {\n    token.start += start;\n    token.end += start;\n    token.children && token.children.forEach(c => fixPositions(c, token.start));\n}\nfunction agregateErrors(errors, token) {\n    if (token.errors && token.errors.length)\n        token.errors.forEach(err => errors.push(err));\n    token.children && token.children.forEach(tok => agregateErrors(errors, tok));\n}\nfunction parseRuleName(name) {\n    let postDecoration = decorationRE.exec(name);\n    let preDecoration = preDecorationRE.exec(name);\n    let postDecorationText = (postDecoration && postDecoration[0]) || '';\n    let preDecorationText = (preDecoration && preDecoration[0]) || '';\n    let out = {\n        raw: name,\n        name: name.replace(decorationRE, '').replace(preDecorationRE, ''),\n        isOptional: postDecorationText == '?' || postDecorationText == '*',\n        allowRepetition: postDecorationText == '+' || postDecorationText == '*',\n        atLeastOne: postDecorationText == '+',\n        lookupPositive: preDecorationText == '&',\n        lookupNegative: preDecorationText == '!',\n        pinned: preDecorationText == '@',\n        lookup: false,\n        isLiteral: false\n    };\n    out.isLiteral = out.name[0] == \"'\" || out.name[0] == '\"';\n    out.lookup = out.lookupNegative || out.lookupPositive;\n    return out;\n}\nexports.parseRuleName = parseRuleName;\nfunction findRuleByName(name, parser) {\n    let parsed = parseRuleName(name);\n    return parser.cachedRules[parsed.name] || null;\n}\nexports.findRuleByName = findRuleByName;\n/// Removes all the nodes starting with 'RULE_'\nfunction stripRules(token, re) {\n    if (token.children) {\n        let localRules = token.children.filter(x => x.type && re.test(x.type));\n        for (let i = 0; i < localRules.length; i++) {\n            let indexOnChildren = token.children.indexOf(localRules[i]);\n            if (indexOnChildren != -1) {\n                token.children.splice(indexOnChildren, 1);\n            }\n        }\n        token.children.forEach(c => stripRules(c, re));\n    }\n}\nconst ignoreMissingRules = ['EOF'];\nclass Parser {\n    constructor(grammarRules, options) {\n        this.grammarRules = grammarRules;\n        this.options = options;\n        this.cachedRules = {};\n        this.debug = options ? options.debug === true : false;\n        let errors = [];\n        let neededRules = [];\n        grammarRules.forEach(rule => {\n            let parsedName = parseRuleName(rule.name);\n            if (parsedName.name in this.cachedRules) {\n                errors.push('Duplicated rule ' + parsedName.name);\n                return;\n            }\n            else {\n                this.cachedRules[parsedName.name] = rule;\n            }\n            if (!rule.bnf || !rule.bnf.length) {\n                let error = 'Missing rule content, rule: ' + rule.name;\n                if (errors.indexOf(error) == -1)\n                    errors.push(error);\n            }\n            else {\n                rule.bnf.forEach(options => {\n                    if (typeof options[0] === 'string') {\n                        let parsed = parseRuleName(options[0]);\n                        if (parsed.name == rule.name) {\n                            let error = 'Left recursion is not allowed, rule: ' + rule.name;\n                            if (errors.indexOf(error) == -1)\n                                errors.push(error);\n                        }\n                    }\n                    options.forEach(option => {\n                        if (typeof option == 'string') {\n                            let name = parseRuleName(option);\n                            if (!name.isLiteral &&\n                                neededRules.indexOf(name.name) == -1 &&\n                                ignoreMissingRules.indexOf(name.name) == -1)\n                                neededRules.push(name.name);\n                        }\n                    });\n                });\n            }\n            if (WS_RULE == rule.name)\n                rule.implicitWs = false;\n            if (rule.implicitWs) {\n                if (neededRules.indexOf(WS_RULE) == -1)\n                    neededRules.push(WS_RULE);\n            }\n            if (rule.recover) {\n                if (neededRules.indexOf(rule.recover) == -1)\n                    neededRules.push(rule.recover);\n            }\n        });\n        neededRules.forEach(ruleName => {\n            if (!(ruleName in this.cachedRules)) {\n                errors.push('Missing rule ' + ruleName);\n            }\n        });\n        if (errors.length)\n            throw new Error(errors.join('\\n'));\n    }\n    getAST(txt, target) {\n        if (!target) {\n            target = this.grammarRules.filter(x => !x.fragment && x.name.indexOf('%') != 0)[0].name;\n        }\n        let result = this.parse(txt, target);\n        if (result) {\n            agregateErrors(result.errors, result);\n            fixPositions(result, 0);\n            // REMOVE ALL THE TAGS MATCHING /^%/\n            stripRules(result, /^%/);\n            if (!this.options || !this.options.keepUpperRules)\n                stripRules(result, UPPER_SNAKE_RE);\n            let rest = result.rest;\n            if (rest) {\n                new TokenError_1.TokenError('Unexpected end of input: \\n' + rest, result);\n            }\n            fixRest(result);\n            result.rest = rest;\n        }\n        return result;\n    }\n    emitSource() {\n        return 'CANNOT EMIT SOURCE FROM BASE Parser';\n    }\n    parse(txt, target, recursion = 0) {\n        let out = null;\n        let type = parseRuleName(target);\n        let expr;\n        let printable = this.debug && /*!isLiteral &*/ !UPPER_SNAKE_RE.test(type.name);\n        printable &&\n            console.log(new Array(recursion).join('\u2502  ') + 'Trying to get ' + target + ' from ' + JSON.stringify(txt.split('\\n')[0]));\n        let realType = type.name;\n        let targetLex = findRuleByName(type.name, this);\n        if (type.name == 'EOF') {\n            if (txt.length) {\n                return null;\n            }\n            else if (txt.length == 0) {\n                return {\n                    type: 'EOF',\n                    text: '',\n                    rest: '',\n                    start: 0,\n                    end: 0,\n                    fullText: '',\n                    errors: [],\n                    children: [],\n                    parent: null\n                };\n            }\n        }\n        try {\n            if (!targetLex && type.isLiteral) {\n                let src = type.name.trim();\n                if (src.startsWith('\"')) {\n                    src = JSON.parse(src);\n                }\n                else if (src.startsWith(\"'\")) {\n                    src = src.replace(/^'(.+)'$/, '$1').replace(/\\\\'/g, \"'\");\n                }\n                if (src === '') {\n                    return {\n                        type: '%%EMPTY%%',\n                        text: '',\n                        rest: txt,\n                        start: 0,\n                        end: 0,\n                        fullText: '',\n                        errors: [],\n                        children: [],\n                        parent: null\n                    };\n                }\n                expr = new RegExp(escapeRegExp(src));\n                realType = null;\n            }\n        }\n        catch (e) {\n            if (e instanceof ReferenceError) {\n                console.error(e);\n            }\n            return null;\n        }\n        if (expr) {\n            let result = readToken(txt, expr);\n            if (result) {\n                result.type = realType;\n                return result;\n            }\n        }\n        else {\n            let options = targetLex.bnf;\n            if (options instanceof Array) {\n                options.forEach(phases => {\n                    if (out)\n                        return;\n                    let pinned = null;\n                    let tmp = {\n                        type: type.name,\n                        text: '',\n                        children: [],\n                        end: 0,\n                        errors: [],\n                        fullText: '',\n                        parent: null,\n                        start: 0,\n                        rest: txt\n                    };\n                    if (targetLex.fragment)\n                        tmp.fragment = true;\n                    let tmpTxt = txt;\n                    let position = 0;\n                    let allOptional = phases.length > 0;\n                    let foundSomething = false;\n                    for (let i = 0; i < phases.length; i++) {\n                        if (typeof phases[i] == 'string') {\n                            let localTarget = parseRuleName(phases[i]);\n                            allOptional = allOptional && localTarget.isOptional;\n                            let got;\n                            let foundAtLeastOne = false;\n                            do {\n                                got = null;\n                                if (targetLex.implicitWs) {\n                                    got = this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                    if (!got) {\n                                        let WS;\n                                        do {\n                                            WS = this.parse(tmpTxt, WS_RULE, recursion + 1);\n                                            if (WS) {\n                                                tmp.text = tmp.text + WS.text;\n                                                tmp.end = tmp.text.length;\n                                                WS.parent = tmp;\n                                                tmp.children.push(WS);\n                                                tmpTxt = tmpTxt.substr(WS.text.length);\n                                                position += WS.text.length;\n                                            }\n                                            else {\n                                                break;\n                                            }\n                                        } while (WS && WS.text.length);\n                                    }\n                                }\n                                got = got || this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                // rule ::= \"true\" ![a-zA-Z]\n                                // negative lookup, if it does not match, we should continue\n                                if (localTarget.lookupNegative) {\n                                    if (got)\n                                        return /* cancel this path */;\n                                    break;\n                                }\n                                if (localTarget.lookupPositive) {\n                                    if (!got)\n                                        return;\n                                }\n                                if (!got) {\n                                    if (localTarget.isOptional)\n                                        break;\n                                    if (localTarget.atLeastOne && foundAtLeastOne)\n                                        break;\n                                }\n                                if (got && targetLex.pinned == i + 1) {\n                                    pinned = got;\n                                    printable && console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514\u2500 ' + got.type + ' PINNED');\n                                }\n                                if (!got)\n                                    got = this.parseRecovery(targetLex, tmpTxt, recursion + 1);\n                                if (!got) {\n                                    if (pinned) {\n                                        out = tmp;\n                                        got = {\n                                            type: 'SyntaxError',\n                                            text: tmpTxt,\n                                            children: [],\n                                            end: tmpTxt.length,\n                                            errors: [],\n                                            fullText: '',\n                                            parent: null,\n                                            start: 0,\n                                            rest: ''\n                                        };\n                                        if (tmpTxt.length) {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Expecting ${localTarget.name} Got: ${tmpTxt}`, got);\n                                        }\n                                        else {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Missing ${localTarget.name}`, got);\n                                        }\n                                        printable &&\n                                            console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514\u2500 ' + got.type + ' ' + JSON.stringify(got.text));\n                                    }\n                                    else {\n                                        return;\n                                    }\n                                }\n                                foundAtLeastOne = true;\n                                foundSomething = true;\n                                if (got.type == '%%EMPTY%%') {\n                                    break;\n                                }\n                                got.start += position;\n                                got.end += position;\n                                if (!localTarget.lookupPositive && got.type) {\n                                    if (got.fragment) {\n                                        got.children &&\n                                            got.children.forEach(x => {\n                                                x.start += position;\n                                                x.end += position;\n                                                x.parent = tmp;\n                                                tmp.children.push(x);\n                                            });\n                                    }\n                                    else {\n                                        got.parent = tmp;\n                                        tmp.children.push(got);\n                                    }\n                                }\n                                if (localTarget.lookup)\n                                    got.lookup = true;\n                                printable &&\n                                    console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514\u2500 ' + got.type + ' ' + JSON.stringify(got.text));\n                                // Eat it from the input stream, only if it is not a lookup\n                                if (!localTarget.lookup && !got.lookup) {\n                                    tmp.text = tmp.text + got.text;\n                                    tmp.end = tmp.text.length;\n                                    tmpTxt = tmpTxt.substr(got.text.length);\n                                    position += got.text.length;\n                                }\n                                tmp.rest = tmpTxt;\n                            } while (got && localTarget.allowRepetition && tmpTxt.length && !got.lookup);\n                        } /* IS A REGEXP */\n                        else {\n                            let got = readToken(tmpTxt, phases[i]);\n                            if (!got) {\n                                return;\n                            }\n                            printable &&\n                                console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514> ' + JSON.stringify(got.text) + phases[i].source);\n                            foundSomething = true;\n                            got.start += position;\n                            got.end += position;\n                            tmp.text = tmp.text + got.text;\n                            tmp.end = tmp.text.length;\n                            tmpTxt = tmpTxt.substr(got.text.length);\n                            position += got.text.length;\n                            tmp.rest = tmpTxt;\n                        }\n                    }\n                    if (foundSomething) {\n                        out = tmp;\n                        printable &&\n                            console.log(new Array(recursion).join('\u2502  ') + '\u251c<\u2500\u2534< PUSHING ' + out.type + ' ' + JSON.stringify(out.text));\n                    }\n                });\n            }\n            if (out && targetLex.simplifyWhenOneChildren && out.children.length == 1) {\n                out = out.children[0];\n            }\n        }\n        if (!out) {\n            printable && console.log(target + ' NOT RESOLVED FROM ' + txt);\n        }\n        return out;\n    }\n    parseRecovery(recoverableToken, tmpTxt, recursion) {\n        if (recoverableToken.recover && tmpTxt.length) {\n            let printable = this.debug;\n            printable &&\n                console.log(new Array(recursion + 1).join('\u2502  ') +\n                    'Trying to recover until token ' +\n                    recoverableToken.recover +\n                    ' from ' +\n                    JSON.stringify(tmpTxt.split('\\n')[0] + tmpTxt.split('\\n')[1]));\n            let tmp = {\n                type: 'SyntaxError',\n                text: '',\n                children: [],\n                end: 0,\n                errors: [],\n                fullText: '',\n                parent: null,\n                start: 0,\n                rest: ''\n            };\n            let got;\n            do {\n                got = this.parse(tmpTxt, recoverableToken.recover, recursion + 1);\n                if (got) {\n                    new TokenError_1.TokenError('Unexpected input: \"' + tmp.text + `\" Expecting: ${recoverableToken.name}`, tmp);\n                    break;\n                }\n                else {\n                    tmp.text = tmp.text + tmpTxt[0];\n                    tmp.end = tmp.text.length;\n                    tmpTxt = tmpTxt.substr(1);\n                }\n            } while (!got && tmpTxt.length > 0);\n            if (tmp.text.length > 0 && got) {\n                printable && console.log(new Array(recursion + 1).join('\u2502  ') + 'Recovered text: ' + JSON.stringify(tmp.text));\n                return tmp;\n            }\n        }\n        return null;\n    }\n}\nexports.Parser = Parser;\nexports[\"default\"] = Parser;\n//# sourceMappingURL=Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxJQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxrQkFBa0IsT0FBTyxPQUFPO0FBQzlJO0FBQ0E7QUFDQSw0R0FBNEcsaUJBQWlCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxzQkFBc0I7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VibmYvZGlzdC9QYXJzZXIuanM/OGE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIGh0dHBzOi8vd3d3Lmljcy51Y2kuZWR1L35wYXR0aXMvSUNTLTMzL2xlY3R1cmVzL2VibmYucGRmXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnNlciA9IGV4cG9ydHMuZmluZFJ1bGVCeU5hbWUgPSBleHBvcnRzLnBhcnNlUnVsZU5hbWUgPSBleHBvcnRzLmVzY2FwZVJlZ0V4cCA9IGV4cG9ydHMucmVhZFRva2VuID0gdm9pZCAwO1xuY29uc3QgVVBQRVJfU05BS0VfUkUgPSAvXltBLVowLTlfXSskLztcbmNvbnN0IGRlY29yYXRpb25SRSA9IC8oXFw/fFxcK3xcXCopJC87XG5jb25zdCBwcmVEZWNvcmF0aW9uUkUgPSAvXihAfCZ8ISkvO1xuY29uc3QgV1NfUlVMRSA9ICdXUyc7XG5jb25zdCBUb2tlbkVycm9yXzEgPSByZXF1aXJlKFwiLi9Ub2tlbkVycm9yXCIpO1xuZnVuY3Rpb24gcmVhZFRva2VuKHR4dCwgZXhwcikge1xuICAgIGxldCByZXN1bHQgPSBleHByLmV4ZWModHh0KTtcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5pbmRleCA9PSAwKSB7XG4gICAgICAgIGlmIChyZXN1bHRbMF0ubGVuZ3RoID09IDAgJiYgZXhwci5zb3VyY2UubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIHRleHQ6IHJlc3VsdFswXSxcbiAgICAgICAgICAgIHJlc3Q6IHR4dC5zdWJzdHIocmVzdWx0WzBdLmxlbmd0aCksXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogcmVzdWx0WzBdLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBmdWxsVGV4dDogcmVzdWx0WzBdLFxuICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMucmVhZFRva2VuID0gcmVhZFRva2VuO1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbn1cbmV4cG9ydHMuZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuZnVuY3Rpb24gZml4UmVzdCh0b2tlbikge1xuICAgIHRva2VuLnJlc3QgPSAnJztcbiAgICB0b2tlbi5jaGlsZHJlbiAmJiB0b2tlbi5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gZml4UmVzdChjKSk7XG59XG5mdW5jdGlvbiBmaXhQb3NpdGlvbnModG9rZW4sIHN0YXJ0KSB7XG4gICAgdG9rZW4uc3RhcnQgKz0gc3RhcnQ7XG4gICAgdG9rZW4uZW5kICs9IHN0YXJ0O1xuICAgIHRva2VuLmNoaWxkcmVuICYmIHRva2VuLmNoaWxkcmVuLmZvckVhY2goYyA9PiBmaXhQb3NpdGlvbnMoYywgdG9rZW4uc3RhcnQpKTtcbn1cbmZ1bmN0aW9uIGFncmVnYXRlRXJyb3JzKGVycm9ycywgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4uZXJyb3JzICYmIHRva2VuLmVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRva2VuLmVycm9ycy5mb3JFYWNoKGVyciA9PiBlcnJvcnMucHVzaChlcnIpKTtcbiAgICB0b2tlbi5jaGlsZHJlbiAmJiB0b2tlbi5jaGlsZHJlbi5mb3JFYWNoKHRvayA9PiBhZ3JlZ2F0ZUVycm9ycyhlcnJvcnMsIHRvaykpO1xufVxuZnVuY3Rpb24gcGFyc2VSdWxlTmFtZShuYW1lKSB7XG4gICAgbGV0IHBvc3REZWNvcmF0aW9uID0gZGVjb3JhdGlvblJFLmV4ZWMobmFtZSk7XG4gICAgbGV0IHByZURlY29yYXRpb24gPSBwcmVEZWNvcmF0aW9uUkUuZXhlYyhuYW1lKTtcbiAgICBsZXQgcG9zdERlY29yYXRpb25UZXh0ID0gKHBvc3REZWNvcmF0aW9uICYmIHBvc3REZWNvcmF0aW9uWzBdKSB8fCAnJztcbiAgICBsZXQgcHJlRGVjb3JhdGlvblRleHQgPSAocHJlRGVjb3JhdGlvbiAmJiBwcmVEZWNvcmF0aW9uWzBdKSB8fCAnJztcbiAgICBsZXQgb3V0ID0ge1xuICAgICAgICByYXc6IG5hbWUsXG4gICAgICAgIG5hbWU6IG5hbWUucmVwbGFjZShkZWNvcmF0aW9uUkUsICcnKS5yZXBsYWNlKHByZURlY29yYXRpb25SRSwgJycpLFxuICAgICAgICBpc09wdGlvbmFsOiBwb3N0RGVjb3JhdGlvblRleHQgPT0gJz8nIHx8IHBvc3REZWNvcmF0aW9uVGV4dCA9PSAnKicsXG4gICAgICAgIGFsbG93UmVwZXRpdGlvbjogcG9zdERlY29yYXRpb25UZXh0ID09ICcrJyB8fCBwb3N0RGVjb3JhdGlvblRleHQgPT0gJyonLFxuICAgICAgICBhdExlYXN0T25lOiBwb3N0RGVjb3JhdGlvblRleHQgPT0gJysnLFxuICAgICAgICBsb29rdXBQb3NpdGl2ZTogcHJlRGVjb3JhdGlvblRleHQgPT0gJyYnLFxuICAgICAgICBsb29rdXBOZWdhdGl2ZTogcHJlRGVjb3JhdGlvblRleHQgPT0gJyEnLFxuICAgICAgICBwaW5uZWQ6IHByZURlY29yYXRpb25UZXh0ID09ICdAJyxcbiAgICAgICAgbG9va3VwOiBmYWxzZSxcbiAgICAgICAgaXNMaXRlcmFsOiBmYWxzZVxuICAgIH07XG4gICAgb3V0LmlzTGl0ZXJhbCA9IG91dC5uYW1lWzBdID09IFwiJ1wiIHx8IG91dC5uYW1lWzBdID09ICdcIic7XG4gICAgb3V0Lmxvb2t1cCA9IG91dC5sb29rdXBOZWdhdGl2ZSB8fCBvdXQubG9va3VwUG9zaXRpdmU7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMucGFyc2VSdWxlTmFtZSA9IHBhcnNlUnVsZU5hbWU7XG5mdW5jdGlvbiBmaW5kUnVsZUJ5TmFtZShuYW1lLCBwYXJzZXIpIHtcbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSdWxlTmFtZShuYW1lKTtcbiAgICByZXR1cm4gcGFyc2VyLmNhY2hlZFJ1bGVzW3BhcnNlZC5uYW1lXSB8fCBudWxsO1xufVxuZXhwb3J0cy5maW5kUnVsZUJ5TmFtZSA9IGZpbmRSdWxlQnlOYW1lO1xuLy8vIFJlbW92ZXMgYWxsIHRoZSBub2RlcyBzdGFydGluZyB3aXRoICdSVUxFXydcbmZ1bmN0aW9uIHN0cmlwUnVsZXModG9rZW4sIHJlKSB7XG4gICAgaWYgKHRva2VuLmNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBsb2NhbFJ1bGVzID0gdG9rZW4uY2hpbGRyZW4uZmlsdGVyKHggPT4geC50eXBlICYmIHJlLnRlc3QoeC50eXBlKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4T25DaGlsZHJlbiA9IHRva2VuLmNoaWxkcmVuLmluZGV4T2YobG9jYWxSdWxlc1tpXSk7XG4gICAgICAgICAgICBpZiAoaW5kZXhPbkNoaWxkcmVuICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4uY2hpbGRyZW4uc3BsaWNlKGluZGV4T25DaGlsZHJlbiwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4uY2hpbGRyZW4uZm9yRWFjaChjID0+IHN0cmlwUnVsZXMoYywgcmUpKTtcbiAgICB9XG59XG5jb25zdCBpZ25vcmVNaXNzaW5nUnVsZXMgPSBbJ0VPRiddO1xuY2xhc3MgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihncmFtbWFyUnVsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ncmFtbWFyUnVsZXMgPSBncmFtbWFyUnVsZXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FjaGVkUnVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMgPyBvcHRpb25zLmRlYnVnID09PSB0cnVlIDogZmFsc2U7XG4gICAgICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICAgICAgbGV0IG5lZWRlZFJ1bGVzID0gW107XG4gICAgICAgIGdyYW1tYXJSdWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcnNlZE5hbWUgPSBwYXJzZVJ1bGVOYW1lKHJ1bGUubmFtZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkTmFtZS5uYW1lIGluIHRoaXMuY2FjaGVkUnVsZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCgnRHVwbGljYXRlZCBydWxlICcgKyBwYXJzZWROYW1lLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkUnVsZXNbcGFyc2VkTmFtZS5uYW1lXSA9IHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJ1bGUuYm5mIHx8ICFydWxlLmJuZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSAnTWlzc2luZyBydWxlIGNvbnRlbnQsIHJ1bGU6ICcgKyBydWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5pbmRleE9mKGVycm9yKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZS5ibmYuZm9yRWFjaChvcHRpb25zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZCA9IHBhcnNlUnVsZU5hbWUob3B0aW9uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLm5hbWUgPT0gcnVsZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yID0gJ0xlZnQgcmVjdXJzaW9uIGlzIG5vdCBhbGxvd2VkLCBydWxlOiAnICsgcnVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMuaW5kZXhPZihlcnJvcikgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBwYXJzZVJ1bGVOYW1lKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lLmlzTGl0ZXJhbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkZWRSdWxlcy5pbmRleE9mKG5hbWUubmFtZSkgPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlTWlzc2luZ1J1bGVzLmluZGV4T2YobmFtZS5uYW1lKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZGVkUnVsZXMucHVzaChuYW1lLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChXU19SVUxFID09IHJ1bGUubmFtZSlcbiAgICAgICAgICAgICAgICBydWxlLmltcGxpY2l0V3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChydWxlLmltcGxpY2l0V3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZGVkUnVsZXMuaW5kZXhPZihXU19SVUxFKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgbmVlZGVkUnVsZXMucHVzaChXU19SVUxFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydWxlLnJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZGVkUnVsZXMuaW5kZXhPZihydWxlLnJlY292ZXIpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBuZWVkZWRSdWxlcy5wdXNoKHJ1bGUucmVjb3Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBuZWVkZWRSdWxlcy5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICAgICAgICAgIGlmICghKHJ1bGVOYW1lIGluIHRoaXMuY2FjaGVkUnVsZXMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goJ01pc3NpbmcgcnVsZSAnICsgcnVsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICB9XG4gICAgZ2V0QVNUKHR4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmdyYW1tYXJSdWxlcy5maWx0ZXIoeCA9PiAheC5mcmFnbWVudCAmJiB4Lm5hbWUuaW5kZXhPZignJScpICE9IDApWzBdLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2UodHh0LCB0YXJnZXQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBhZ3JlZ2F0ZUVycm9ycyhyZXN1bHQuZXJyb3JzLCByZXN1bHQpO1xuICAgICAgICAgICAgZml4UG9zaXRpb25zKHJlc3VsdCwgMCk7XG4gICAgICAgICAgICAvLyBSRU1PVkUgQUxMIFRIRSBUQUdTIE1BVENISU5HIC9eJS9cbiAgICAgICAgICAgIHN0cmlwUnVsZXMocmVzdWx0LCAvXiUvKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zIHx8ICF0aGlzLm9wdGlvbnMua2VlcFVwcGVyUnVsZXMpXG4gICAgICAgICAgICAgICAgc3RyaXBSdWxlcyhyZXN1bHQsIFVQUEVSX1NOQUtFX1JFKTtcbiAgICAgICAgICAgIGxldCByZXN0ID0gcmVzdWx0LnJlc3Q7XG4gICAgICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgICAgIG5ldyBUb2tlbkVycm9yXzEuVG9rZW5FcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQ6IFxcbicgKyByZXN0LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZml4UmVzdChyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnJlc3QgPSByZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVtaXRTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAnQ0FOTk9UIEVNSVQgU09VUkNFIEZST00gQkFTRSBQYXJzZXInO1xuICAgIH1cbiAgICBwYXJzZSh0eHQsIHRhcmdldCwgcmVjdXJzaW9uID0gMCkge1xuICAgICAgICBsZXQgb3V0ID0gbnVsbDtcbiAgICAgICAgbGV0IHR5cGUgPSBwYXJzZVJ1bGVOYW1lKHRhcmdldCk7XG4gICAgICAgIGxldCBleHByO1xuICAgICAgICBsZXQgcHJpbnRhYmxlID0gdGhpcy5kZWJ1ZyAmJiAvKiFpc0xpdGVyYWwgJiovICFVUFBFUl9TTkFLRV9SRS50ZXN0KHR5cGUubmFtZSk7XG4gICAgICAgIHByaW50YWJsZSAmJlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3IEFycmF5KHJlY3Vyc2lvbikuam9pbign4pSCICAnKSArICdUcnlpbmcgdG8gZ2V0ICcgKyB0YXJnZXQgKyAnIGZyb20gJyArIEpTT04uc3RyaW5naWZ5KHR4dC5zcGxpdCgnXFxuJylbMF0pKTtcbiAgICAgICAgbGV0IHJlYWxUeXBlID0gdHlwZS5uYW1lO1xuICAgICAgICBsZXQgdGFyZ2V0TGV4ID0gZmluZFJ1bGVCeU5hbWUodHlwZS5uYW1lLCB0aGlzKTtcbiAgICAgICAgaWYgKHR5cGUubmFtZSA9PSAnRU9GJykge1xuICAgICAgICAgICAgaWYgKHR4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR4dC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFT0YnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdDogJycsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxUZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldExleCAmJiB0eXBlLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGxldCBzcmMgPSB0eXBlLm5hbWUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBKU09OLnBhcnNlKHNyYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNyYy5zdGFydHNXaXRoKFwiJ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXicoLispJyQvLCAnJDEnKS5yZXBsYWNlKC9cXFxcJy9nLCBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcmMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnJSVFTVBUWSUlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdDogdHh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsVGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChzcmMpKTtcbiAgICAgICAgICAgICAgICByZWFsVHlwZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSByZWFkVG9rZW4odHh0LCBleHByKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSA9IHJlYWxUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHRhcmdldExleC5ibmY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKHBoYXNlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaW5uZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG1wID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0OiB0eHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldExleC5mcmFnbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5mcmFnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0bXBUeHQgPSB0eHQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGxPcHRpb25hbCA9IHBoYXNlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaGFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGhhc2VzW2ldID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsVGFyZ2V0ID0gcGFyc2VSdWxlTmFtZShwaGFzZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbE9wdGlvbmFsID0gYWxsT3B0aW9uYWwgJiYgbG9jYWxUYXJnZXQuaXNPcHRpb25hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ290O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEF0TGVhc3RPbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRMZXguaW1wbGljaXRXcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ290ID0gdGhpcy5wYXJzZSh0bXBUeHQsIGxvY2FsVGFyZ2V0Lm5hbWUsIHJlY3Vyc2lvbiArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgV1M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXUyA9IHRoaXMucGFyc2UodG1wVHh0LCBXU19SVUxFLCByZWN1cnNpb24gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFdTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAudGV4dCA9IHRtcC50ZXh0ICsgV1MudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5lbmQgPSB0bXAudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXUy5wYXJlbnQgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAuY2hpbGRyZW4ucHVzaChXUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUeHQgPSB0bXBUeHQuc3Vic3RyKFdTLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IFdTLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChXUyAmJiBXUy50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ290ID0gZ290IHx8IHRoaXMucGFyc2UodG1wVHh0LCBsb2NhbFRhcmdldC5uYW1lLCByZWN1cnNpb24gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVsZSA6Oj0gXCJ0cnVlXCIgIVthLXpBLVpdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIGxvb2t1cCwgaWYgaXQgZG9lcyBub3QgbWF0Y2gsIHdlIHNob3VsZCBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUYXJnZXQubG9va3VwTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnb3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGNhbmNlbCB0aGlzIHBhdGggKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUYXJnZXQubG9va3VwUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ290KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVGFyZ2V0LmlzT3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUYXJnZXQuYXRMZWFzdE9uZSAmJiBmb3VuZEF0TGVhc3RPbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdvdCAmJiB0YXJnZXRMZXgucGlubmVkID09IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWQgPSBnb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludGFibGUgJiYgY29uc29sZS5sb2cobmV3IEFycmF5KHJlY3Vyc2lvbiArIDEpLmpvaW4oJ+KUgiAgJykgKyAn4pSU4pSAICcgKyBnb3QudHlwZSArICcgUElOTkVEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnb3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb3QgPSB0aGlzLnBhcnNlUmVjb3ZlcnkodGFyZ2V0TGV4LCB0bXBUeHQsIHJlY3Vyc2lvbiArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTeW50YXhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRtcFR4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRtcFR4dC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxUZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdDogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBUeHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUb2tlbkVycm9yXzEuVG9rZW5FcnJvcihgVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuIEV4cGVjdGluZyAke2xvY2FsVGFyZ2V0Lm5hbWV9IEdvdDogJHt0bXBUeHR9YCwgZ290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUb2tlbkVycm9yXzEuVG9rZW5FcnJvcihgVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuIE1pc3NpbmcgJHtsb2NhbFRhcmdldC5uYW1lfWAsIGdvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50YWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuZXcgQXJyYXkocmVjdXJzaW9uICsgMSkuam9pbign4pSCICAnKSArICfilJTilIAgJyArIGdvdC50eXBlICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoZ290LnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEF0TGVhc3RPbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnb3QudHlwZSA9PSAnJSVFTVBUWSUlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ290LnN0YXJ0ICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb3QuZW5kICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsVGFyZ2V0Lmxvb2t1cFBvc2l0aXZlICYmIGdvdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ290LmZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ290LmNoaWxkcmVuICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvdC5jaGlsZHJlbi5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5zdGFydCArPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZW5kICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAuY2hpbGRyZW4ucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb3QucGFyZW50ID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5jaGlsZHJlbi5wdXNoKGdvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVGFyZ2V0Lmxvb2t1cClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvdC5sb29rdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ldyBBcnJheShyZWN1cnNpb24gKyAxKS5qb2luKCfilIIgICcpICsgJ+KUlOKUgCAnICsgZ290LnR5cGUgKyAnICcgKyBKU09OLnN0cmluZ2lmeShnb3QudGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFYXQgaXQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCBvbmx5IGlmIGl0IGlzIG5vdCBhIGxvb2t1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsVGFyZ2V0Lmxvb2t1cCAmJiAhZ290Lmxvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnRleHQgPSB0bXAudGV4dCArIGdvdC50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLmVuZCA9IHRtcC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFR4dCA9IHRtcFR4dC5zdWJzdHIoZ290LnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGdvdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucmVzdCA9IHRtcFR4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChnb3QgJiYgbG9jYWxUYXJnZXQuYWxsb3dSZXBldGl0aW9uICYmIHRtcFR4dC5sZW5ndGggJiYgIWdvdC5sb29rdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvKiBJUyBBIFJFR0VYUCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdvdCA9IHJlYWRUb2tlbih0bXBUeHQsIHBoYXNlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobmV3IEFycmF5KHJlY3Vyc2lvbiArIDEpLmpvaW4oJ+KUgiAgJykgKyAn4pSUPiAnICsgSlNPTi5zdHJpbmdpZnkoZ290LnRleHQpICsgcGhhc2VzW2ldLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvdC5zdGFydCArPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb3QuZW5kICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC50ZXh0ID0gdG1wLnRleHQgKyBnb3QudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAuZW5kID0gdG1wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFR4dCA9IHRtcFR4dC5zdWJzdHIoZ290LnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBnb3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnJlc3QgPSB0bXBUeHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU29tZXRoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuZXcgQXJyYXkocmVjdXJzaW9uKS5qb2luKCfilIIgICcpICsgJ+KUnDzilIDilLQ8IFBVU0hJTkcgJyArIG91dC50eXBlICsgJyAnICsgSlNPTi5zdHJpbmdpZnkob3V0LnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dCAmJiB0YXJnZXRMZXguc2ltcGxpZnlXaGVuT25lQ2hpbGRyZW4gJiYgb3V0LmNoaWxkcmVuLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgb3V0ID0gb3V0LmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3V0KSB7XG4gICAgICAgICAgICBwcmludGFibGUgJiYgY29uc29sZS5sb2codGFyZ2V0ICsgJyBOT1QgUkVTT0xWRUQgRlJPTSAnICsgdHh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBwYXJzZVJlY292ZXJ5KHJlY292ZXJhYmxlVG9rZW4sIHRtcFR4dCwgcmVjdXJzaW9uKSB7XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZVRva2VuLnJlY292ZXIgJiYgdG1wVHh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHByaW50YWJsZSA9IHRoaXMuZGVidWc7XG4gICAgICAgICAgICBwcmludGFibGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuZXcgQXJyYXkocmVjdXJzaW9uICsgMSkuam9pbign4pSCICAnKSArXG4gICAgICAgICAgICAgICAgICAgICdUcnlpbmcgdG8gcmVjb3ZlciB1bnRpbCB0b2tlbiAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmFibGVUb2tlbi5yZWNvdmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBmcm9tICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0bXBUeHQuc3BsaXQoJ1xcbicpWzBdICsgdG1wVHh0LnNwbGl0KCdcXG4nKVsxXSkpO1xuICAgICAgICAgICAgbGV0IHRtcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBmdWxsVGV4dDogJycsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIHJlc3Q6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGdvdDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBnb3QgPSB0aGlzLnBhcnNlKHRtcFR4dCwgcmVjb3ZlcmFibGVUb2tlbi5yZWNvdmVyLCByZWN1cnNpb24gKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZ290KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBUb2tlbkVycm9yXzEuVG9rZW5FcnJvcignVW5leHBlY3RlZCBpbnB1dDogXCInICsgdG1wLnRleHQgKyBgXCIgRXhwZWN0aW5nOiAke3JlY292ZXJhYmxlVG9rZW4ubmFtZX1gLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcC50ZXh0ID0gdG1wLnRleHQgKyB0bXBUeHRbMF07XG4gICAgICAgICAgICAgICAgICAgIHRtcC5lbmQgPSB0bXAudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRtcFR4dCA9IHRtcFR4dC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoIWdvdCAmJiB0bXBUeHQubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBpZiAodG1wLnRleHQubGVuZ3RoID4gMCAmJiBnb3QpIHtcbiAgICAgICAgICAgICAgICBwcmludGFibGUgJiYgY29uc29sZS5sb2cobmV3IEFycmF5KHJlY3Vyc2lvbiArIDEpLmpvaW4oJ+KUgiAgJykgKyAnUmVjb3ZlcmVkIHRleHQ6ICcgKyBKU09OLnN0cmluZ2lmeSh0bXAudGV4dCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6492\n")},6782:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n\n// https://www.w3.org/TR/REC-xml/#NT-Name\n// http://www.bottlecaps.de/rr/ui\n__webpack_unused_export__ = ({ value: true });\n// Grammar\t::=\tProduction*\n// Production\t::=\tNCName '::=' Choice\n// NCName\t::=\t[http://www.w3.org/TR/xml-names/#NT-NCName]\n// Choice\t::=\tSequenceOrDifference ( '|' SequenceOrDifference )*\n// SequenceOrDifference\t::=\t(Item ( '-' Item | Item* ))?\n// Item\t::=\tPrimary ( '?' | '*' | '+' )?\n// Primary\t::=\tNCName | StringLiteral | CharCode | CharClass | '(' Choice ')'\n// StringLiteral\t::=\t'\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n// CharCode\t::=\t'#x' [0-9a-fA-F]+\n// CharClass\t::=\t'[' '^'? ( RULE_Char | CharCode | CharRange | CharCodeRange )+ ']'\n// RULE_Char\t::=\t[http://www.w3.org/TR/xml#NT-RULE_Char]\n// CharRange\t::=\tRULE_Char '-' ( RULE_Char - ']' )\n// CharCodeRange\t::=\tCharCode '-' CharCode\n// RULE_WHITESPACE\t::=\tRULE_S | Comment\n// RULE_S\t::=\t#x9 | #xA | #xD | #x20\n// Comment\t::=\t'/*' ( [^*] | '*'+ [^*/] )* '*'* '*/'\nconst Parser_1 = __webpack_require__(6492);\nvar BNF;\n(function (BNF) {\n    BNF.RULES = [\n        {\n            name: 'Grammar',\n            bnf: [['RULE_S*', '%Atomic*', 'EOF']]\n        },\n        {\n            name: '%Atomic',\n            bnf: [['Production', 'RULE_S*']],\n            fragment: true\n        },\n        {\n            name: 'Production',\n            bnf: [['NCName', 'RULE_S*', '\"::=\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', 'RULE_EOL+', 'RULE_S*']]\n        },\n        {\n            name: 'NCName',\n            bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]\n        },\n        {\n            name: 'Choice',\n            bnf: [['SequenceOrDifference', '%_Choice_1*']],\n            fragment: true\n        },\n        {\n            name: '%_Choice_1',\n            bnf: [['RULE_WHITESPACE*', '\"|\"', 'RULE_WHITESPACE*', 'SequenceOrDifference']],\n            fragment: true\n        },\n        {\n            name: 'SequenceOrDifference',\n            bnf: [['Item', 'RULE_WHITESPACE*', '%_Item_1?']]\n        },\n        {\n            name: '%_Item_1',\n            bnf: [['Minus', 'Item'], ['Item*']],\n            fragment: true\n        },\n        {\n            name: 'Minus',\n            bnf: [['\"-\"']]\n        },\n        {\n            name: 'Item',\n            bnf: [['RULE_WHITESPACE*', '%Primary', 'PrimaryDecoration?']],\n            fragment: true\n        },\n        {\n            name: 'PrimaryDecoration',\n            bnf: [['\"?\"'], ['\"*\"'], ['\"+\"']]\n        },\n        {\n            name: 'DecorationName',\n            bnf: [['\"ebnf://\"', /[^\\x5D#]+/]]\n        },\n        {\n            name: '%Primary',\n            bnf: [['NCName'], ['StringLiteral'], ['CharCode'], ['CharClass'], ['SubItem']],\n            fragment: true\n        },\n        {\n            name: 'SubItem',\n            bnf: [['\"(\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', '\")\"']]\n        },\n        {\n            name: 'StringLiteral',\n            bnf: [[`'\"'`, /[^\"]*/, `'\"'`], [`\"'\"`, /[^']*/, `\"'\"`]],\n            pinned: 1\n        },\n        {\n            name: 'CharCode',\n            bnf: [['\"#x\"', /[0-9a-zA-Z]+/]]\n        },\n        {\n            name: 'CharClass',\n            bnf: [[\"'['\", \"'^'?\", '%RULE_CharClass_1+', '\"]\"']]\n        },\n        {\n            name: '%RULE_CharClass_1',\n            bnf: [['CharCodeRange'], ['CharRange'], ['CharCode'], ['RULE_Char']],\n            fragment: true\n        },\n        {\n            name: 'RULE_Char',\n            bnf: [[/\\x09/], [/\\x0A/], [/\\x0D/], [/[\\x20-\\x5c]/], [/[\\x5e-\\uD7FF]/], [/[\\uE000-\\uFFFD]/]]\n        },\n        {\n            name: 'CharRange',\n            bnf: [['RULE_Char', '\"-\"', 'RULE_Char']]\n        },\n        {\n            name: 'CharCodeRange',\n            bnf: [['CharCode', '\"-\"', 'CharCode']]\n        },\n        {\n            name: 'RULE_WHITESPACE',\n            bnf: [['%RULE_WHITESPACE_CHAR*'], ['Comment', 'RULE_WHITESPACE*']]\n        },\n        {\n            name: 'RULE_S',\n            bnf: [['RULE_WHITESPACE', 'RULE_S*'], ['RULE_EOL', 'RULE_S*']]\n        },\n        {\n            name: '%RULE_WHITESPACE_CHAR',\n            bnf: [[/\\x09/], [/\\x20/]],\n            fragment: true\n        },\n        {\n            name: 'Comment',\n            bnf: [['\"/*\"', '%RULE_Comment_Body*', '\"*/\"']]\n        },\n        {\n            name: '%RULE_Comment_Body',\n            bnf: [['!\"*/\"', /[^*]/]],\n            fragment: true\n        },\n        {\n            name: 'RULE_EOL',\n            bnf: [[/\\x0D/, /\\x0A/], [/\\x0A/], [/\\x0D/]]\n        },\n        {\n            name: 'Link',\n            bnf: [[\"'['\", 'Url', \"']'\"]]\n        },\n        {\n            name: 'Url',\n            bnf: [[/[^\\x5D:/?#]/, '\"://\"', /[^\\x5D#]+/, '%Url1?']]\n        },\n        {\n            name: '%Url1',\n            bnf: [['\"#\"', 'NCName']],\n            fragment: true\n        }\n    ];\n    BNF.defaultParser = new Parser_1.Parser(BNF.RULES, { debug: false });\n    const preDecorationRE = /^(!|&)/;\n    const decorationRE = /(\\?|\\+|\\*)$/;\n    const subExpressionRE = /^%/;\n    function getBNFRule(name, parser) {\n        if (typeof name == 'string') {\n            if (preDecorationRE.test(name))\n                return '';\n            let subexpression = subExpressionRE.test(name);\n            if (subexpression) {\n                let decoration = decorationRE.exec(name);\n                let decorationText = decoration ? decoration[0] + ' ' : '';\n                let lonely = isLonelyRule(name, parser);\n                if (lonely)\n                    return getBNFBody(name, parser) + decorationText;\n                return '(' + getBNFBody(name, parser) + ')' + decorationText;\n            }\n            return name;\n        }\n        else {\n            return name.source\n                .replace(/\\\\(?:x|u)([a-zA-Z0-9]+)/g, '#x$1')\n                .replace(/\\[\\\\(?:x|u)([a-zA-Z0-9]+)-\\\\(?:x|u)([a-zA-Z0-9]+)\\]/g, '[#x$1-#x$2]');\n        }\n    }\n    /// Returns true if the rule is a string literal or regular expression without a descendant tree\n    function isLonelyRule(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        return (rule &&\n            rule.bnf.length == 1 &&\n            rule.bnf[0].length == 1 &&\n            (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '\"' || rule.bnf[0][0][0] == \"'\"));\n    }\n    function getBNFChoice(rules, parser) {\n        return rules.map(x => getBNFRule(x, parser)).join(' ');\n    }\n    function getBNFBody(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        if (rule)\n            return rule.bnf.map(x => getBNFChoice(x, parser)).join(' | ');\n        return 'RULE_NOT_FOUND {' + name + '}';\n    }\n    function emit(parser) {\n        let acumulator = [];\n        parser.grammarRules.forEach(l => {\n            if (!/^%/.test(l.name)) {\n                let recover = l.recover ? ' /* { recoverUntil=' + l.recover + ' } */' : '';\n                acumulator.push(l.name + ' ::= ' + getBNFBody(l.name, parser) + recover);\n            }\n        });\n        return acumulator.join('\\n');\n    }\n    BNF.emit = emit;\n    let subitems = 0;\n    function restar(total, resta) {\n        console.log('reberia restar ' + resta + ' a ' + total);\n        throw new Error('Difference not supported yet');\n    }\n    function convertRegex(txt) {\n        return new RegExp(txt\n            .replace(/#x([a-zA-Z0-9]{4})/g, '\\\\u$1')\n            .replace(/#x([a-zA-Z0-9]{3})/g, '\\\\u0$1')\n            .replace(/#x([a-zA-Z0-9]{2})/g, '\\\\x$1')\n            .replace(/#x([a-zA-Z0-9]{1})/g, '\\\\x0$1'));\n    }\n    function getSubItems(tmpRules, seq, parentName) {\n        let anterior = null;\n        let bnfSeq = [];\n        seq.children.forEach((x, i) => {\n            if (x.type == 'Minus') {\n                restar(anterior, x);\n            }\n            else {\n            }\n            let decoration = seq.children[i + 1];\n            decoration = (decoration && decoration.type == 'PrimaryDecoration' && decoration.text) || '';\n            let preDecoration = '';\n            switch (x.type) {\n                case 'SubItem':\n                    let name = '%' + (parentName + subitems++);\n                    createRule(tmpRules, x, name);\n                    bnfSeq.push(preDecoration + name + decoration);\n                    break;\n                case 'NCName':\n                case 'StringLiteral':\n                    bnfSeq.push(preDecoration + x.text + decoration);\n                    break;\n                case 'CharCode':\n                case 'CharClass':\n                    if (decoration || preDecoration) {\n                        let newRule = {\n                            name: '%' + (parentName + subitems++),\n                            bnf: [[convertRegex(x.text)]]\n                        };\n                        tmpRules.push(newRule);\n                        bnfSeq.push(preDecoration + newRule.name + decoration);\n                    }\n                    else {\n                        bnfSeq.push(convertRegex(x.text));\n                    }\n                    break;\n                case 'PrimaryDecoration':\n                    break;\n                default:\n                    throw new Error(' HOW SHOULD I PARSE THIS? ' + x.type + ' -> ' + JSON.stringify(x.text));\n            }\n            anterior = x;\n        });\n        return bnfSeq;\n    }\n    function createRule(tmpRules, token, name) {\n        let bnf = token.children.filter(x => x.type == 'SequenceOrDifference').map(s => getSubItems(tmpRules, s, name));\n        let rule = {\n            name,\n            bnf\n        };\n        let recover = null;\n        bnf.forEach(x => {\n            recover = recover || x['recover'];\n            delete x['recover'];\n        });\n        if (name.indexOf('%') == 0)\n            rule.fragment = true;\n        if (recover)\n            rule.recover = recover;\n        tmpRules.push(rule);\n    }\n    function getRules(source, parser = BNF.defaultParser) {\n        let ast = parser.getAST(source);\n        if (!ast)\n            throw new Error('Could not parse ' + source);\n        if (ast.errors && ast.errors.length) {\n            throw ast.errors[0];\n        }\n        let tmpRules = [];\n        ast.children.filter(x => x.type == 'Production').map((x) => {\n            let name = x.children.filter(x => x.type == 'NCName')[0].text;\n            createRule(tmpRules, x, name);\n        });\n        return tmpRules;\n    }\n    BNF.getRules = getRules;\n    function Transform(source, subParser = BNF.defaultParser) {\n        return getRules(source.join(''), subParser);\n    }\n    BNF.Transform = Transform;\n    class Parser extends Parser_1.Parser {\n        constructor(source, options) {\n            const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF.RULES, { debug: true }) : BNF.defaultParser;\n            super(getRules(source, subParser), options);\n        }\n        emitSource() {\n            return emit(this);\n        }\n    }\n    BNF.Parser = Parser;\n})(BNF || (BNF = {}));\nexports.A = BNF;\n//# sourceMappingURL=W3CEBNF.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc4Mi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZDLEVBQUUsYUFBYSxDQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsSUFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFO0FBQ3ZDLHFDQUFxQyxFQUFFO0FBQ3ZDLHFDQUFxQyxFQUFFO0FBQ3ZDLHFDQUFxQyxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxhQUFhO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkIsU0FBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VibmYvZGlzdC9HcmFtbWFycy9XM0NFQk5GLmpzPzcwOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuLy8gaHR0cDovL3d3dy5ib3R0bGVjYXBzLmRlL3JyL3VpXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBHcmFtbWFyXHQ6Oj1cdFByb2R1Y3Rpb24qXG4vLyBQcm9kdWN0aW9uXHQ6Oj1cdE5DTmFtZSAnOjo9JyBDaG9pY2Vcbi8vIE5DTmFtZVx0Ojo9XHRbaHR0cDovL3d3dy53My5vcmcvVFIveG1sLW5hbWVzLyNOVC1OQ05hbWVdXG4vLyBDaG9pY2VcdDo6PVx0U2VxdWVuY2VPckRpZmZlcmVuY2UgKCAnfCcgU2VxdWVuY2VPckRpZmZlcmVuY2UgKSpcbi8vIFNlcXVlbmNlT3JEaWZmZXJlbmNlXHQ6Oj1cdChJdGVtICggJy0nIEl0ZW0gfCBJdGVtKiApKT9cbi8vIEl0ZW1cdDo6PVx0UHJpbWFyeSAoICc/JyB8ICcqJyB8ICcrJyApP1xuLy8gUHJpbWFyeVx0Ojo9XHROQ05hbWUgfCBTdHJpbmdMaXRlcmFsIHwgQ2hhckNvZGUgfCBDaGFyQ2xhc3MgfCAnKCcgQ2hvaWNlICcpJ1xuLy8gU3RyaW5nTGl0ZXJhbFx0Ojo9XHQnXCInIFteXCJdKiAnXCInIHwgXCInXCIgW14nXSogXCInXCJcbi8vIENoYXJDb2RlXHQ6Oj1cdCcjeCcgWzAtOWEtZkEtRl0rXG4vLyBDaGFyQ2xhc3NcdDo6PVx0J1snICdeJz8gKCBSVUxFX0NoYXIgfCBDaGFyQ29kZSB8IENoYXJSYW5nZSB8IENoYXJDb2RlUmFuZ2UgKSsgJ10nXG4vLyBSVUxFX0NoYXJcdDo6PVx0W2h0dHA6Ly93d3cudzMub3JnL1RSL3htbCNOVC1SVUxFX0NoYXJdXG4vLyBDaGFyUmFuZ2VcdDo6PVx0UlVMRV9DaGFyICctJyAoIFJVTEVfQ2hhciAtICddJyApXG4vLyBDaGFyQ29kZVJhbmdlXHQ6Oj1cdENoYXJDb2RlICctJyBDaGFyQ29kZVxuLy8gUlVMRV9XSElURVNQQUNFXHQ6Oj1cdFJVTEVfUyB8IENvbW1lbnRcbi8vIFJVTEVfU1x0Ojo9XHQjeDkgfCAjeEEgfCAjeEQgfCAjeDIwXG4vLyBDb21tZW50XHQ6Oj1cdCcvKicgKCBbXipdIHwgJyonKyBbXiovXSApKiAnKicqICcqLydcbmNvbnN0IFBhcnNlcl8xID0gcmVxdWlyZShcIi4uL1BhcnNlclwiKTtcbnZhciBCTkY7XG4oZnVuY3Rpb24gKEJORikge1xuICAgIEJORi5SVUxFUyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0dyYW1tYXInLFxuICAgICAgICAgICAgYm5mOiBbWydSVUxFX1MqJywgJyVBdG9taWMqJywgJ0VPRiddXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnJUF0b21pYycsXG4gICAgICAgICAgICBibmY6IFtbJ1Byb2R1Y3Rpb24nLCAnUlVMRV9TKiddXSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQcm9kdWN0aW9uJyxcbiAgICAgICAgICAgIGJuZjogW1snTkNOYW1lJywgJ1JVTEVfUyonLCAnXCI6Oj1cIicsICdSVUxFX1dISVRFU1BBQ0UqJywgJ0Nob2ljZScsICdSVUxFX1dISVRFU1BBQ0UqJywgJ1JVTEVfRU9MKycsICdSVUxFX1MqJ11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdOQ05hbWUnLFxuICAgICAgICAgICAgYm5mOiBbWy9bYS16QS1aXVthLXpBLVpfMC05XSovXV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0Nob2ljZScsXG4gICAgICAgICAgICBibmY6IFtbJ1NlcXVlbmNlT3JEaWZmZXJlbmNlJywgJyVfQ2hvaWNlXzEqJ11dLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJyVfQ2hvaWNlXzEnLFxuICAgICAgICAgICAgYm5mOiBbWydSVUxFX1dISVRFU1BBQ0UqJywgJ1wifFwiJywgJ1JVTEVfV0hJVEVTUEFDRSonLCAnU2VxdWVuY2VPckRpZmZlcmVuY2UnXV0sXG4gICAgICAgICAgICBmcmFnbWVudDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU2VxdWVuY2VPckRpZmZlcmVuY2UnLFxuICAgICAgICAgICAgYm5mOiBbWydJdGVtJywgJ1JVTEVfV0hJVEVTUEFDRSonLCAnJV9JdGVtXzE/J11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICclX0l0ZW1fMScsXG4gICAgICAgICAgICBibmY6IFtbJ01pbnVzJywgJ0l0ZW0nXSwgWydJdGVtKiddXSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNaW51cycsXG4gICAgICAgICAgICBibmY6IFtbJ1wiLVwiJ11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJdGVtJyxcbiAgICAgICAgICAgIGJuZjogW1snUlVMRV9XSElURVNQQUNFKicsICclUHJpbWFyeScsICdQcmltYXJ5RGVjb3JhdGlvbj8nXV0sXG4gICAgICAgICAgICBmcmFnbWVudDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUHJpbWFyeURlY29yYXRpb24nLFxuICAgICAgICAgICAgYm5mOiBbWydcIj9cIiddLCBbJ1wiKlwiJ10sIFsnXCIrXCInXV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0RlY29yYXRpb25OYW1lJyxcbiAgICAgICAgICAgIGJuZjogW1snXCJlYm5mOi8vXCInLCAvW15cXHg1RCNdKy9dXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnJVByaW1hcnknLFxuICAgICAgICAgICAgYm5mOiBbWydOQ05hbWUnXSwgWydTdHJpbmdMaXRlcmFsJ10sIFsnQ2hhckNvZGUnXSwgWydDaGFyQ2xhc3MnXSwgWydTdWJJdGVtJ11dLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1N1Ykl0ZW0nLFxuICAgICAgICAgICAgYm5mOiBbWydcIihcIicsICdSVUxFX1dISVRFU1BBQ0UqJywgJ0Nob2ljZScsICdSVUxFX1dISVRFU1BBQ0UqJywgJ1wiKVwiJ11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTdHJpbmdMaXRlcmFsJyxcbiAgICAgICAgICAgIGJuZjogW1tgJ1wiJ2AsIC9bXlwiXSovLCBgJ1wiJ2BdLCBbYFwiJ1wiYCwgL1teJ10qLywgYFwiJ1wiYF1dLFxuICAgICAgICAgICAgcGlubmVkOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDaGFyQ29kZScsXG4gICAgICAgICAgICBibmY6IFtbJ1wiI3hcIicsIC9bMC05YS16QS1aXSsvXV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NoYXJDbGFzcycsXG4gICAgICAgICAgICBibmY6IFtbXCInWydcIiwgXCInXic/XCIsICclUlVMRV9DaGFyQ2xhc3NfMSsnLCAnXCJdXCInXV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJyVSVUxFX0NoYXJDbGFzc18xJyxcbiAgICAgICAgICAgIGJuZjogW1snQ2hhckNvZGVSYW5nZSddLCBbJ0NoYXJSYW5nZSddLCBbJ0NoYXJDb2RlJ10sIFsnUlVMRV9DaGFyJ11dLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1JVTEVfQ2hhcicsXG4gICAgICAgICAgICBibmY6IFtbL1xceDA5L10sIFsvXFx4MEEvXSwgWy9cXHgwRC9dLCBbL1tcXHgyMC1cXHg1Y10vXSwgWy9bXFx4NWUtXFx1RDdGRl0vXSwgWy9bXFx1RTAwMC1cXHVGRkZEXS9dXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ2hhclJhbmdlJyxcbiAgICAgICAgICAgIGJuZjogW1snUlVMRV9DaGFyJywgJ1wiLVwiJywgJ1JVTEVfQ2hhciddXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ2hhckNvZGVSYW5nZScsXG4gICAgICAgICAgICBibmY6IFtbJ0NoYXJDb2RlJywgJ1wiLVwiJywgJ0NoYXJDb2RlJ11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdSVUxFX1dISVRFU1BBQ0UnLFxuICAgICAgICAgICAgYm5mOiBbWyclUlVMRV9XSElURVNQQUNFX0NIQVIqJ10sIFsnQ29tbWVudCcsICdSVUxFX1dISVRFU1BBQ0UqJ11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdSVUxFX1MnLFxuICAgICAgICAgICAgYm5mOiBbWydSVUxFX1dISVRFU1BBQ0UnLCAnUlVMRV9TKiddLCBbJ1JVTEVfRU9MJywgJ1JVTEVfUyonXV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJyVSVUxFX1dISVRFU1BBQ0VfQ0hBUicsXG4gICAgICAgICAgICBibmY6IFtbL1xceDA5L10sIFsvXFx4MjAvXV0sXG4gICAgICAgICAgICBmcmFnbWVudDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ29tbWVudCcsXG4gICAgICAgICAgICBibmY6IFtbJ1wiLypcIicsICclUlVMRV9Db21tZW50X0JvZHkqJywgJ1wiKi9cIiddXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnJVJVTEVfQ29tbWVudF9Cb2R5JyxcbiAgICAgICAgICAgIGJuZjogW1snIVwiKi9cIicsIC9bXipdL11dLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1JVTEVfRU9MJyxcbiAgICAgICAgICAgIGJuZjogW1svXFx4MEQvLCAvXFx4MEEvXSwgWy9cXHgwQS9dLCBbL1xceDBEL11dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMaW5rJyxcbiAgICAgICAgICAgIGJuZjogW1tcIidbJ1wiLCAnVXJsJywgXCInXSdcIl1dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdVcmwnLFxuICAgICAgICAgICAgYm5mOiBbWy9bXlxceDVEOi8/I10vLCAnXCI6Ly9cIicsIC9bXlxceDVEI10rLywgJyVVcmwxPyddXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnJVVybDEnLFxuICAgICAgICAgICAgYm5mOiBbWydcIiNcIicsICdOQ05hbWUnXV0sXG4gICAgICAgICAgICBmcmFnbWVudDogdHJ1ZVxuICAgICAgICB9XG4gICAgXTtcbiAgICBCTkYuZGVmYXVsdFBhcnNlciA9IG5ldyBQYXJzZXJfMS5QYXJzZXIoQk5GLlJVTEVTLCB7IGRlYnVnOiBmYWxzZSB9KTtcbiAgICBjb25zdCBwcmVEZWNvcmF0aW9uUkUgPSAvXighfCYpLztcbiAgICBjb25zdCBkZWNvcmF0aW9uUkUgPSAvKFxcP3xcXCt8XFwqKSQvO1xuICAgIGNvbnN0IHN1YkV4cHJlc3Npb25SRSA9IC9eJS87XG4gICAgZnVuY3Rpb24gZ2V0Qk5GUnVsZShuYW1lLCBwYXJzZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAocHJlRGVjb3JhdGlvblJFLnRlc3QobmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgbGV0IHN1YmV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uUkUudGVzdChuYW1lKTtcbiAgICAgICAgICAgIGlmIChzdWJleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlY29yYXRpb24gPSBkZWNvcmF0aW9uUkUuZXhlYyhuYW1lKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVjb3JhdGlvblRleHQgPSBkZWNvcmF0aW9uID8gZGVjb3JhdGlvblswXSArICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIGxldCBsb25lbHkgPSBpc0xvbmVseVJ1bGUobmFtZSwgcGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAobG9uZWx5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qk5GQm9keShuYW1lLCBwYXJzZXIpICsgZGVjb3JhdGlvblRleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIGdldEJORkJvZHkobmFtZSwgcGFyc2VyKSArICcpJyArIGRlY29yYXRpb25UZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS5zb3VyY2VcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXCg/Onh8dSkoW2EtekEtWjAtOV0rKS9nLCAnI3gkMScpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1xcXFwoPzp4fHUpKFthLXpBLVowLTldKyktXFxcXCg/Onh8dSkoW2EtekEtWjAtOV0rKVxcXS9nLCAnWyN4JDEtI3gkMl0nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBydWxlIGlzIGEgc3RyaW5nIGxpdGVyYWwgb3IgcmVndWxhciBleHByZXNzaW9uIHdpdGhvdXQgYSBkZXNjZW5kYW50IHRyZWVcbiAgICBmdW5jdGlvbiBpc0xvbmVseVJ1bGUobmFtZSwgcGFyc2VyKSB7XG4gICAgICAgIGxldCBydWxlID0gUGFyc2VyXzEuZmluZFJ1bGVCeU5hbWUobmFtZSwgcGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIChydWxlICYmXG4gICAgICAgICAgICBydWxlLmJuZi5sZW5ndGggPT0gMSAmJlxuICAgICAgICAgICAgcnVsZS5ibmZbMF0ubGVuZ3RoID09IDEgJiZcbiAgICAgICAgICAgIChydWxlLmJuZlswXVswXSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBydWxlLmJuZlswXVswXVswXSA9PSAnXCInIHx8IHJ1bGUuYm5mWzBdWzBdWzBdID09IFwiJ1wiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJORkNob2ljZShydWxlcywgcGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBydWxlcy5tYXAoeCA9PiBnZXRCTkZSdWxlKHgsIHBhcnNlcikpLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Qk5GQm9keShuYW1lLCBwYXJzZXIpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBQYXJzZXJfMS5maW5kUnVsZUJ5TmFtZShuYW1lLCBwYXJzZXIpO1xuICAgICAgICBpZiAocnVsZSlcbiAgICAgICAgICAgIHJldHVybiBydWxlLmJuZi5tYXAoeCA9PiBnZXRCTkZDaG9pY2UoeCwgcGFyc2VyKSkuam9pbignIHwgJyk7XG4gICAgICAgIHJldHVybiAnUlVMRV9OT1RfRk9VTkQgeycgKyBuYW1lICsgJ30nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0KHBhcnNlcikge1xuICAgICAgICBsZXQgYWN1bXVsYXRvciA9IFtdO1xuICAgICAgICBwYXJzZXIuZ3JhbW1hclJ1bGVzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICBpZiAoIS9eJS8udGVzdChsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY292ZXIgPSBsLnJlY292ZXIgPyAnIC8qIHsgcmVjb3ZlclVudGlsPScgKyBsLnJlY292ZXIgKyAnIH0gKi8nIDogJyc7XG4gICAgICAgICAgICAgICAgYWN1bXVsYXRvci5wdXNoKGwubmFtZSArICcgOjo9ICcgKyBnZXRCTkZCb2R5KGwubmFtZSwgcGFyc2VyKSArIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFjdW11bGF0b3Iuam9pbignXFxuJyk7XG4gICAgfVxuICAgIEJORi5lbWl0ID0gZW1pdDtcbiAgICBsZXQgc3ViaXRlbXMgPSAwO1xuICAgIGZ1bmN0aW9uIHJlc3Rhcih0b3RhbCwgcmVzdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3JlYmVyaWEgcmVzdGFyICcgKyByZXN0YSArICcgYSAnICsgdG90YWwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZmZlcmVuY2Ugbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFJlZ2V4KHR4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh0eHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC8jeChbYS16QS1aMC05XXs0fSkvZywgJ1xcXFx1JDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyN4KFthLXpBLVowLTldezN9KS9nLCAnXFxcXHUwJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyN4KFthLXpBLVowLTldezJ9KS9nLCAnXFxcXHgkMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvI3goW2EtekEtWjAtOV17MX0pL2csICdcXFxceDAkMScpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3ViSXRlbXModG1wUnVsZXMsIHNlcSwgcGFyZW50TmFtZSkge1xuICAgICAgICBsZXQgYW50ZXJpb3IgPSBudWxsO1xuICAgICAgICBsZXQgYm5mU2VxID0gW107XG4gICAgICAgIHNlcS5jaGlsZHJlbi5mb3JFYWNoKCh4LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoeC50eXBlID09ICdNaW51cycpIHtcbiAgICAgICAgICAgICAgICByZXN0YXIoYW50ZXJpb3IsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVjb3JhdGlvbiA9IHNlcS5jaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICBkZWNvcmF0aW9uID0gKGRlY29yYXRpb24gJiYgZGVjb3JhdGlvbi50eXBlID09ICdQcmltYXJ5RGVjb3JhdGlvbicgJiYgZGVjb3JhdGlvbi50ZXh0KSB8fCAnJztcbiAgICAgICAgICAgIGxldCBwcmVEZWNvcmF0aW9uID0gJyc7XG4gICAgICAgICAgICBzd2l0Y2ggKHgudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1N1Ykl0ZW0nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9ICclJyArIChwYXJlbnROYW1lICsgc3ViaXRlbXMrKyk7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJ1bGUodG1wUnVsZXMsIHgsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBibmZTZXEucHVzaChwcmVEZWNvcmF0aW9uICsgbmFtZSArIGRlY29yYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdOQ05hbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgICAgICAgICAgICAgICBibmZTZXEucHVzaChwcmVEZWNvcmF0aW9uICsgeC50ZXh0ICsgZGVjb3JhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0NoYXJDb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdDaGFyQ2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdGlvbiB8fCBwcmVEZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UnVsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJScgKyAocGFyZW50TmFtZSArIHN1Yml0ZW1zKyspLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJuZjogW1tjb252ZXJ0UmVnZXgoeC50ZXh0KV1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wUnVsZXMucHVzaChuZXdSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJuZlNlcS5wdXNoKHByZURlY29yYXRpb24gKyBuZXdSdWxlLm5hbWUgKyBkZWNvcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJuZlNlcS5wdXNoKGNvbnZlcnRSZWdleCh4LnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdQcmltYXJ5RGVjb3JhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIEhPVyBTSE9VTEQgSSBQQVJTRSBUSElTPyAnICsgeC50eXBlICsgJyAtPiAnICsgSlNPTi5zdHJpbmdpZnkoeC50ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbnRlcmlvciA9IHg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm5mU2VxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSdWxlKHRtcFJ1bGVzLCB0b2tlbiwgbmFtZSkge1xuICAgICAgICBsZXQgYm5mID0gdG9rZW4uY2hpbGRyZW4uZmlsdGVyKHggPT4geC50eXBlID09ICdTZXF1ZW5jZU9yRGlmZmVyZW5jZScpLm1hcChzID0+IGdldFN1Ykl0ZW1zKHRtcFJ1bGVzLCBzLCBuYW1lKSk7XG4gICAgICAgIGxldCBydWxlID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGJuZlxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVjb3ZlciA9IG51bGw7XG4gICAgICAgIGJuZi5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgcmVjb3ZlciA9IHJlY292ZXIgfHwgeFsncmVjb3ZlciddO1xuICAgICAgICAgICAgZGVsZXRlIHhbJ3JlY292ZXInXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJyUnKSA9PSAwKVxuICAgICAgICAgICAgcnVsZS5mcmFnbWVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWNvdmVyKVxuICAgICAgICAgICAgcnVsZS5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgICAgICAgdG1wUnVsZXMucHVzaChydWxlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UnVsZXMoc291cmNlLCBwYXJzZXIgPSBCTkYuZGVmYXVsdFBhcnNlcikge1xuICAgICAgICBsZXQgYXN0ID0gcGFyc2VyLmdldEFTVChzb3VyY2UpO1xuICAgICAgICBpZiAoIWFzdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlICcgKyBzb3VyY2UpO1xuICAgICAgICBpZiAoYXN0LmVycm9ycyAmJiBhc3QuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgYXN0LmVycm9yc1swXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG1wUnVsZXMgPSBbXTtcbiAgICAgICAgYXN0LmNoaWxkcmVuLmZpbHRlcih4ID0+IHgudHlwZSA9PSAnUHJvZHVjdGlvbicpLm1hcCgoeCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB4LmNoaWxkcmVuLmZpbHRlcih4ID0+IHgudHlwZSA9PSAnTkNOYW1lJylbMF0udGV4dDtcbiAgICAgICAgICAgIGNyZWF0ZVJ1bGUodG1wUnVsZXMsIHgsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRtcFJ1bGVzO1xuICAgIH1cbiAgICBCTkYuZ2V0UnVsZXMgPSBnZXRSdWxlcztcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm0oc291cmNlLCBzdWJQYXJzZXIgPSBCTkYuZGVmYXVsdFBhcnNlcikge1xuICAgICAgICByZXR1cm4gZ2V0UnVsZXMoc291cmNlLmpvaW4oJycpLCBzdWJQYXJzZXIpO1xuICAgIH1cbiAgICBCTkYuVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuICAgIGNsYXNzIFBhcnNlciBleHRlbmRzIFBhcnNlcl8xLlBhcnNlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc3ViUGFyc2VyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnUnVsZXNQYXJzZXIgPT09IHRydWUgPyBuZXcgUGFyc2VyXzEuUGFyc2VyKEJORi5SVUxFUywgeyBkZWJ1ZzogdHJ1ZSB9KSA6IEJORi5kZWZhdWx0UGFyc2VyO1xuICAgICAgICAgICAgc3VwZXIoZ2V0UnVsZXMoc291cmNlLCBzdWJQYXJzZXIpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbWl0U291cmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQk5GLlBhcnNlciA9IFBhcnNlcjtcbn0pKEJORiB8fCAoQk5GID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJORjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVczQ0VCTkYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6782\n")},7853:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1My5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy92YWxpZC11cmwvaW5kZXguanM/MWJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfdXJpID0gaXNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX2h0dHBfdXJpID0gaXNfaHR0cF9pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfaHR0cHNfdXJpID0gaXNfaHR0cHNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX3dlYl91cmkgPSBpc193ZWJfaXJpO1xuICAgIC8vIENyZWF0ZSBhbGlhc2VzXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNVcmkgPSBpc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNIdHRwVXJpID0gaXNfaHR0cF9pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNIdHRwc1VyaSA9IGlzX2h0dHBzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc1dlYlVyaSA9IGlzX3dlYl9pcmk7XG5cblxuICAgIC8vIHByaXZhdGUgZnVuY3Rpb25cbiAgICAvLyBpbnRlcm5hbCBVUkkgc3BpdHRlciBtZXRob2QgLSBkaXJlY3QgZnJvbSBSRkMgMzk4NlxuICAgIHZhciBzcGxpdFVyaSA9IGZ1bmN0aW9uKHVyaSkge1xuICAgICAgICB2YXIgc3BsaXR0ZWQgPSB1cmkubWF0Y2goLyg/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8vKTtcbiAgICAgICAgcmV0dXJuIHNwbGl0dGVkO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc19pcmkodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoL1teYS16MC05XFw6XFwvXFw/XFwjXFxbXFxdXFxAXFwhXFwkXFwmXFwnXFwoXFwpXFwqXFwrXFwsXFw7XFw9XFwuXFwtXFxfXFx+XFwlXS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGhleCBlc2NhcGVzIHRoYXQgYXJlbid0IGNvbXBsZXRlXG4gICAgICAgIGlmICgvJVteMC05YS1mXS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGlmICgvJVswLTlhLWZdKDo/W14wLTlhLWZdfCQpL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcblxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICcnO1xuICAgICAgICB2YXIgYXV0aG9yaXR5ID0gJyc7XG4gICAgICAgIHZhciBwYXRoID0gJyc7XG4gICAgICAgIHZhciBxdWVyeSA9ICcnO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuXG4gICAgICAgIC8vIGZyb20gUkZDIDM5ODZcbiAgICAgICAgc3BsaXR0ZWQgPSBzcGxpdFVyaSh2YWx1ZSk7XG4gICAgICAgIHNjaGVtZSA9IHNwbGl0dGVkWzFdOyBcbiAgICAgICAgYXV0aG9yaXR5ID0gc3BsaXR0ZWRbMl07XG4gICAgICAgIHBhdGggPSBzcGxpdHRlZFszXTtcbiAgICAgICAgcXVlcnkgPSBzcGxpdHRlZFs0XTtcbiAgICAgICAgZnJhZ21lbnQgPSBzcGxpdHRlZFs1XTtcblxuICAgICAgICAvLyBzY2hlbWUgYW5kIHBhdGggYXJlIHJlcXVpcmVkLCB0aG91Z2ggdGhlIHBhdGggY2FuIGJlIGVtcHR5XG4gICAgICAgIGlmICghKHNjaGVtZSAmJiBzY2hlbWUubGVuZ3RoICYmIHBhdGgubGVuZ3RoID49IDApKSByZXR1cm47XG5cbiAgICAgICAgLy8gaWYgYXV0aG9yaXR5IGlzIHByZXNlbnQsIHRoZSBwYXRoIG11c3QgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIC9cbiAgICAgICAgaWYgKGF1dGhvcml0eSAmJiBhdXRob3JpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRoLmxlbmd0aCA9PT0gMCB8fCAvXlxcLy8udGVzdChwYXRoKSkpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGF1dGhvcml0eSBpcyBub3QgcHJlc2VudCwgdGhlIHBhdGggbXVzdCBub3Qgc3RhcnQgd2l0aCAvL1xuICAgICAgICAgICAgaWYgKC9eXFwvXFwvLy50ZXN0KHBhdGgpKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2hlbWUgbXVzdCBiZWdpbiB3aXRoIGEgbGV0dGVyLCB0aGVuIGNvbnNpc3Qgb2YgbGV0dGVycywgZGlnaXRzLCArLCAuLCBvciAtXG4gICAgICAgIGlmICghL15bYS16XVthLXowLTlcXCtcXC1cXC5dKiQvLnRlc3Qoc2NoZW1lLnRvTG93ZXJDYXNlKCkpKSAgcmV0dXJuO1xuXG4gICAgICAgIC8vIHJlLWFzc2VtYmxlIHRoZSBVUkwgcGVyIHNlY3Rpb24gNS4zIGluIFJGQyAzOTg2XG4gICAgICAgIG91dCArPSBzY2hlbWUgKyAnOic7XG4gICAgICAgIGlmIChhdXRob3JpdHkgJiYgYXV0aG9yaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICcvLycgKyBhdXRob3JpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gcGF0aDtcblxuICAgICAgICBpZiAocXVlcnkgJiYgcXVlcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2h0dHBfaXJpKHZhbHVlLCBhbGxvd0h0dHBzKSB7XG4gICAgICAgIGlmICghaXNfaXJpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwbGl0dGVkID0gW107XG4gICAgICAgIHZhciBzY2hlbWUgPSAnJztcbiAgICAgICAgdmFyIGF1dGhvcml0eSA9ICcnO1xuICAgICAgICB2YXIgcGF0aCA9ICcnO1xuICAgICAgICB2YXIgcG9ydCA9ICcnO1xuICAgICAgICB2YXIgcXVlcnkgPSAnJztcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIHZhciBvdXQgPSAnJztcblxuICAgICAgICAvLyBmcm9tIFJGQyAzOTg2XG4gICAgICAgIHNwbGl0dGVkID0gc3BsaXRVcmkodmFsdWUpO1xuICAgICAgICBzY2hlbWUgPSBzcGxpdHRlZFsxXTsgXG4gICAgICAgIGF1dGhvcml0eSA9IHNwbGl0dGVkWzJdO1xuICAgICAgICBwYXRoID0gc3BsaXR0ZWRbM107XG4gICAgICAgIHF1ZXJ5ID0gc3BsaXR0ZWRbNF07XG4gICAgICAgIGZyYWdtZW50ID0gc3BsaXR0ZWRbNV07XG5cbiAgICAgICAgaWYgKCFzY2hlbWUpICByZXR1cm47XG5cbiAgICAgICAgaWYoYWxsb3dIdHRwcykge1xuICAgICAgICAgICAgaWYgKHNjaGVtZS50b0xvd2VyQ2FzZSgpICE9ICdodHRwcycpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPSAnaHR0cCcpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bGx5LXF1YWxpZmllZCBVUklzIG11c3QgaGF2ZSBhbiBhdXRob3JpdHkgc2VjdGlvbiB0aGF0IGlzXG4gICAgICAgIC8vIGEgdmFsaWQgaG9zdFxuICAgICAgICBpZiAoIWF1dGhvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5hYmxlIHBvcnQgY29tcG9uZW50XG4gICAgICAgIGlmICgvOihcXGQrKSQvLnRlc3QoYXV0aG9yaXR5KSkge1xuICAgICAgICAgICAgcG9ydCA9IGF1dGhvcml0eS5tYXRjaCgvOihcXGQrKSQvKVswXTtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IGF1dGhvcml0eS5yZXBsYWNlKC86XFxkKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gc2NoZW1lICsgJzonO1xuICAgICAgICBvdXQgKz0gJy8vJyArIGF1dGhvcml0eTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBvdXQgKz0gcG9ydDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgb3V0ICs9IHBhdGg7XG4gICAgICAgIFxuICAgICAgICBpZihxdWVyeSAmJiBxdWVyeS5sZW5ndGgpe1xuICAgICAgICAgICAgb3V0ICs9ICc/JyArIHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZnJhZ21lbnQgJiYgZnJhZ21lbnQubGVuZ3RoKXtcbiAgICAgICAgICAgIG91dCArPSAnIycgKyBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19odHRwc19pcmkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzX2h0dHBfaXJpKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc193ZWJfaXJpKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoaXNfaHR0cF9pcmkodmFsdWUpIHx8IGlzX2h0dHBzX2lyaSh2YWx1ZSkpO1xuICAgIH1cblxufSkobW9kdWxlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7853\n")},8506:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.canonicalize = exports.canonicalize_quoted_string = exports.normalize = exports.normalize_dot_string = exports.parse = void 0;\n// const punycode = require(\'punycode\');\nconst nearley = __webpack_require__(8515);\nconst grammar_1 = __importDefault(__webpack_require__(2084));\ngrammar_1.default.ParserStart = "Mailbox";\nconst grammar = nearley.Grammar.fromCompiled(grammar_1.default);\n// <https://tools.ietf.org/html/rfc5321#section-4.1.2>\nfunction parse(address) {\n    const parser = new nearley.Parser(grammar);\n    parser.feed(address);\n    if (parser.results.length !== 1) {\n        throw new Error("address parsing failed: ambiguous grammar");\n    }\n    return parser.results[0];\n}\nexports.parse = parse;\n/** Strip +something, strip \'.\'s, and map to lower case.\n */\nfunction normalize_dot_string(dot_string) {\n    const tagless = (function () {\n        const plus_loc = dot_string.indexOf("+");\n        if (plus_loc === -1) {\n            return dot_string;\n        }\n        return dot_string.substr(0, plus_loc);\n    })();\n    const dotless = tagless.replace(/\\./g, "");\n    return dotless.toLowerCase();\n}\nexports.normalize_dot_string = normalize_dot_string;\n/** The G style address normalization.\n */\nfunction normalize(address) {\n    var _a, _b;\n    const a = parse(address);\n    const domain = (_a = a.domainPart.AddressLiteral) !== null && _a !== void 0 ? _a : a.domainPart.DomainName.toLowerCase();\n    const local = (_b = a.localPart.QuotedString) !== null && _b !== void 0 ? _b : normalize_dot_string(a.localPart.DotString);\n    return `${local}@${domain}`;\n}\nexports.normalize = normalize;\nfunction canonicalize_quoted_string(quoted_string) {\n    const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);\n    const unescaped = unquoted.replace(/(?:\\\\(.))/g, "$1");\n    const reescaped = unescaped.replace(/(?:(["\\\\]))/g, "\\\\$1");\n    return `"${reescaped}"`; // re-quote\n}\nexports.canonicalize_quoted_string = canonicalize_quoted_string;\n/**\n * Apply a canonicalization consistent with standards to support\n * comparison as a string.\n */\nfunction canonicalize(address) {\n    var _a;\n    const a = parse(address);\n    const domain = (_a = a.domainPart.AddressLiteral) !== null && _a !== void 0 ? _a : a.domainPart.DomainName.toLowerCase();\n    const local = a.localPart.QuotedString\n        ? canonicalize_quoted_string(a.localPart.QuotedString)\n        : a.localPart.DotString;\n    return `${local}@${domain}`;\n}\nexports.canonicalize = canonicalize;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUwNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtDQUFrQyxHQUFHLGlCQUFpQixHQUFHLDRCQUE0QixHQUFHLGFBQWE7QUFDNUg7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFTO0FBQ2pDLGtDQUFrQyxtQkFBTyxDQUFDLElBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNLEdBQUcsT0FBTztBQUM5QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVSxJQUFJO0FBQzdCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU0sR0FBRyxPQUFPO0FBQzlCO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3NtdHAtYWRkcmVzcy1wYXJzZXIvZGlzdC9saWIvaW5kZXguanM/ZTZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2Fub25pY2FsaXplID0gZXhwb3J0cy5jYW5vbmljYWxpemVfcXVvdGVkX3N0cmluZyA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5ub3JtYWxpemVfZG90X3N0cmluZyA9IGV4cG9ydHMucGFyc2UgPSB2b2lkIDA7XG4vLyBjb25zdCBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5jb25zdCBuZWFybGV5ID0gcmVxdWlyZShcIm5lYXJsZXlcIik7XG5jb25zdCBncmFtbWFyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZ3JhbW1hclwiKSk7XG5ncmFtbWFyXzEuZGVmYXVsdC5QYXJzZXJTdGFydCA9IFwiTWFpbGJveFwiO1xuY29uc3QgZ3JhbW1hciA9IG5lYXJsZXkuR3JhbW1hci5mcm9tQ29tcGlsZWQoZ3JhbW1hcl8xLmRlZmF1bHQpO1xuLy8gPGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC4xLjI+XG5mdW5jdGlvbiBwYXJzZShhZGRyZXNzKSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IG5lYXJsZXkuUGFyc2VyKGdyYW1tYXIpO1xuICAgIHBhcnNlci5mZWVkKGFkZHJlc3MpO1xuICAgIGlmIChwYXJzZXIucmVzdWx0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcyBwYXJzaW5nIGZhaWxlZDogYW1iaWd1b3VzIGdyYW1tYXJcIik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIucmVzdWx0c1swXTtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKiBTdHJpcCArc29tZXRoaW5nLCBzdHJpcCAnLidzLCBhbmQgbWFwIHRvIGxvd2VyIGNhc2UuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9kb3Rfc3RyaW5nKGRvdF9zdHJpbmcpIHtcbiAgICBjb25zdCB0YWdsZXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcGx1c19sb2MgPSBkb3Rfc3RyaW5nLmluZGV4T2YoXCIrXCIpO1xuICAgICAgICBpZiAocGx1c19sb2MgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZG90X3N0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG90X3N0cmluZy5zdWJzdHIoMCwgcGx1c19sb2MpO1xuICAgIH0pKCk7XG4gICAgY29uc3QgZG90bGVzcyA9IHRhZ2xlc3MucmVwbGFjZSgvXFwuL2csIFwiXCIpO1xuICAgIHJldHVybiBkb3RsZXNzLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZV9kb3Rfc3RyaW5nID0gbm9ybWFsaXplX2RvdF9zdHJpbmc7XG4vKiogVGhlIEcgc3R5bGUgYWRkcmVzcyBub3JtYWxpemF0aW9uLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYWRkcmVzcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYSA9IHBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRvbWFpbiA9IChfYSA9IGEuZG9tYWluUGFydC5BZGRyZXNzTGl0ZXJhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYS5kb21haW5QYXJ0LkRvbWFpbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBsb2NhbCA9IChfYiA9IGEubG9jYWxQYXJ0LlF1b3RlZFN0cmluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbm9ybWFsaXplX2RvdF9zdHJpbmcoYS5sb2NhbFBhcnQuRG90U3RyaW5nKTtcbiAgICByZXR1cm4gYCR7bG9jYWx9QCR7ZG9tYWlufWA7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZV9xdW90ZWRfc3RyaW5nKHF1b3RlZF9zdHJpbmcpIHtcbiAgICBjb25zdCB1bnF1b3RlZCA9IHF1b3RlZF9zdHJpbmcuc3Vic3RyKDEpLnN1YnN0cigwLCBxdW90ZWRfc3RyaW5nLmxlbmd0aCAtIDIpO1xuICAgIGNvbnN0IHVuZXNjYXBlZCA9IHVucXVvdGVkLnJlcGxhY2UoLyg/OlxcXFwoLikpL2csIFwiJDFcIik7XG4gICAgY29uc3QgcmVlc2NhcGVkID0gdW5lc2NhcGVkLnJlcGxhY2UoLyg/OihbXCJcXFxcXSkpL2csIFwiXFxcXCQxXCIpO1xuICAgIHJldHVybiBgXCIke3JlZXNjYXBlZH1cImA7IC8vIHJlLXF1b3RlXG59XG5leHBvcnRzLmNhbm9uaWNhbGl6ZV9xdW90ZWRfc3RyaW5nID0gY2Fub25pY2FsaXplX3F1b3RlZF9zdHJpbmc7XG4vKipcbiAqIEFwcGx5IGEgY2Fub25pY2FsaXphdGlvbiBjb25zaXN0ZW50IHdpdGggc3RhbmRhcmRzIHRvIHN1cHBvcnRcbiAqIGNvbXBhcmlzb24gYXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShhZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGEgPSBwYXJzZShhZGRyZXNzKTtcbiAgICBjb25zdCBkb21haW4gPSAoX2EgPSBhLmRvbWFpblBhcnQuQWRkcmVzc0xpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGEuZG9tYWluUGFydC5Eb21haW5OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgbG9jYWwgPSBhLmxvY2FsUGFydC5RdW90ZWRTdHJpbmdcbiAgICAgICAgPyBjYW5vbmljYWxpemVfcXVvdGVkX3N0cmluZyhhLmxvY2FsUGFydC5RdW90ZWRTdHJpbmcpXG4gICAgICAgIDogYS5sb2NhbFBhcnQuRG90U3RyaW5nO1xuICAgIHJldHVybiBgJHtsb2NhbH1AJHtkb21haW59YDtcbn1cbmV4cG9ydHMuY2Fub25pY2FsaXplID0gY2Fub25pY2FsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8506\n')},8515:function(module){eval('(function(root, factory) {\n    if ( true && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === "undefined")\n                             ? this.symbols.map(getSymbolShortDisplay).join(\' \')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(\' \')\n                                 + " \u25cf "\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(\' \')     );\n        return this.name + " \u2192 " + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== \'string\') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset("");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === \'\\n\') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === \'string\') {\n            var lines = buffer\n                .split("\\n")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf(\'\\n\', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += " at line " + this.line + " col " + col + ":\\n\\n";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;\n                }, this)\n                .join("\\n");\n            message += "\\n" + pad("", lastLineDigits + col) + "^\\n";\n            return message;\n        } else {\n            return message + " at index " + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(" ") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal\'s start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it\'s worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo\'s thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";\n            lexerMessage = this.lexer.formatError(token, "Syntax error");\n        } else {\n            tokenDisplay = "input (lexer error)";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, "Syntax error");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== "string";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push(\'Unexpected \' + tokenDisplay + \'. I did not expect any more input. Here is the state of my parse table:\\n\');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push(\'Unexpected \' + tokenDisplay + \'. Instead, I was expecting to see one of the following:\\n\');\n            // Display a "state stack" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push(\'A \' + symbolDisplay + \' based on:\');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push("");\n        return lines.join("\\n");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push(\'    ^ \' + sameDisplayCount + \' more lines identical to this\');\n                }\n                sameDisplayCount = 0;\n                lines.push(\'    \' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don\'t know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error(\'set option `keepHistory` to enable rewinding\')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === "string") {\n            return symbol;\n        } else if (type === "object") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return \'character matching \' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + \' token\';\n            } else if (symbol.test) {\n                return \'token matching \' + String(symbol.test);\n            } else {\n                throw new Error(\'Unknown symbol type: \' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === "string") {\n            return symbol;\n        } else if (type === "object") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return \'%\' + symbol.type;\n            } else if (symbol.test) {\n                return \'<\' + String(symbol.test) + \'>\';\n            } else {\n                throw new Error(\'Unknown symbol type: \' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZWFybGV5L2xpYi9uZWFybGV5LmpzP2JmZWEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5uZWFybGV5ID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBSdWxlKG5hbWUsIHN5bWJvbHMsIHBvc3Rwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuaWQgPSArK1J1bGUuaGlnaGVzdElkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBzeW1ib2xzOyAgICAgICAgLy8gYSBsaXN0IG9mIGxpdGVyYWwgfCByZWdleCBjbGFzcyB8IG5vbnRlcm1pbmFsXG4gICAgICAgIHRoaXMucG9zdHByb2Nlc3MgPSBwb3N0cHJvY2VzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFJ1bGUuaGlnaGVzdElkID0gMDtcblxuICAgIFJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24od2l0aEN1cnNvckF0KSB7XG4gICAgICAgIHZhciBzeW1ib2xTZXF1ZW5jZSA9ICh0eXBlb2Ygd2l0aEN1cnNvckF0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc3ltYm9scy5tYXAoZ2V0U3ltYm9sU2hvcnREaXNwbGF5KS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoICAgdGhpcy5zeW1ib2xzLnNsaWNlKDAsIHdpdGhDdXJzb3JBdCkubWFwKGdldFN5bWJvbFNob3J0RGlzcGxheSkuam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIOKXjyBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB0aGlzLnN5bWJvbHMuc2xpY2Uod2l0aEN1cnNvckF0KS5tYXAoZ2V0U3ltYm9sU2hvcnREaXNwbGF5KS5qb2luKCcgJykgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIiDihpIgXCIgKyBzeW1ib2xTZXF1ZW5jZTtcbiAgICB9XG5cblxuICAgIC8vIGEgU3RhdGUgaXMgYSBydWxlIGF0IGEgcG9zaXRpb24gZnJvbSBhIGdpdmVuIHN0YXJ0aW5nIHBvaW50IGluIHRoZSBpbnB1dCBzdHJlYW0gKHJlZmVyZW5jZSlcbiAgICBmdW5jdGlvbiBTdGF0ZShydWxlLCBkb3QsIHJlZmVyZW5jZSwgd2FudGVkQnkpIHtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICAgICAgdGhpcy5kb3QgPSBkb3Q7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy53YW50ZWRCeSA9IHdhbnRlZEJ5O1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0aGlzLmRvdCA9PT0gcnVsZS5zeW1ib2xzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy5ydWxlLnRvU3RyaW5nKHRoaXMuZG90KSArIFwifSwgZnJvbTogXCIgKyAodGhpcy5yZWZlcmVuY2UgfHwgMCk7XG4gICAgfTtcblxuICAgIFN0YXRlLnByb3RvdHlwZS5uZXh0U3RhdGUgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUodGhpcy5ydWxlLCB0aGlzLmRvdCArIDEsIHRoaXMucmVmZXJlbmNlLCB0aGlzLndhbnRlZEJ5KTtcbiAgICAgICAgc3RhdGUubGVmdCA9IHRoaXM7XG4gICAgICAgIHN0YXRlLnJpZ2h0ID0gY2hpbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuYnVpbGQoKTtcbiAgICAgICAgICAgIC8vIEhhdmluZyByaWdodCBzZXQgaGVyZSB3aWxsIHByZXZlbnQgdGhlIHJpZ2h0IHN0YXRlIGFuZCBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIGZvcm0gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgIHN0YXRlLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuXG4gICAgU3RhdGUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZS5yaWdodC5kYXRhKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIH0gd2hpbGUgKG5vZGUubGVmdCk7XG4gICAgICAgIGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGUucG9zdHByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMucnVsZS5wb3N0cHJvY2Vzcyh0aGlzLmRhdGEsIHRoaXMucmVmZXJlbmNlLCBQYXJzZXIuZmFpbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBDb2x1bW4oZ3JhbW1hciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLndhbnRzID0ge307IC8vIHN0YXRlcyBpbmRleGVkIGJ5IHRoZSBub24tdGVybWluYWwgdGhleSBleHBlY3RcbiAgICAgICAgdGhpcy5zY2FubmFibGUgPSBbXTsgLy8gbGlzdCBvZiBzdGF0ZXMgdGhhdCBleHBlY3QgYSB0b2tlblxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHt9OyAvLyBzdGF0ZXMgdGhhdCBhcmUgbnVsbGFibGVcbiAgICB9XG5cblxuICAgIENvbHVtbi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKG5leHRDb2x1bW4pIHtcbiAgICAgICAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICAgICAgICB2YXIgd2FudHMgPSB0aGlzLndhbnRzO1xuICAgICAgICB2YXIgY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBzdGF0ZXMubGVuZ3RoOyB3KyspIHsgLy8gbmIuIHdlIHB1c2goKSBkdXJpbmcgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbd107XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRhdGEgIT09IFBhcnNlci5mYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YW50ZWRCeSA9IHN0YXRlLndhbnRlZEJ5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gd2FudGVkQnkubGVuZ3RoOyBpLS07ICkgeyAvLyB0aGlzIGxpbmUgaXMgaG90XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHdhbnRlZEJ5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShsZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgbnVsbGFibGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZWZlcmVuY2UgPT09IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBmdXR1cmUgcHJlZGljdG9ycyBvZiB0aGlzIHJ1bGUgZ2V0IGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHAgPSBzdGF0ZS5ydWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jb21wbGV0ZWRbZXhwXSA9IHRoaXMuY29tcGxldGVkW2V4cF0gfHwgW10pLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHNjYW5uYWJsZSBzdGF0ZXNcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5hYmxlLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwcmVkaWN0XG4gICAgICAgICAgICAgICAgaWYgKHdhbnRzW2V4cF0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FudHNbZXhwXS5wdXNoKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkLmhhc093blByb3BlcnR5KGV4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudWxscyA9IGNvbXBsZXRlZFtleHBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IG51bGxzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoc3RhdGUsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbnRzW2V4cF0gPSBbc3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZWRpY3QoZXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb2x1bW4ucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbihleHApIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ncmFtbWFyLmJ5TmFtZVtleHBdIHx8IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcnVsZXNbaV07XG4gICAgICAgICAgICB2YXIgd2FudGVkQnkgPSB0aGlzLndhbnRzW2V4cF07XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBTdGF0ZShyLCAwLCB0aGlzLmluZGV4LCB3YW50ZWRCeSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29sdW1uLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBjb3B5ID0gbGVmdC5uZXh0U3RhdGUocmlnaHQpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKGNvcHkpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gR3JhbW1hcihydWxlcywgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfHwgdGhpcy5ydWxlc1swXS5uYW1lO1xuICAgICAgICB2YXIgYnlOYW1lID0gdGhpcy5ieU5hbWUgPSB7fTtcbiAgICAgICAgdGhpcy5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIGlmICghYnlOYW1lLmhhc093blByb3BlcnR5KHJ1bGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBieU5hbWVbcnVsZS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnlOYW1lW3J1bGUubmFtZV0ucHVzaChydWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU28gd2UgY2FuIGFsbG93IHBhc3NpbmcgKHJ1bGVzLCBzdGFydCkgZGlyZWN0bHkgdG8gUGFyc2VyIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIEdyYW1tYXIuZnJvbUNvbXBpbGVkID0gZnVuY3Rpb24ocnVsZXMsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBsZXhlciA9IHJ1bGVzLkxleGVyO1xuICAgICAgICBpZiAocnVsZXMuUGFyc2VyU3RhcnQpIHtcbiAgICAgICAgICBzdGFydCA9IHJ1bGVzLlBhcnNlclN0YXJ0O1xuICAgICAgICAgIHJ1bGVzID0gcnVsZXMuUGFyc2VyUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gcnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiAobmV3IFJ1bGUoci5uYW1lLCByLnN5bWJvbHMsIHIucG9zdHByb2Nlc3MpKTsgfSk7XG4gICAgICAgIHZhciBnID0gbmV3IEdyYW1tYXIocnVsZXMsIHN0YXJ0KTtcbiAgICAgICAgZy5sZXhlciA9IGxleGVyOyAvLyBuYi4gc3RvcmluZyBsZXhlciBvbiBHcmFtbWFyIGlzIGlmZnksIGJ1dCB1bmF2b2lkYWJsZVxuICAgICAgICByZXR1cm4gZztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIFN0cmVhbUxleGVyKCkge1xuICAgICAgdGhpcy5yZXNldChcIlwiKTtcbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkYXRhLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGRhdGE7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGF0ZSA/IHN0YXRlLmxpbmUgOiAxO1xuICAgICAgICB0aGlzLmxhc3RMaW5lQnJlYWsgPSBzdGF0ZSA/IC1zdGF0ZS5jb2wgOiAwO1xuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgICB0aGlzLmxpbmUgKz0gMTtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUJyZWFrID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IGNofTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgIGNvbDogdGhpcy5pbmRleCAtIHRoaXMubGFzdExpbmVCcmVhayxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbih0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICAvLyBuYi4gdGhpcyBnZXRzIGNhbGxlZCBhZnRlciBjb25zdW1pbmcgdGhlIG9mZmVuZGluZyB0b2tlbixcbiAgICAgICAgLy8gc28gdGhlIGN1bHByaXQgaXMgaW5kZXgtMVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gYnVmZmVyXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCB0aGlzLmxpbmUgLSA1KSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBuZXh0TGluZUJyZWFrID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5leHRMaW5lQnJlYWsgPT09IC0xKSBuZXh0TGluZUJyZWFrID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzLmluZGV4IC0gdGhpcy5sYXN0TGluZUJyZWFrO1xuICAgICAgICAgICAgdmFyIGxhc3RMaW5lRGlnaXRzID0gU3RyaW5nKHRoaXMubGluZSkubGVuZ3RoO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBhdCBsaW5lIFwiICsgdGhpcy5saW5lICsgXCIgY29sIFwiICsgY29sICsgXCI6XFxuXFxuXCI7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGxpbmVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWQodGhpcy5saW5lIC0gbGluZXMubGVuZ3RoICsgaSArIDEsIGxhc3RMaW5lRGlnaXRzKSArIFwiIFwiICsgbGluZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIlxcblwiICsgcGFkKFwiXCIsIGxhc3RMaW5lRGlnaXRzICsgY29sKSArIFwiXlxcblwiO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZSArIFwiIGF0IGluZGV4IFwiICsgKHRoaXMuaW5kZXggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhZChuLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzID0gU3RyaW5nKG4pO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KGxlbmd0aCAtIHMubGVuZ3RoICsgMSkuam9pbihcIiBcIikgKyBzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUGFyc2VyKHJ1bGVzLCBzdGFydCwgb3B0aW9ucykge1xuICAgICAgICBpZiAocnVsZXMgaW5zdGFuY2VvZiBHcmFtbWFyKSB7XG4gICAgICAgICAgICB2YXIgZ3JhbW1hciA9IHJ1bGVzO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBncmFtbWFyID0gR3JhbW1hci5mcm9tQ29tcGlsZWQocnVsZXMsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuXG4gICAgICAgIC8vIFJlYWQgb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBrZWVwSGlzdG9yeTogZmFsc2UsXG4gICAgICAgICAgICBsZXhlcjogZ3JhbW1hci5sZXhlciB8fCBuZXcgU3RyZWFtTGV4ZXIsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAob3B0aW9ucyB8fCB7fSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dXAgbGV4ZXJcbiAgICAgICAgdGhpcy5sZXhlciA9IHRoaXMub3B0aW9ucy5sZXhlcjtcbiAgICAgICAgdGhpcy5sZXhlclN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFNldHVwIGEgdGFibGVcbiAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBDb2x1bW4oZ3JhbW1hciwgMCk7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGUgPSBbY29sdW1uXTtcblxuICAgICAgICAvLyBJIGNvdWxkIGJlIGV4cGVjdGluZyBhbnl0aGluZy5cbiAgICAgICAgY29sdW1uLndhbnRzW2dyYW1tYXIuc3RhcnRdID0gW107XG4gICAgICAgIGNvbHVtbi5wcmVkaWN0KGdyYW1tYXIuc3RhcnQpO1xuICAgICAgICAvLyBUT0RPIHdoYXQgaWYgc3RhcnQgcnVsZSBpcyBudWxsYWJsZT9cbiAgICAgICAgY29sdW1uLnByb2Nlc3MoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMDsgLy8gdG9rZW4gaW5kZXhcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSByZXNlcnZlZCB0b2tlbiBmb3IgaW5kaWNhdGluZyBhIHBhcnNlIGZhaWxcbiAgICBQYXJzZXIuZmFpbCA9IHt9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5mZWVkID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgdmFyIGxleGVyID0gdGhpcy5sZXhlcjtcbiAgICAgICAgbGV4ZXIucmVzZXQoY2h1bmssIHRoaXMubGV4ZXJTdGF0ZSk7XG5cbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5leHQgY29sdW1uIHNvIHRoYXQgdGhlIGVycm9yIHJlcG9ydGVyXG4gICAgICAgICAgICAgICAgLy8gY2FuIGRpc3BsYXkgdGhlIGNvcnJlY3RseSBwcmVkaWN0ZWQgc3RhdGVzLlxuICAgICAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uID0gbmV3IENvbHVtbih0aGlzLmdyYW1tYXIsIHRoaXMuY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGUucHVzaChuZXh0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHRoaXMucmVwb3J0TGV4ZXJFcnJvcihlKSk7XG4gICAgICAgICAgICAgICAgZXJyLm9mZnNldCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICBlcnIudG9rZW4gPSBlLnRva2VuO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFkZCBuZXcgc3RhdGVzIHRvIHRhYmxlW2N1cnJlbnQrMV1cbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRhYmxlW3RoaXMuY3VycmVudF07XG5cbiAgICAgICAgICAgIC8vIEdDIHVudXNlZCBzdGF0ZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFibGVbdGhpcy5jdXJyZW50IC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5jdXJyZW50ICsgMTtcbiAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uID0gbmV3IENvbHVtbih0aGlzLmdyYW1tYXIsIG4pO1xuICAgICAgICAgICAgdGhpcy50YWJsZS5wdXNoKG5leHRDb2x1bW4pO1xuXG4gICAgICAgICAgICAvLyBBZHZhbmNlIGFsbCB0b2tlbnMgdGhhdCBleHBlY3QgdGhlIHN5bWJvbFxuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0b2tlbi50ZXh0ICE9PSB1bmRlZmluZWQgPyB0b2tlbi50ZXh0IDogdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsZXhlci5jb25zdHJ1Y3RvciA9PT0gU3RyZWFtTGV4ZXIgPyB0b2tlbi52YWx1ZSA6IHRva2VuO1xuICAgICAgICAgICAgdmFyIHNjYW5uYWJsZSA9IGNvbHVtbi5zY2FubmFibGU7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gc2Nhbm5hYmxlLmxlbmd0aDsgdy0tOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzY2FubmFibGVbd107XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjb25zdW1lIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIC8vIGVpdGhlciByZWdleCBvciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdC50ZXN0ID8gZXhwZWN0LnRlc3QodmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LnR5cGUgPyBleHBlY3QudHlwZSA9PT0gdG9rZW4udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4cGVjdC5saXRlcmFsID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0YXRlLm5leHRTdGF0ZSh7ZGF0YTogdmFsdWUsIHRva2VuOiB0b2tlbiwgaXNUb2tlbjogdHJ1ZSwgcmVmZXJlbmNlOiBuIC0gMX0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29sdW1uLnN0YXRlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV4dCwgZm9yIGVhY2ggb2YgdGhlIHJ1bGVzLCB3ZSBlaXRoZXJcbiAgICAgICAgICAgIC8vIChhKSBjb21wbGV0ZSBpdCwgYW5kIHRyeSB0byBzZWUgaWYgdGhlIHJlZmVyZW5jZSByb3cgZXhwZWN0ZWQgdGhhdFxuICAgICAgICAgICAgLy8gICAgIHJ1bGVcbiAgICAgICAgICAgIC8vIChiKSBwcmVkaWN0IHRoZSBuZXh0IG5vbnRlcm1pbmFsIGl0IGV4cGVjdHMgYnkgYWRkaW5nIHRoYXRcbiAgICAgICAgICAgIC8vICAgICBub250ZXJtaW5hbCdzIHN0YXJ0IHN0YXRlXG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0aW9uLCB3ZSBhbHNvIGtlZXAgdHJhY2sgb2YgcnVsZXMgd2UgaGF2ZSBhbHJlYWR5XG4gICAgICAgICAgICAvLyBhZGRlZFxuXG4gICAgICAgICAgICBuZXh0Q29sdW1uLnByb2Nlc3MoKTtcblxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkLCB0aHJvdyBhbiBlcnJvcjpcbiAgICAgICAgICAgIGlmIChuZXh0Q29sdW1uLnN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzdGF0ZXMgYXQgYWxsISBUaGlzIGlzIG5vdCBnb29kLlxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IodGhpcy5yZXBvcnRFcnJvcih0b2tlbikpO1xuICAgICAgICAgICAgICAgIGVyci5vZmZzZXQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgZXJyLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYXliZSBzYXZlIGxleGVyIHN0YXRlXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICAgIGNvbHVtbi5sZXhlclN0YXRlID0gbGV4ZXIuc2F2ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSBsZXhlci5zYXZlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudGFsbHkga2VlcCB0cmFjayBvZiByZXN1bHRzXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuZmluaXNoKCk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcsIGZvciB3aGF0ZXZlciBpdCdzIHdvcnRoXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlcG9ydExleGVyRXJyb3IgPSBmdW5jdGlvbihsZXhlckVycm9yKSB7XG4gICAgICAgIHZhciB0b2tlbkRpc3BsYXksIGxleGVyTWVzc2FnZTtcbiAgICAgICAgLy8gUGxhbm5pbmcgdG8gYWRkIGEgdG9rZW4gcHJvcGVydHkgdG8gbW9vJ3MgdGhyb3duIGVycm9yXG4gICAgICAgIC8vIGV2ZW4gb24gZXJyb3JpbmcgdG9rZW5zIHRvIGJlIHVzZWQgaW4gZXJyb3IgZGlzcGxheSBiZWxvd1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXhlckVycm9yLnRva2VuO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuRGlzcGxheSA9IFwiaW5wdXQgXCIgKyBKU09OLnN0cmluZ2lmeSh0b2tlbi50ZXh0WzBdKSArIFwiIChsZXhlciBlcnJvcilcIjtcbiAgICAgICAgICAgIGxleGVyTWVzc2FnZSA9IHRoaXMubGV4ZXIuZm9ybWF0RXJyb3IodG9rZW4sIFwiU3ludGF4IGVycm9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5EaXNwbGF5ID0gXCJpbnB1dCAobGV4ZXIgZXJyb3IpXCI7XG4gICAgICAgICAgICBsZXhlck1lc3NhZ2UgPSBsZXhlckVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVwb3J0RXJyb3JDb21tb24obGV4ZXJNZXNzYWdlLCB0b2tlbkRpc3BsYXkpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIHRva2VuRGlzcGxheSA9ICh0b2tlbi50eXBlID8gdG9rZW4udHlwZSArIFwiIHRva2VuOiBcIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodG9rZW4udmFsdWUgIT09IHVuZGVmaW5lZCA/IHRva2VuLnZhbHVlIDogdG9rZW4pO1xuICAgICAgICB2YXIgbGV4ZXJNZXNzYWdlID0gdGhpcy5sZXhlci5mb3JtYXRFcnJvcih0b2tlbiwgXCJTeW50YXggZXJyb3JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcG9ydEVycm9yQ29tbW9uKGxleGVyTWVzc2FnZSwgdG9rZW5EaXNwbGF5KTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXBvcnRFcnJvckNvbW1vbiA9IGZ1bmN0aW9uKGxleGVyTWVzc2FnZSwgdG9rZW5EaXNwbGF5KSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICBsaW5lcy5wdXNoKGxleGVyTWVzc2FnZSk7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uSW5kZXggPSB0aGlzLnRhYmxlLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uID0gdGhpcy50YWJsZVtsYXN0Q29sdW1uSW5kZXhdO1xuICAgICAgICB2YXIgZXhwZWN0YW50U3RhdGVzID0gbGFzdENvbHVtbi5zdGF0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFN5bWJvbCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U3ltYm9sICYmIHR5cGVvZiBuZXh0U3ltYm9sICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGV4cGVjdGFudFN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJ1VuZXhwZWN0ZWQgJyArIHRva2VuRGlzcGxheSArICcuIEkgZGlkIG5vdCBleHBlY3QgYW55IG1vcmUgaW5wdXQuIEhlcmUgaXMgdGhlIHN0YXRlIG9mIG15IHBhcnNlIHRhYmxlOlxcbicpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5U3RhdGVTdGFjayhsYXN0Q29sdW1uLnN0YXRlcywgbGluZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXMucHVzaCgnVW5leHBlY3RlZCAnICsgdG9rZW5EaXNwbGF5ICsgJy4gSW5zdGVhZCwgSSB3YXMgZXhwZWN0aW5nIHRvIHNlZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcXG4nKTtcbiAgICAgICAgICAgIC8vIERpc3BsYXkgYSBcInN0YXRlIHN0YWNrXCIgZm9yIGVhY2ggZXhwZWN0YW50IHN0YXRlXG4gICAgICAgICAgICAvLyAtIHdoaWNoIHNob3dzIHlvdSBob3cgdGhpcyBzdGF0ZSBjYW1lIHRvIGJlLCBzdGVwIGJ5IHN0ZXAuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGRlcml2YXRpb24sIHdlIG9ubHkgZGlzcGxheSB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgdmFyIHN0YXRlU3RhY2tzID0gZXhwZWN0YW50U3RhdGVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZpcnN0U3RhdGVTdGFjayhzdGF0ZSwgW10pIHx8IFtzdGF0ZV07XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAvLyBEaXNwbGF5IGVhY2ggc3RhdGUgdGhhdCBpcyBleHBlY3RpbmcgYSB0ZXJtaW5hbCBzeW1ib2wgbmV4dC5cbiAgICAgICAgICAgIHN0YXRlU3RhY2tzLmZvckVhY2goZnVuY3Rpb24oc3RhdGVTdGFjaykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlU3RhY2tbMF07XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTeW1ib2wgPSBzdGF0ZS5ydWxlLnN5bWJvbHNbc3RhdGUuZG90XTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sRGlzcGxheSA9IHRoaXMuZ2V0U3ltYm9sRGlzcGxheShuZXh0U3ltYm9sKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCdBICcgKyBzeW1ib2xEaXNwbGF5ICsgJyBiYXNlZCBvbjonKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlTdGF0ZVN0YWNrKHN0YXRlU3RhY2ssIGxpbmVzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBcbiAgICBQYXJzZXIucHJvdG90eXBlLmRpc3BsYXlTdGF0ZVN0YWNrID0gZnVuY3Rpb24oc3RhdGVTdGFjaywgbGluZXMpIHtcbiAgICAgICAgdmFyIGxhc3REaXNwbGF5O1xuICAgICAgICB2YXIgc2FtZURpc3BsYXlDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGVTdGFjay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVTdGFja1tqXTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gc3RhdGUucnVsZS50b1N0cmluZyhzdGF0ZS5kb3QpO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IGxhc3REaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgc2FtZURpc3BsYXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZURpc3BsYXlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnICAgIF4gJyArIHNhbWVEaXNwbGF5Q291bnQgKyAnIG1vcmUgbGluZXMgaWRlbnRpY2FsIHRvIHRoaXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FtZURpc3BsYXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnICAgICcgKyBkaXNwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3REaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmdldFN5bWJvbERpc3BsYXkgPSBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIGdldFN5bWJvbExvbmdEaXNwbGF5KHN5bWJvbCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQnVpbGRzIGEgdGhlIGZpcnN0IHN0YXRlIHN0YWNrLiBZb3UgY2FuIHRoaW5rIG9mIGEgc3RhdGUgc3RhY2sgYXMgdGhlIGNhbGwgc3RhY2tcbiAgICBvZiB0aGUgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyIHdoaWNoIHRoZSBOZWFybGV5IHBhcnNlIGFsZ29yaXRobSBzaW11bGF0ZXMuXG4gICAgQSBzdGF0ZSBzdGFjayBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZSBvYmplY3RzLiBXaXRoaW4gYVxuICAgIHN0YXRlIHN0YWNrLCB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgYXJyYXkgd2lsbCBiZSB0aGUgc3RhcnRpbmdcbiAgICBzdGF0ZSwgd2l0aCBlYWNoIHN1Y2Nlc3NpdmUgaXRlbSBpbiB0aGUgYXJyYXkgZ29pbmcgZnVydGhlciBiYWNrIGludG8gaGlzdG9yeS5cblxuICAgIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgZ2l2ZW4gYSBzdGFydGluZyBzdGF0ZSBhbmQgYW4gZW1wdHkgYXJyYXkgcmVwcmVzZW50aW5nXG4gICAgdGhlIHZpc2l0ZWQgc3RhdGVzLCBhbmQgaXQgcmV0dXJucyBhbiBzaW5nbGUgc3RhdGUgc3RhY2suXG5cbiAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuYnVpbGRGaXJzdFN0YXRlU3RhY2sgPSBmdW5jdGlvbihzdGF0ZSwgdmlzaXRlZCkge1xuICAgICAgICBpZiAodmlzaXRlZC5pbmRleE9mKHN0YXRlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGN5Y2xlLCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgLy8gdG8gZWxpbWluYXRlIHRoaXMgcGF0aCBmcm9tIHRoZSByZXN1bHRzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGhvdyB0byBkaXNwbGF5IGl0IG1lYW5pbmdmdWxseVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLndhbnRlZEJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzdGF0ZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHN0YXRlLndhbnRlZEJ5WzBdO1xuICAgICAgICB2YXIgY2hpbGRWaXNpdGVkID0gW3N0YXRlXS5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IHRoaXMuYnVpbGRGaXJzdFN0YXRlU3RhY2socHJldlN0YXRlLCBjaGlsZFZpc2l0ZWQpO1xuICAgICAgICBpZiAoY2hpbGRSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhdGVdLmNvbmNhdChjaGlsZFJlc3VsdCk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50YWJsZVt0aGlzLmN1cnJlbnRdO1xuICAgICAgICBjb2x1bW4ubGV4ZXJTdGF0ZSA9IHRoaXMubGV4ZXJTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvbHVtbi5pbmRleDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudGFibGVbaW5kZXhdID0gY29sdW1uO1xuICAgICAgICB0aGlzLnRhYmxlLnNwbGljZShpbmRleCArIDEpO1xuICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSBjb2x1bW4ubGV4ZXJTdGF0ZTtcblxuICAgICAgICAvLyBJbmNyZW1lbnRhbGx5IGtlZXAgdHJhY2sgb2YgcmVzdWx0c1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSB0aGlzLmZpbmlzaCgpO1xuICAgIH07XG5cbiAgICAvLyBuYi4gZGVwcmVjYXRlZDogdXNlIHNhdmUvcmVzdG9yZSBpbnN0ZWFkIVxuICAgIFBhcnNlci5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0IG9wdGlvbiBga2VlcEhpc3RvcnlgIHRvIGVuYWJsZSByZXdpbmRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIC8vIG5iLiByZWNhbGwgY29sdW1uICh0YWJsZSkgaW5kaWNpZXMgZmFsbCBiZXR3ZWVuIHRva2VuIGluZGljaWVzLlxuICAgICAgICAvLyAgICAgICAgY29sIDAgICAtLSAgIHRva2VuIDAgICAtLSAgIGNvbCAxXG4gICAgICAgIHRoaXMucmVzdG9yZSh0aGlzLnRhYmxlW2luZGV4XSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcG9zc2libGUgcGFyc2luZ3NcbiAgICAgICAgdmFyIGNvbnNpZGVyYXRpb25zID0gW107XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ3JhbW1hci5zdGFydDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMudGFibGVbdGhpcy50YWJsZS5sZW5ndGggLSAxXVxuICAgICAgICBjb2x1bW4uc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGlmICh0LnJ1bGUubmFtZSA9PT0gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgJiYgdC5kb3QgPT09IHQucnVsZS5zeW1ib2xzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAmJiB0LnJlZmVyZW5jZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAmJiB0LmRhdGEgIT09IFBhcnNlci5mYWlsKSB7XG4gICAgICAgICAgICAgICAgY29uc2lkZXJhdGlvbnMucHVzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25zaWRlcmF0aW9ucy5tYXAoZnVuY3Rpb24oYykge3JldHVybiBjLmRhdGE7IH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xMb25nRGlzcGxheShzeW1ib2wpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ltYm9sO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3ltYm9sLmxpdGVyYWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoYXJhY3RlciBtYXRjaGluZyAnICsgc3ltYm9sO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wudHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2wudHlwZSArICcgdG9rZW4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wudGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndG9rZW4gbWF0Y2hpbmcgJyArIFN0cmluZyhzeW1ib2wudGVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzeW1ib2wgdHlwZTogJyArIHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xTaG9ydERpc3BsYXkoc3ltYm9sKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHN5bWJvbDtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHN5bWJvbC5saXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN5bWJvbC5saXRlcmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ltYm9sIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wudHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJScgKyBzeW1ib2wudHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ltYm9sLnRlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwnICsgU3RyaW5nKHN5bWJvbC50ZXN0KSArICc+JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN5bWJvbCB0eXBlOiAnICsgc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIFBhcnNlcjogUGFyc2VyLFxuICAgICAgICBHcmFtbWFyOiBHcmFtbWFyLFxuICAgICAgICBSdWxlOiBSdWxlLFxuICAgIH07XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8515\n')}}]);