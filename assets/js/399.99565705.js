(self.webpackChunk_sap_csn_interop_renderer_website=self.webpackChunk_sap_csn_interop_renderer_website||[]).push([[399],{1399:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Draft: () => (/* reexport */ Draft),\n  Draft04: () => (/* reexport */ Draft04),\n  Draft06: () => (/* reexport */ Draft06),\n  Draft07: () => (/* reexport */ Draft07),\n  Draft2019: () => (/* reexport */ Draft2019),\n  JsonEditor: () => (/* reexport */ JsonEditor),\n  config: () => (/* binding */ config),\n  createCustomError: () => (/* reexport */ createCustomError),\n  createError: () => (/* reexport */ createError),\n  createNode: () => (/* reexport */ createNode),\n  draft04Config: () => (/* reexport */ draft04Config),\n  draft06Config: () => (/* reexport */ draft06Config),\n  draft07Config: () => (/* reexport */ draft07Config),\n  draft2019Config: () => (/* reexport */ draft2019Config),\n  draftJsonEditorConfig: () => (/* reexport */ draftJsonEditorConfig),\n  getTypeOf: () => (/* reexport */ getTypeOf),\n  isDynamicSchema: () => (/* reexport */ isDynamicSchema),\n  isJsonError: () => (/* reexport */ isJsonError),\n  isSchemaNode: () => (/* reexport */ isSchemaNode),\n  mergeSchema: () => (/* reexport */ mergeSchema),\n  reduceSchema: () => (/* reexport */ reduceSchema),\n  render: () => (/* reexport */ render),\n  resolveAllOf: () => (/* reexport */ resolveAllOf),\n  resolveDynamicSchema: () => (/* reexport */ resolveDynamicSchema),\n  resolveOneOf: () => (/* reexport */ resolveOneOf),\n  resolveOneOfFuzzy: () => (/* reexport */ resolveOneOfFuzzy),\n  resolveRef: () => (/* reexport */ resolveRef_resolveRef),\n  resolveRefStrict: () => (/* reexport */ resolveRef_strict_resolveRef),\n  settings: () => (/* reexport */ settings),\n  validateAsync: () => (/* reexport */ validateAsync)\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/config/strings.js\n/* eslint max-len: 0 */\n/* harmony default export */ const strings = ({\n    // validation errors\n    AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",\n    AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",\n    AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",\n    AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",\n    ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",\n    containsAnyError: "The array at `{{pointer}}` must contain at least one item",\n    ContainsArrayError: "The property at `{{pointer}}` must not be an array",\n    ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",\n    ContainsMinError: "The array at `{{pointer}}` contains {{delta}} too few items matching `{{schema}}`",\n    ContainsMaxError: "The array at `{{pointer}}` contains {{delta}} too many items matching `{{schema}}`",\n    EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",\n    ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",\n    FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",\n    FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",\n    FormatDurationError: "Value `{{value}}` at `{{pointer}}` is not a valid duration",\n    FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",\n    FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",\n    FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",\n    FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",\n    FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",\n    FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",\n    FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",\n    FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",\n    FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",\n    FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",\n    FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",\n    FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",\n    FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",\n    FormatUUIDError: "Value `{{value}}` at `{{pointer}}` is not a valid uuid",\n    InvalidDataError: "No value may be specified in `{{pointer}}`",\n    InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",\n    MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",\n    MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",\n    MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",\n    MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maxProperties}}` at most, but got `{{length}}`",\n    MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",\n    MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",\n    MinItemsOneError: "At least one item is required in `{{pointer}}`",\n    MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",\n    MinLengthOneError: "A value is required in `{{pointer}}`",\n    MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minProperties}}`, but got `{{length}}`",\n    MissingDependencyError: "The required propery \'{{missingProperty}}\' in `{{pointer}}` is missing",\n    MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",\n    MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",\n    MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",\n    NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",\n    NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",\n    OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",\n    OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",\n    PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",\n    PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",\n    RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",\n    SchemaWarning: "Failed retrieving a schema from \'{{pointer}}\' to key \'{{key}}\'",\n    TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",\n    UndefinedValueError: "Value must not be undefined in `{{pointer}}`",\n    UnevaluatedPropertyError: "Invalid unevaluated property `{{pointer}}`",\n    UnevaluatedItemsError: "Invalid unevaluated item `{{pointer}}`",\n    UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",\n    UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",\n    ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/getTypeOf.js\nconst getTypeOf_toString = Object.prototype.toString;\nfunction getTypeOf(value) {\n    const type = getTypeOf_toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === "file") {\n        return "object";\n    }\n    return type;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/render.js\n\nconst OBJECT_TYPE = "object";\nconst ARRAY_TYPE = "array";\n/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nfunction render(template, data = {}) {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, (match) => {\n        const key = match.replace(/[{}]/g, "");\n        const variable = data[key];\n        const variableType = getTypeOf(variable);\n        if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {\n            return JSON.stringify(variable);\n        }\n        return variable;\n    });\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/__.js\n\n\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nfunction __(keyword, data, fallback = keyword) {\n    var _a;\n    const template = (_a = strings[keyword]) !== null && _a !== void 0 ? _a : fallback;\n    return render(template, data);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js\n\nfunction dashCase(text) {\n    return text.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();\n}\nfunction createError(name, data) {\n    return {\n        type: "error",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n/**\n * Creates a custom Error Creator. Its messages are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nfunction createCustomError(name) {\n    return createError.bind(null, name);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js\nfunction flattenArray(list, result = []) {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/config/settings.js\n/* harmony default export */ const settings = ({\n    DECLARATOR_ONEOF: "oneOfProperty",\n    /** set to false to not set __oneOfIndex on returned schema */\n    EXPOSE_ONE_OF_INDEX: true,\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    propertyBlacklist: ["_id"],\n    templateDefaultOptions: {\n        addOptionalProps: false,\n        removeInvalidData: false,\n        extendDefaults: true\n    }\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/types.js\n/**\n * ts type guard for json error\n * @returns true if passed type is a JsonError\n */\nfunction isJsonError(error) {\n    return (error === null || error === void 0 ? void 0 : error.type) === "error";\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/filter.js\n\nfunction isPromise(obj) {\n    return obj instanceof Promise;\n}\nfunction errorOrPromise(error) {\n    return isJsonError(error) || isPromise(error);\n}\nfunction errorsOnly(error) {\n    return isJsonError(error);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/isObject.js\n\nfunction isObject(v) {\n    return getTypeOf(v) === "object";\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/oneOf.js\n/**\n * @draft-04\n */\n\n\n\n\n\nconst { DECLARATOR_ONEOF, EXPOSE_ONE_OF_INDEX } = settings;\nfunction setOneOfOrigin(schema, index) {\n    if (EXPOSE_ONE_OF_INDEX && isObject(schema)) {\n        schema.__oneOfIndex = index;\n    }\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nfunction resolveOneOf(node, data) {\n    const { schema, draft, pointer } = node;\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const oneNode = node.next(schema.oneOf[i]).resolveRef();\n            const resultNode = draft.step(oneNode, oneOfProperty, data);\n            if (isJsonError(resultNode)) {\n                return resultNode;\n            }\n            let result = flattenArray(draft.validate(resultNode, oneOfValue));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                // @evaluation-info\n                setOneOfOrigin(oneNode.schema, i);\n                return resultNode.next(oneNode.schema);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n        let result = flattenArray(draft.validate(oneNode, data));\n        result = result.filter(errorOrPromise);\n        if (result.length > 0) {\n            errors.push(...result);\n        }\n        else {\n            matches.push({ index: i, schema: oneNode.schema });\n        }\n    }\n    if (matches.length === 1) {\n        // @evaluation-info\n        setOneOfOrigin(matches[0].schema, matches[0].index);\n        return node.next(matches[0].schema);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            schema,\n            matches\n        });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n/**\n * Returns a ranking for the data and given schema\n *\n * @param draft\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(node, data) {\n    const { draft, schema, pointer } = node;\n    if (data == null || schema.properties == null) {\n        return -1;\n    }\n    let value = 0;\n    const keys = Object.keys(schema.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key]) {\n            if (draft.isValid(data[key], schema.properties[key], pointer)) {\n                value += 1;\n            }\n        }\n    }\n    return value;\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nfunction resolveOneOfFuzzy(node, data) {\n    const { schema, pointer, draft } = node;\n    if (!Array.isArray(schema.oneOf)) {\n        throw new Error("not a oneof schema");\n        return node;\n    }\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n            const resultNode = draft.step(oneNode, oneOfProperty, data);\n            if (isJsonError(resultNode)) {\n                return resultNode;\n            }\n            let result = flattenArray(draft.validate(resultNode, oneOfValue));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                // @evaluation-info\n                setOneOfOrigin(oneNode.schema, i);\n                return resultNode.next(oneNode.schema);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n        const one = oneNode.schema;\n        if (draft.isValid(data, one, pointer)) {\n            matches.push({ schema: one, index: i });\n        }\n    }\n    if (matches.length === 1) {\n        // @evaluation-info\n        setOneOfOrigin(matches[0].schema, matches[0].index);\n        return node.next(matches[0].schema);\n    }\n    // fuzzy match oneOf\n    if (isObject(data)) {\n        let schemaOfItem;\n        let schemaOfIndex = -1;\n        let fuzzyGreatest = 0;\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n            const fuzzyValue = fuzzyObjectValue(oneNode, data);\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = oneNode.schema;\n                schemaOfIndex = i;\n            }\n        }\n        if (schemaOfItem === undefined) {\n            return draft.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                schema,\n                oneOf: schema.oneOf\n            });\n        }\n        // @evaluation-info\n        setOneOfOrigin(schemaOfItem, schemaOfIndex);\n        return node.next(schemaOfItem);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf\n    });\n}\n/**\n * validates oneOf definition for given input data\n */\nconst validateOneOf = (node, value) => {\n    if (Array.isArray(node.schema.oneOf)) {\n        const nodeOrError = node.draft.resolveOneOf(node, value);\n        if (isJsonError(nodeOrError)) {\n            return nodeOrError;\n        }\n    }\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/mergeSchema.js\n\n\nfunction mergeSchema(a, b, ...omit) {\n    if ((b === null || b === void 0 ? void 0 : b.type) === "error") {\n        return b;\n    }\n    else if ((a === null || a === void 0 ? void 0 : a.type) === "error") {\n        return a;\n    }\n    const aType = getTypeOf(a);\n    const bType = getTypeOf(b);\n    if (aType !== bType) {\n        return a;\n    }\n    const schema = mergeSchema2(a, b);\n    for (let i = 0; i < omit.length; i += 1) {\n        delete schema[omit[i]];\n    }\n    return schema;\n}\nfunction mergeSchema2(a, b, property) {\n    var _a;\n    if (isObject(a) && isObject(b)) {\n        const newObject = {};\n        [...Object.keys(a), ...Object.keys(b)]\n            .filter((item, index, array) => array.indexOf(item) === index)\n            .forEach(key => (newObject[key] = mergeSchema2(a[key], b[key], key)));\n        return newObject;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (property === "required") {\n            return a.concat(b).filter((item, index, array) => array.indexOf(item) === index);\n        }\n        if (property === "items") {\n            const result = [];\n            for (let i = 0; i < b.length; i += 1) {\n                if (isObject(a[i]) && isObject(b[i]) && a[i].type === b[i].type) {\n                    result[i] = mergeSchema2(a[i], b[i]);\n                }\n                else {\n                    result.push((_a = b[i]) !== null && _a !== void 0 ? _a : a[i]);\n                }\n            }\n            return result;\n        }\n        const result = [];\n        const append = [];\n        for (let i = 0; i < Math.max(a.length, b.length); i += 1) {\n            if (isObject(a[i]) && isObject(b[i])) {\n                result[i] = mergeSchema2(a[i], b[i]);\n            }\n            else {\n                if (a[i] !== undefined && b[i] !== undefined) {\n                    result[i] = a[i];\n                    append.push(b[i]);\n                }\n                else if (a[i] !== undefined) {\n                    result[i] = a[i];\n                }\n                else if (b[i] !== undefined) {\n                    append.push(b[i]);\n                }\n            }\n        }\n        return [...result, ...append].filter((item, index, array) => array.indexOf(item) === index);\n    }\n    if (Array.isArray(b)) {\n        return b;\n    }\n    if (Array.isArray(a)) {\n        return a;\n    }\n    if (b !== undefined) {\n        return b;\n    }\n    return a;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/omit.js\n/**\n * Omit properties from input schema. Accepts any number of properties to\n * remove. Example:\n *\n * ```ts\n * omit(myObject, "if", "dependencies");\n * ```\n *\n * @returns shallow copy of input object without specified properties\n */\nfunction omit(object, ...keysToOmit) {\n    const result = {};\n    Object.keys(object).forEach((key) => {\n        if (!keysToOmit.includes(key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/if.js\n/**\n * returns if-then-else as a json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns json schema defined by if-then-else or undefined\n */\nfunction resolveIfSchema(node, data) {\n    if (node.schema.if == null) {\n        return undefined;\n    }\n    if (node.schema.if === false) {\n        // @evaluation-info\n        // schema.__ifelse = true\n        return node.next(node.schema.else);\n    }\n    if (node.schema.if && (node.schema.then || node.schema.else)) {\n        const ifNode = node.draft.resolveRef(node.next(node.schema.if));\n        const ifErrors = node.draft.validate(ifNode, data);\n        if (ifErrors.length === 0 && node.schema.then) {\n            const thenNode = node.next(node.schema.then);\n            // @evaluation-info\n            // schema.__ifthen = true\n            return node.draft.resolveRef(thenNode);\n        }\n        if (ifErrors.length !== 0 && node.schema.else) {\n            const elseNode = node.next(node.schema.else);\n            // @evaluation-info\n            // schema.__ifelse = true\n            return node.draft.resolveRef(elseNode);\n        }\n    }\n    return undefined;\n}\n/**\n * @returns validation result of it-then-else schema\n */\nconst validateIf = (node, value) => {\n    const resolvedNode = resolveIfSchema(node, value);\n    if (resolvedNode) {\n        // @recursiveRef ok, we not just add per pointer, but any evluation to dynamic scope / validation path\n        return node.draft.validate(resolvedNode, value);\n    }\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/shallowCloneSchema.js\nfunction shallowCloneSchemaNode(node) {\n    return { ...node };\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/allOf.js\n\n\n\n\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nfunction resolveSchema(node, data) {\n    const ifSchema = resolveIfSchema(node, data);\n    if (ifSchema) {\n        return ifSchema;\n    }\n    const schema = shallowCloneSchemaNode(node.schema);\n    return node.next(omit(schema, "if", "then", "else"));\n}\nfunction resolveAllOf(node, data) {\n    const { schema } = node;\n    let mergedSchema = shallowCloneSchemaNode(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        const allOfNode = node.next(schema.allOf[i]).resolveRef();\n        // @todo introduce draft.resolveSchema to iteratively resolve\n        const allOfSchema = resolveSchema(allOfNode, data).schema;\n        mergedSchema = mergeSchema(mergedSchema, allOfSchema);\n    }\n    delete mergedSchema.allOf;\n    return node.next(mergedSchema);\n}\n/**\n * @attention: subschemas have to be resolved upfront (e.g. if-else that do not apply)\n * Merge all allOf sub schema into a single schema. Returns undefined for\n * missing allOf definition.\n *\n * @returns json schema defined by allOf or undefined\n */\nfunction mergeAllOfSchema(draft, schema) {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    let resolvedSchema = {};\n    allOf.forEach((subschema) => {\n        if (subschema == null) {\n            return;\n        }\n        const subSchemaNode = draft.createNode(subschema).resolveRef();\n        resolvedSchema = mergeSchema(resolvedSchema, subSchemaNode.schema);\n    });\n    return resolvedSchema;\n}\n/**\n * validate allOf definition for given input data\n */\nconst validateAllOf = (node, value) => {\n    const { draft, schema } = node;\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    const errors = [];\n    schema.allOf.forEach((subSchema) => {\n        errors.push(...draft.validate(node.next(subSchema), value));\n    });\n    return errors;\n};\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/schemaNode.js\n\n\n\n\nfunction merge(schema, ...omit) {\n    if (schema == null) {\n        throw new Error(`undefined schema`);\n    }\n    const node = this;\n    const mergedSchema = mergeSchema(node.schema, schema, ...omit);\n    return { ...node, schema: mergedSchema, path: [...node.path, [node.pointer, node.schema]] };\n}\nfunction resolveRef() {\n    const node = this;\n    return node.draft.resolveRef(node);\n}\nfunction next(schema, key) {\n    if (isJsonError(schema)) {\n        return schema;\n    }\n    if (schema == null) {\n        throw new Error(`undefined schema`);\n    }\n    if (!isObject(schema) && getTypeOf(schema) !== "boolean") {\n        throw new Error(`bad schema type ${getTypeOf(schema)}`);\n    }\n    const node = this;\n    return {\n        ...node,\n        pointer: key ? `${node.pointer}/${key}` : node.pointer,\n        schema,\n        path: [...node.path, [node.pointer, node.schema]]\n    };\n}\nfunction isSchemaNode(value) {\n    // @ts-expect-error unknown object\n    return isObject(value) && value.next && value.path && value.draft;\n}\nfunction createNode(draft, schema, pointer = "#") {\n    return { draft, pointer, schema, path: [], next, merge, resolveRef };\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js\n\nfunction resolveRef_strict_resolveRef(node) {\n    if (!isSchemaNode(node)) {\n        throw new Error("schema node expected");\n    }\n    if (node.schema == null || node.schema.$ref == null) {\n        return node;\n    }\n    if (node.schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = node.schema.getRoot().getRef(node.schema);\n        return node.next(resolvedSchema);\n    }\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = node.draft.rootSchema.getRef(node.schema);\n    return node.next(resolvedSchema);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/resolveRef.js\n\n// 1. https://json-schema.org/draft/2019-09/json-schema-core#scopes\nfunction resolveRecursiveRef(node) {\n    const history = node.path;\n    // console.log(...history);\n    // RESTRICT BY CHANGE IN BASE-URL\n    let startIndex = 0;\n    for (let i = history.length - 1; i >= 0; i--) {\n        const step = history[i][1];\n        if (step.$id && /^https?:\\/\\//.test(step.$id) && step.$recursiveAnchor !== true) {\n            startIndex = i;\n            break;\n        }\n    }\n    // FROM THERE FIND FIRST OCCURENCE OF ANCHOR\n    const firstAnchor = history.find((s, index) => index >= startIndex && s[1].$recursiveAnchor === true);\n    if (firstAnchor) {\n        return node.next(firstAnchor[1]);\n    }\n    // THEN RETURN LATEST BASE AS TARGET\n    for (let i = history.length - 1; i >= 0; i--) {\n        const step = history[i][1];\n        if (step.$id) {\n            return node.next(step);\n        }\n    }\n    // OR RETURN ROOT\n    return node.next(node.draft.rootSchema);\n}\n/**\n * @todo update types\n * Note: JsonSchema my be false\n */\nfunction resolveRef_resolveRef(node) {\n    if (!isSchemaNode(node)) {\n        throw new Error("expected node");\n    }\n    if (node.schema == null) {\n        return node;\n    }\n    if (node.schema.$recursiveRef) {\n        return resolveRef_resolveRef(resolveRecursiveRef(node));\n    }\n    if (node.schema.$ref == null) {\n        return node;\n    }\n    const resolvedSchema = node.draft.rootSchema.getRef(node.schema);\n    if (resolvedSchema === false) {\n        return node.next(resolvedSchema);\n    }\n    // @draft >= 2019-09 we now merge schemas: in draft <= 7 $ref is treated as reference, not as schema\n    return node.merge(resolvedSchema, "$ref");\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/validateAsync.js\n\n\n\nfunction createErrorNotification(onError) {\n    return function notifyError(error) {\n        if (Array.isArray(error)) {\n            error = flattenArray(error);\n            error.forEach(notifyError);\n            return error;\n        }\n        if (isJsonError(error)) {\n            onError(error);\n        }\n        return error;\n    };\n}\n/**\n * @async\n * Validate data by a json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param options\n * @param options.schema - json schema to use, defaults to draft.rootSchema\n * @param options.pointer - json pointer pointing to current value. Used in error reports\n * @param options.onError   - will be called for each error as soon as it is resolved\n * @return list of errors or empty\n */\nfunction validateAsync(draft, value, options) {\n    const { schema, pointer, onError } = { schema: draft.rootSchema, pointer: "#", ...options };\n    let errors = draft.validate(draft.createNode(schema, pointer), value);\n    if (onError) {\n        errors = flattenArray(errors);\n        const notifyError = createErrorNotification(onError);\n        for (let i = 0; i < errors.length; i += 1) {\n            const error = errors[i];\n            if (error instanceof Promise) {\n                error.then(notifyError);\n            }\n            else if (isJsonError(error)) {\n                onError(error);\n            }\n        }\n    }\n    return Promise.all(errors)\n        .then(flattenArray)\n        .then((resolvedErrors) => resolvedErrors.filter(errorsOnly))\n        .catch((e) => {\n        console.log("Failed resolving promises", e.message);\n        console.log(e.stack);\n        throw e;\n    });\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js\n/**\n * @returns list with unique values only\n */\nfunction uniqueItems(list) {\n    return list.filter((item, index) => list.indexOf(item) === index);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/dependencies.js\n\n\n\n\n/**\n * @todo add support for dependentRequired (draft 2019-09)\n * returns dependencies as an object json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns merged json schema defined by dependencies or undefined\n */\nfunction resolveDependencies(node, data) {\n    var _a;\n    const { schema } = node;\n    // @draft >= 2019-09 dependentSchemas\n    const dependencies = (_a = schema.dependencies) !== null && _a !== void 0 ? _a : schema.dependentSchemas;\n    if (!isObject(dependencies) || !isObject(data)) {\n        return;\n    }\n    let updated = false;\n    let resolvedSchema = { required: [] };\n    Object.keys(dependencies).forEach((prop) => {\n        var _a, _b;\n        if (data[prop] == null &&\n            !(((_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {\n            return;\n        }\n        const dependency = dependencies[prop];\n        // dependency array\n        if (Array.isArray(dependency)) {\n            updated = true;\n            resolvedSchema.required.push(...dependency);\n            return;\n        }\n        // dependency schema\n        if (isObject(dependency)) {\n            updated = true;\n            const dNode = node.next(dependency).resolveRef();\n            resolvedSchema = mergeSchema(resolvedSchema, dNode.schema);\n            return;\n        }\n    });\n    if (updated) {\n        resolvedSchema.required = uniqueItems(resolvedSchema.required);\n        return resolvedSchema;\n    }\n}\n/**\n * @draft 2019-09\n */\nconst validateDependentRequired = (node, value) => {\n    const { draft, schema, pointer } = node;\n    const dependentRequired = schema.dependentRequired;\n    if (!isObject(dependentRequired)) {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        const dependencies = dependentRequired[property];\n        // @draft >= 6 boolean schema\n        if (dependencies === true) {\n            return;\n        }\n        if (dependencies === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        if (!Array.isArray(dependencies)) {\n            return;\n        }\n        for (let i = 0, l = dependencies.length; i < l; i += 1) {\n            if (value[dependencies[i]] === undefined) {\n                errors.push(draft.errors.missingDependencyError({ missingProperty: dependencies[i], pointer, schema, value }));\n            }\n        }\n    });\n    return errors;\n};\n/**\n * @draft 2019-09\n */\nconst validateDependentSchemas = (node, value) => {\n    const { draft, schema, pointer } = node;\n    const dependentSchemas = schema.dependentSchemas;\n    if (!isObject(dependentSchemas)) {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        const dependencies = dependentSchemas[property];\n        // @draft >= 6 boolean schema\n        if (dependencies === true) {\n            return;\n        }\n        if (dependencies === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        if (!isObject(dependencies)) {\n            return;\n        }\n        draft.validate(node.next(dependencies), value).map(error => errors.push(error));\n    });\n    return errors;\n};\n/**\n * validate dependencies definition for given input data\n */\nconst validateDependencies = (node, value) => {\n    const { draft, schema, pointer } = node;\n    // @draft >= 2019-09 dependentSchemas\n    const dependencies = schema.dependencies;\n    if (!isObject(dependencies)) {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        if (dependencies[property] === undefined) {\n            return;\n        }\n        // @draft >= 6 boolean schema\n        if (dependencies[property] === true) {\n            return;\n        }\n        if (dependencies[property] === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        let dependencyErrors;\n        const type = getTypeOf(dependencies[property]);\n        const propertyValue = dependencies[property];\n        if (Array.isArray(propertyValue)) {\n            dependencyErrors = propertyValue\n                .filter((dependency) => value[dependency] === undefined)\n                .map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));\n        }\n        else if (type === "object") {\n            dependencyErrors = draft.validate(node.next(dependencies[property]), value);\n        }\n        else {\n            throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);\n        }\n        errors.push(...dependencyErrors);\n    });\n    return errors.length > 0 ? errors : undefined;\n};\n\n;// ./node_modules/json-schema-library/dist/module/lib/features/anyOf.js\n/**\n * @draft-04\n */\n\n/**\n * returns merged schema of all valid anyOf subschemas for the given input data.\n * Does not merge with rest input schema.\n *\n * @returns merged anyOf subschemas which are valid to the given input data.\n */\nfunction mergeValidAnyOfSchema(node, data) {\n    const { draft, schema } = node;\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return;\n    }\n    let resolvedSchema;\n    schema.anyOf.forEach((anySchema) => {\n        const anyNode = draft.resolveRef(node.next(anySchema));\n        if (draft.validate(anyNode, data).length === 0) {\n            resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anyNode.schema) : anyNode.schema;\n        }\n    });\n    if (resolvedSchema) {\n        return node.next(resolvedSchema);\n    }\n}\n/**\n * @unused this function is only exposed via draft and not used otherwise\n * @returns extended input schema with valid anyOf subschemas or JsonError if\n * no anyOf schema matches input data\n */\nfunction resolveAnyOf(node, data) {\n    const { anyOf } = node.schema;\n    if (!Array.isArray(anyOf) || anyOf.length === 0) {\n        return node;\n    }\n    const resolvedNode = mergeValidAnyOfSchema(node, data);\n    if (resolvedNode) {\n        const { pointer, schema } = node;\n        return node.draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });\n    }\n    return node.merge(resolvedNode.schema, "anyOf");\n}\n/**\n * validate anyOf definition for given input data\n */\nconst validateAnyOf = (node, value) => {\n    const { draft, schema, pointer } = node;\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return undefined;\n    }\n    // console.log("validate any of", pointer, value);\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        const nextNode = draft.resolveRef(node.next(schema.anyOf[i]));\n        if (draft.validate(nextNode, value).length === 0) {\n            return undefined;\n        }\n    }\n    return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });\n};\n\n;// ./node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js\n\n\n\n\n\n\n\n\n\nconst toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];\nconst dynamicProperties = ["allOf", "anyOf", "oneOf", "dependencies", "if"];\nfunction isDynamicSchema(schema) {\n    const givenProps = Object.keys(schema);\n    return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;\n}\n/**\n * @note this utility does not reference draft methods for resolution\n * @todo consider using draft methods\n * @todo consider exposing separate info-object (oneOf-Index)\n *\n * Resolves all dynamic schema definitions for the given input data and returns\n * the resulting json-schema without any dynamic schema definitions. The result\n * is not merged with the original input schema, thus static definitions of the\n * input schema are untouched and missing. For a full schema definition of this\n * input data you have to merge the result with the original schema\n * (@see reduceSchema)\n *\n * dynamic schema definitions: dependencies, allOf, anyOf, oneOf, if\n *\n * @returns static schema from resolved dynamic schema definitions for this\n *  specific input data\n */\nfunction resolveDynamicSchema(schemaNode, data) {\n    let resolvedSchema;\n    let error;\n    const node = schemaNode.draft.resolveRef(schemaNode);\n    const { draft } = node;\n    const schema = isSchemaNode(node) ? node.schema : node;\n    // @feature oneOf\n    if (schema.oneOf) {\n        const oneOfSchema = resolveOneOfFuzzy(node, data);\n        if (isJsonError(oneOfSchema)) {\n            error = oneOfSchema;\n        }\n        else if (oneOfSchema) {\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema.schema);\n        }\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const allOf = schema.allOf.map((s) => {\n            // before merging allOf schema we need to resolve all subschemas\n            // if not, we would wrongly merge oneOf, if-then statements, etc\n            if (isDynamicSchema(s)) {\n                // copy of reduceSchema\n                const result = resolveDynamicSchema(node.next(s), data);\n                // note: result has no scope\n                if (result == null || isJsonError(result)) {\n                    return result;\n                }\n                const finalSchema = mergeSchema(s, result.schema);\n                return omit(finalSchema, ...toOmit);\n            }\n            return s;\n        });\n        if (allOf.length > 0) {\n            const allOfSchema = mergeAllOfSchema(draft, { allOf });\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);\n        }\n    }\n    // @feature anyOf\n    const anyNode = mergeValidAnyOfSchema(node, data);\n    if (anyNode && anyNode.schema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyNode.schema);\n    }\n    // @feature dependencies\n    const dependenciesSchema = resolveDependencies(node, data);\n    if (dependenciesSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);\n    }\n    // @feature if-then-else\n    const ifNodeResolved = resolveIfSchema(node, data);\n    if (isSchemaNode(ifNodeResolved)) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifNodeResolved.schema);\n    }\n    if (resolvedSchema == null) {\n        return error;\n    }\n    if (isJsonError(resolvedSchema)) {\n        return resolvedSchema;\n    }\n    const nestedSchema = resolveDynamicSchema(node.next(resolvedSchema), data);\n    if (isSchemaNode(nestedSchema)) {\n        resolvedSchema = mergeSchema(resolvedSchema, nestedSchema.schema);\n    }\n    const finalSchema = omit(resolvedSchema, ...toOmit);\n    return node.next(finalSchema);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/reduceSchema.js\n\n\nconst reduceSchema_toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];\n/**\n * reduces json schema by merging dynamic constructs like if-then-else,\n * dependencies, allOf, anyOf, oneOf, etc into a static json schema\n * omitting those properties.\n *\n * @returns input schema reduced by dynamic schema definitions for the given\n * input data\n */\nfunction reduceSchema(node, data) {\n    const resolvedSchema = resolveDynamicSchema(node, data);\n    if (isSchemaNode(resolvedSchema)) {\n        return node.merge(resolvedSchema.schema, ...reduceSchema_toOmit);\n    }\n    if (resolvedSchema) {\n        return resolvedSchema; // error\n    }\n    return node;\n}\n\n;// ./node_modules/fast-copy/dist/esm/index.mjs\nvar toStringFunction = Function.prototype.toString;\nvar create = Object.create;\nvar toStringObject = Object.prototype.toString;\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nvar LegacyCache = /** @class */ (function () {\n    function LegacyCache() {\n        this._keys = [];\n        this._values = [];\n    }\n    LegacyCache.prototype.has = function (key) {\n        return !!~this._keys.indexOf(key);\n    };\n    LegacyCache.prototype.get = function (key) {\n        return this._values[this._keys.indexOf(key)];\n    };\n    LegacyCache.prototype.set = function (key, value) {\n        this._keys.push(key);\n        this._values.push(value);\n    };\n    return LegacyCache;\n}());\nfunction createCacheLegacy() {\n    return new LegacyCache();\n}\nfunction createCacheModern() {\n    return new WeakMap();\n}\n/**\n * Get a new cache object to prevent circular references.\n */\nvar createCache = typeof WeakMap !== \'undefined\' ? createCacheModern : createCacheLegacy;\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nfunction getCleanClone(prototype) {\n    if (!prototype) {\n        return create(null);\n    }\n    var Constructor = prototype.constructor;\n    if (Constructor === Object) {\n        return prototype === Object.prototype ? {} : create(prototype);\n    }\n    if (Constructor &&\n        ~toStringFunction.call(Constructor).indexOf(\'[native code]\')) {\n        try {\n            return new Constructor();\n        }\n        catch (_a) { }\n    }\n    return create(prototype);\n}\nfunction getRegExpFlagsLegacy(regExp) {\n    var flags = \'\';\n    if (regExp.global) {\n        flags += \'g\';\n    }\n    if (regExp.ignoreCase) {\n        flags += \'i\';\n    }\n    if (regExp.multiline) {\n        flags += \'m\';\n    }\n    if (regExp.unicode) {\n        flags += \'u\';\n    }\n    if (regExp.sticky) {\n        flags += \'y\';\n    }\n    return flags;\n}\nfunction getRegExpFlagsModern(regExp) {\n    return regExp.flags;\n}\n/**\n * Get the flags to apply to the copied regexp.\n */\nvar getRegExpFlags = /test/g.flags === \'g\' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\nfunction getTagLegacy(value) {\n    var type = toStringObject.call(value);\n    return type.substring(8, type.length - 1);\n}\nfunction getTagModern(value) {\n    return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nvar getTag = typeof Symbol !== \'undefined\' ? getTagModern : getTagLegacy;\n\nvar defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar _a = Object.prototype, esm_hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;\nvar SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === \'function\';\nfunction getStrictPropertiesModern(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nvar getStrictProperties = SUPPORTS_SYMBOL\n    ? getStrictPropertiesModern\n    : getOwnPropertyNames;\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict(value, clone, state) {\n    var properties = getStrictProperties(value);\n    for (var index = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index < length_1; ++index) {\n        property = properties[index];\n        if (property === \'callee\' || property === \'caller\') {\n            continue;\n        }\n        descriptor = getOwnPropertyDescriptor(value, property);\n        if (!descriptor) {\n            // In extra edge cases where the property descriptor cannot be retrived, fall back to\n            // the loose assignment.\n            clone[property] = state.copier(value[property], state);\n            continue;\n        }\n        // Only clone the value if actually a value, not a getter / setter.\n        if (!descriptor.get && !descriptor.set) {\n            descriptor.value = state.copier(descriptor.value, state);\n        }\n        try {\n            defineProperty(clone, property, descriptor);\n        }\n        catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array.\n */\nfunction copyArrayLoose(array, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    for (var index = 0, length_2 = array.length; index < length_2; ++index) {\n        clone[index] = state.copier(array[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nfunction copyArrayStrict(array, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    return copyOwnPropertiesStrict(array, clone, state);\n}\n/**\n * Copy the contents of the ArrayBuffer.\n */\nfunction copyArrayBuffer(arrayBuffer, _state) {\n    return arrayBuffer.slice(0);\n}\n/**\n * Create a new Blob with the contents of the original.\n */\nfunction copyBlob(blob, _state) {\n    return blob.slice(0, blob.size, blob.type);\n}\n/**\n * Create a new DataView with the contents of the original.\n */\nfunction copyDataView(dataView, state) {\n    return new state.Constructor(copyArrayBuffer(dataView.buffer));\n}\n/**\n * Create a new Date based on the time of the original.\n */\nfunction copyDate(date, state) {\n    return new state.Constructor(date.getTime());\n}\n/**\n * Deeply copy the keys and values of the original.\n */\nfunction copyMapLoose(map, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(map, clone);\n    map.forEach(function (value, key) {\n        clone.set(key, state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nfunction copyMapStrict(map, state) {\n    return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\nfunction copyObjectLooseLegacy(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (var key in object) {\n        if (esm_hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    return clone;\n}\nfunction copyObjectLooseModern(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (var key in object) {\n        if (esm_hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    var symbols = getOwnPropertySymbols(object);\n    for (var index = 0, length_3 = symbols.length, symbol = void 0; index < length_3; ++index) {\n        symbol = symbols[index];\n        if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = state.copier(object[symbol], state);\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nvar copyObjectLoose = SUPPORTS_SYMBOL\n    ? copyObjectLooseModern\n    : copyObjectLooseLegacy;\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nfunction copyObjectStrict(object, state) {\n    var clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    return copyOwnPropertiesStrict(object, clone, state);\n}\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nfunction copyPrimitiveWrapper(primitiveObject, state) {\n    return new state.Constructor(primitiveObject.valueOf());\n}\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nfunction copyRegExp(regExp, state) {\n    var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));\n    clone.lastIndex = regExp.lastIndex;\n    return clone;\n}\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nfunction copySelf(value, _state) {\n    return value;\n}\n/**\n * Deeply copy the values of the original.\n */\nfunction copySetLoose(set, state) {\n    var clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(set, clone);\n    set.forEach(function (value) {\n        clone.add(state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nfunction copySetStrict(set, state) {\n    return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n\nvar isArray = Array.isArray;\nvar esm_assign = Object.assign;\nvar getPrototypeOf = Object.getPrototypeOf || (function (obj) { return obj.__proto__; });\nvar DEFAULT_LOOSE_OPTIONS = {\n    array: copyArrayLoose,\n    arrayBuffer: copyArrayBuffer,\n    blob: copyBlob,\n    dataView: copyDataView,\n    date: copyDate,\n    error: copySelf,\n    map: copyMapLoose,\n    object: copyObjectLoose,\n    regExp: copyRegExp,\n    set: copySetLoose,\n};\nvar DEFAULT_STRICT_OPTIONS = esm_assign({}, DEFAULT_LOOSE_OPTIONS, {\n    array: copyArrayStrict,\n    map: copyMapStrict,\n    object: copyObjectStrict,\n    set: copySetStrict,\n});\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(options) {\n    return {\n        Arguments: options.object,\n        Array: options.array,\n        ArrayBuffer: options.arrayBuffer,\n        Blob: options.blob,\n        Boolean: copyPrimitiveWrapper,\n        DataView: options.dataView,\n        Date: options.date,\n        Error: options.error,\n        Float32Array: options.arrayBuffer,\n        Float64Array: options.arrayBuffer,\n        Int8Array: options.arrayBuffer,\n        Int16Array: options.arrayBuffer,\n        Int32Array: options.arrayBuffer,\n        Map: options.map,\n        Number: copyPrimitiveWrapper,\n        Object: options.object,\n        Promise: copySelf,\n        RegExp: options.regExp,\n        Set: options.set,\n        String: copyPrimitiveWrapper,\n        WeakMap: copySelf,\n        WeakSet: copySelf,\n        Uint8Array: options.arrayBuffer,\n        Uint8ClampedArray: options.arrayBuffer,\n        Uint16Array: options.arrayBuffer,\n        Uint32Array: options.arrayBuffer,\n        Uint64Array: options.arrayBuffer,\n    };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nfunction createCopier(options) {\n    var normalizedOptions = esm_assign({}, DEFAULT_LOOSE_OPTIONS, options);\n    var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n    var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;\n    function copier(value, state) {\n        state.prototype = state.Constructor = undefined;\n        if (!value || typeof value !== \'object\') {\n            return value;\n        }\n        if (state.cache.has(value)) {\n            return state.cache.get(value);\n        }\n        state.prototype = getPrototypeOf(value);\n        state.Constructor = state.prototype && state.prototype.constructor;\n        // plain objects\n        if (!state.Constructor || state.Constructor === Object) {\n            return object(value, state);\n        }\n        // arrays\n        if (isArray(value)) {\n            return array(value, state);\n        }\n        var tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n        if (tagSpecificCopier) {\n            return tagSpecificCopier(value, state);\n        }\n        return typeof value.then === \'function\' ? value : object(value, state);\n    }\n    return function copy(value) {\n        return copier(value, {\n            Constructor: undefined,\n            cache: createCache(),\n            copier: copier,\n            prototype: undefined,\n        });\n    };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nfunction createStrictCopier(options) {\n    return createCopier(esm_assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nvar copyStrict = createStrictCopier({});\n/**\n * Copy an value deeply as much as possible.\n */\nvar index = createCopier({});\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/copy.js\n\n/* harmony default export */ const copy = (index);\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft/index.js\n\n\n\nclass Draft {\n    constructor(config, schema) {\n        /** cache for remote schemas */\n        this.remotes = {};\n        /** error creators by id */\n        this.errors = {};\n        /** map for valid keywords of a type  */\n        this.typeKeywords = {};\n        /** keyword validators  */\n        this.validateKeyword = {};\n        /** type validators  */\n        this.validateType = {};\n        /** format validators  */\n        this.validateFormat = {};\n        this.config = config;\n        this.typeKeywords = copy(config.typeKeywords);\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n    set rootSchema(rootSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url, schema) {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n    compileSchema(schema) {\n        var _a;\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\n    }\n    createSchemaOf(data) {\n        return this.config.createSchemaOf(data);\n    }\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data, callback, schema, pointer) {\n        const node = this.createNode(schema !== null && schema !== void 0 ? schema : this.rootSchema, pointer);\n        return this.config.each(node, data, callback);\n    }\n    eachSchema(callback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n    getChildSchemaSelection(property, schema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     *\n     * To resolve dynamic schema where the type of json-schema is evaluated by\n     * its value, a data object has to be passed in options.\n     *\n     * Per default this function will return `undefined` for valid properties that\n     * do not have a defined schema. Use the option `withSchemaWarning: true` to\n     * receive an error with `code: schema-warning` containing the location of its\n     * last evaluated json-schema.\n     *\n     * Notes\n     *      - uses draft.step to walk through data and schema\n     *\n     * @param draft\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n     * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n     * @return resolved json-schema object of requested json-pointer location\n     */\n    getSchema(options) {\n        const result = this.getSchemaNode(options);\n        if (isSchemaNode(result)) {\n            return result.schema;\n        }\n        return result;\n    }\n    getSchemaNode(options) {\n        return this.config.getSchema(this, options);\n    }\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data, schema, opts = this.config.templateDefaultOptions) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n    isValid(data, schema, pointer) {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n    createNode(schema, pointer = "#") {\n        return this.config.createNode(this, schema, pointer);\n    }\n    resolveAnyOf(node, data) {\n        return this.config.resolveAnyOf(node, data);\n    }\n    resolveAllOf(node, data) {\n        return this.config.resolveAllOf(node, data);\n    }\n    resolveRef(node) {\n        return this.config.resolveRef(node);\n    }\n    resolveOneOf(node, data) {\n        return this.config.resolveOneOf(node, data);\n    }\n    setSchema(schema) {\n        this.rootSchema = schema;\n    }\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     * This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     * returns the correct schema.\n     *\n     * @param  node\n     * @param  key       - property-name or array-index\n     * @param  data      - parent of key\n     * @return schema-node containing child schema or error if failed resolving key\n     */\n    step(node, key, data) {\n        return this.config.step(node, key, data);\n    }\n    validate(data, schema = this.rootSchema, pointer) {\n        if (isSchemaNode(data)) {\n            const inputData = schema;\n            const inuptNode = data;\n            return this.config.validate(inuptNode, inputData);\n        }\n        if (isJsonError(data)) {\n            return [data];\n        }\n        const node = this.createNode(schema, pointer);\n        return this.config.validate(node, data);\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft04/addRemoteSchema.js\n/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nfunction addRemoteSchema(draft, url, schema) {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/eachSchema.js\n\nfunction eachProperty(property, schema, callback, pointer) {\n    const target = schema[property];\n    if (!isObject(target)) {\n        return;\n    }\n    Object.keys(target).forEach(key => {\n        if (Array.isArray(target[key])) {\n            // ignore depndencies list (of properties)\n            return;\n        }\n        if (key === "$defs") {\n            eachProperty("$defs", target[key], callback, `${pointer}/${property}/$defs`);\n        }\n        else {\n            eachSchema(target[key], callback, `${pointer}/${property}/${key}`);\n        }\n    });\n}\nfunction eachItem(property, schema, callback, pointer) {\n    const target = schema[property];\n    if (!Array.isArray(target)) {\n        return;\n    }\n    target.forEach((s, key) => eachSchema(s, callback, `${pointer}/${property}/${key}`));\n}\nfunction eachSchema(schema, callback, pointer = "") {\n    if (schema === undefined) {\n        return;\n    }\n    // @ts-expect-error untyped\n    if (callback(schema, pointer) === true) {\n        return;\n    }\n    if (!isObject(schema)) {\n        return;\n    }\n    eachProperty("properties", schema, callback, pointer);\n    eachProperty("patternProperties", schema, callback, pointer);\n    eachSchema(schema.not, callback, `${pointer}/not`);\n    eachSchema(schema.additionalProperties, callback, `${pointer}/additionalProperties`);\n    eachProperty("dependencies", schema, callback, pointer);\n    // items\n    isObject(schema.items) && eachSchema(schema.items, callback, `${pointer}/items`);\n    eachItem("items", schema, callback, pointer);\n    // additional items\n    eachSchema(schema.additionalItems, callback, `${pointer}/additionalItems`);\n    // dynamic schemas\n    eachItem("allOf", schema, callback, pointer);\n    eachItem("anyOf", schema, callback, pointer);\n    eachItem("oneOf", schema, callback, pointer);\n    eachSchema(schema.if, callback, `${pointer}/if`);\n    eachSchema(schema.then, callback, `${pointer}/then`);\n    eachSchema(schema.else, callback, `${pointer}/else`);\n    // definitions\n    eachProperty("definitions", schema, callback, pointer);\n    eachProperty("$defs", schema, callback, pointer);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/joinScope.js\n/* eslint max-statements-per-line: ["error", { "max": 2 }] */\nconst suffixes = /(#)+$/;\nconst trailingHash = /#$/;\nconst startingHashAndSlash = /^[#/]+/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\n// @todo add missing test for urn ids\nconst isURN = /^urn:uuid:[0-9A-Fa-f]/;\nfunction joinScope(previous, id) {\n    if (previous == null && id == null) {\n        return "#";\n    }\n    if (id == null) {\n        return previous.replace(trailingHash, "");\n    }\n    if (isURN.test(id)) {\n        return id;\n    }\n    if (previous == null || previous === "" || previous === "#") {\n        return id.replace(trailingHash, "");\n    }\n    if (id[0] === "#") {\n        return `${previous.replace(idAndPointer, "")}${id.replace(suffixes, "")}`;\n    }\n    if (isDomain.test(id)) {\n        return id.replace(trailingHash, "");\n    }\n    if (isDomain.test(previous) && id.startsWith("/")) {\n        // we have a domain that should be joined with an absolute path\n        // thus we have to remove all paths from domain before joining\n        return `${previous.replace(/(^[^:]+:\\/\\/[^/]+)(.*)/, "$1")}/${id.replace(startingHashAndSlash, "")}`;\n    }\n    return `${previous.replace(trailingFragments, "")}/${id.replace(startingHashAndSlash, "")}`;\n}\n\n// EXTERNAL MODULE: ./node_modules/@sagold/json-pointer/dist/jsonPointer.js\nvar jsonPointer = __webpack_require__(2546);\nvar jsonPointer_default = /*#__PURE__*/__webpack_require__.n(jsonPointer);\n;// ./node_modules/json-schema-library/dist/module/lib/compile/splitRef.js\nconst splitRef_suffixes = /(#)+$/g;\nconst emptyValues = ["", null, "#"];\nfunction splitRef($ref) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n    $ref = $ref.replace(splitRef_suffixes, "");\n    if ($ref.indexOf("#") === -1) {\n        return [$ref.replace(/(#|\\/)+$/g, "")];\n    }\n    if ($ref.indexOf("#") === 0) {\n        return [$ref.replace(splitRef_suffixes, "")];\n    }\n    const result = $ref.split("#");\n    result[0] = result[0].replace(/(#|\\/)+$/g, "");\n    result[1] = `#${result[1].replace(splitRef_suffixes, "")}`;\n    return result;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/getRef.js\n\n\n\nconst getRef_suffixes = /(#)+$/g;\nconst getRef_isObject = (val) => getTypeOf(val) === "object";\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nfunction getRef(context, rootSchema, $search) {\n    var _a, _b, _c, _d, _e;\n    let $ref;\n    if (getRef_isObject($search)) {\n        $ref = $search.__ref || $search.$ref;\n    }\n    else {\n        $ref = $search;\n    }\n    if ($ref == null) {\n        return rootSchema;\n    }\n    // console.log("\\n$ref", $ref);\n    let schema;\n    // is it a known $ref?\n    const $remote = $ref.replace(getRef_suffixes, "");\n    if (context.remotes[$remote] != null) {\n        schema = context.remotes[$remote];\n        // console.log("\xbb remote");\n        if (schema && schema.$ref) {\n            // console.log("\xbb\xbb reresolve", schema);\n            // @todo add missing test for the following line\n            return getRef(context, schema, schema);\n        }\n        // console.log("\xbb\xbb return", schema);\n        return schema;\n    }\n    // @ts-expect-error @draft 2019-09\n    const $anchor = (_a = context.anchors) === null || _a === void 0 ? void 0 : _a[$ref];\n    if ($anchor) {\n        // console.log("\xbb anchor", $anchor);\n        return (0,jsonPointer.get)(rootSchema, $anchor);\n    }\n    if (context.ids[$ref] != null) {\n        // console.log("\xbb id", context.ids[$ref]);\n        schema = (0,jsonPointer.get)(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            // @todo add missing test for the following line\n            return getRef(context, rootSchema, schema);\n        }\n        return schema;\n    }\n    const $inputRef = $ref;\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n    if (fragments.length === 1) {\n        // console.log("\xbb frag1", fragments);\n        // console.log("ids", rootSchema.getContext().ids);\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            // console.log("\xbb remote");\n            schema = context.remotes[$ref];\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema);\n            }\n        }\n        if (context.ids[$ref]) {\n            // console.log("\xbb id");\n            schema = (0,jsonPointer.get)(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema);\n            }\n            return schema;\n        }\n        // @todo why this special case\n        const rootContextRef = (_b = rootSchema.getContext) === null || _b === void 0 ? void 0 : _b.call(rootSchema).ids[$ref];\n        if (rootContextRef) {\n            return getRef(context, rootSchema, rootContextRef);\n        }\n    }\n    if (fragments.length === 2) {\n        // console.log("\xbb frag2", fragments);\n        const base = fragments[0];\n        $ref = fragments[1];\n        // @todo this is unnecessary due to inconsistencies\n        const fromRemote = (_c = context.remotes[base]) !== null && _c !== void 0 ? _c : context.remotes[`${base}/`];\n        if (fromRemote) {\n            // console.log("\xbb remote");\n            // We have retrieved a different compiled json-schema. This compiled schema contains a\n            // separate scope (context) where we might need to work with\n            // ANCHOR\n            if (fromRemote.getContext && fromRemote.getContext().anchors[$inputRef] != null) {\n                // console.log("\xbb remote \xbb anchor");\n                // an anchor is stored with its scope (id) it is defined in. Thus collisions are\n                // avoided, but the current condition is required to resolve the anchor for now\n                return fromRemote.getRef($inputRef);\n            }\n            // PATH (get_ref)\n            if (fromRemote.getRef) {\n                // console.log("\xbb remote \xbb ref");\n                // resolve the local part of the reference in the new schema\n                return fromRemote.getRef($ref);\n            }\n            //log("warning: uncompiled remote - context may be wrong", base);\n            return getRef(context, fromRemote, $ref);\n        }\n        // @todo this is unnecessary due to inconsistencies\n        const fromId = (_d = context.ids[base]) !== null && _d !== void 0 ? _d : context.ids[`${base}/`];\n        if (fromId) {\n            // console.log("\xbb id", fromId);\n            return getRef(context, (0,jsonPointer.get)(rootSchema, fromId), $ref);\n        }\n    }\n    // console.log("\xbb other");\n    schema = (0,jsonPointer.get)(rootSchema, (_e = context.ids[$ref]) !== null && _e !== void 0 ? _e : $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema);\n    }\n    return schema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/compile/index.js\n/* eslint max-statements-per-line: ["error", { "max": 2 }] */\n\n\n\n\nconst COMPILED = "__compiled";\nconst COMPILED_REF = "__ref";\nconst GET_REF = "getRef";\nconst GET_ROOT = "getRoot";\nconst compile_suffixes = /(#|\\/)+$/g;\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nfunction compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperties(compiledSchema, {\n        // flag this schema as compiled\n        [COMPILED]: { enumerable: false, value: true },\n        // add getRef-helper to this object\n        [GET_REF]: {\n            enumerable: false,\n            value: getRef.bind(null, context, compiledSchema)\n        }\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes("$ref") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, "definitions", {\n            enumerable: false,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith("http") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, "");\n                const parentSchema = (0,jsonPointer.get)(compiledSchema, parentPointer);\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\n            }\n            context.ids[schema.id.replace(compile_suffixes, "")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, "#");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, "");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, "");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log("compiled ref", scope, schema.$ref, "=>", joinScope(scope, schema.$ref));\n        }\n    });\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/createSchemaOf.js\n\n\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n */\nfunction createSchemaOf(data) {\n    if (data === undefined) {\n        return undefined;\n    }\n    const schema = {\n        type: getTypeOf(data)\n    };\n    if (schema.type === "object" && isObject(data)) {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n    if (schema.type === "array" && Array.isArray(data)) {\n        if (data.length === 1) {\n            schema.items = createSchemaOf(data[0]);\n        }\n        else {\n            schema.items = data.map(createSchemaOf);\n        }\n    }\n    return schema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/validation/errors.js\n/* eslint no-invalid-this: 0 */\n\nconst errors = {\n    additionalItemsError: createCustomError("AdditionalItemsError"),\n    additionalPropertiesError: createCustomError("AdditionalPropertiesError"),\n    allOfError: createCustomError("AllOfError"),\n    anyOfError: createCustomError("AnyOfError"),\n    constError: createCustomError("ConstError"),\n    containsAnyError: createCustomError("ContainsAnyError"),\n    containsArrayError: createCustomError("ContainsArrayError"),\n    containsError: createCustomError("ContainsError"),\n    containsMaxError: createCustomError("ContainsMaxError"),\n    containsMinError: createCustomError("ContainsMinError"),\n    enumError: createCustomError("EnumError"),\n    forbiddenPropertyError: createCustomError("ForbiddenPropertyError"),\n    formatDateError: createCustomError("FormatDateError"),\n    formatDateTimeError: createCustomError("FormatDateTimeError"),\n    formatDurationError: createCustomError("FormatDurationError"),\n    formatEmailError: createCustomError("FormatEmailError"),\n    formatHostnameError: createCustomError("FormatHostnameError"),\n    formatIPV4Error: createCustomError("FormatIPV4Error"),\n    formatIPV4LeadingZeroError: createCustomError("FormatIPV4LeadingZeroError"),\n    formatIPV6Error: createCustomError("FormatIPV6Error"),\n    formatIPV6LeadingZeroError: createCustomError("FormatIPV6LeadingZeroError"),\n    formatJsonPointerError: createCustomError("FormatJsonPointerError"),\n    formatRegExError: createCustomError("FormatRegExError"),\n    formatTimeError: createCustomError("FormatTimeError"),\n    formatURIError: createCustomError("FormatURIError"),\n    formatURIReferenceError: createCustomError("FormatURIReferenceError"),\n    formatURITemplateError: createCustomError("FormatURITemplateError"),\n    formatURLError: createCustomError("FormatURLError"),\n    formatUUIDError: createCustomError("FormatUUIDError"),\n    invalidDataError: createCustomError("InvalidDataError"),\n    invalidPropertyNameError: createCustomError("InvalidPropertyNameError"),\n    invalidSchemaError: createCustomError("InvalidSchemaError"),\n    invalidTypeError: createCustomError("InvalidTypeError"),\n    maximumError: createCustomError("MaximumError"),\n    maxItemsError: createCustomError("MaxItemsError"),\n    maxLengthError: createCustomError("MaxLengthError"),\n    maxPropertiesError: createCustomError("MaxPropertiesError"),\n    minimumError: createCustomError("MinimumError"),\n    minItemsError: createCustomError("MinItemsError"),\n    minItemsOneError: createCustomError("MinItemsOneError"),\n    minLengthError: createCustomError("MinLengthError"),\n    minLengthOneError: createCustomError("MinLengthOneError"),\n    minPropertiesError: createCustomError("MinPropertiesError"),\n    missingDependencyError: createCustomError("MissingDependencyError"),\n    missingOneOfPropertyError: createCustomError("MissingOneOfPropertyError"),\n    multipleOfError: createCustomError("MultipleOfError"),\n    multipleOneOfError: createCustomError("MultipleOneOfError"),\n    noAdditionalPropertiesError: createCustomError("NoAdditionalPropertiesError"),\n    notError: createCustomError("NotError"),\n    oneOfError: createCustomError("OneOfError"),\n    oneOfPropertyError: createCustomError("OneOfPropertyError"),\n    patternError: createCustomError("PatternError"),\n    patternPropertiesError: createCustomError("PatternPropertiesError"),\n    requiredPropertyError: createCustomError("RequiredPropertyError"),\n    schemaWarning: createCustomError("SchemaWarning"),\n    typeError: createCustomError("TypeError"),\n    undefinedValueError: createCustomError("UndefinedValueError"),\n    unevaluatedItemsError: createCustomError("UnevaluatedItemsError"),\n    unevaluatedPropertyError: createCustomError("UnevaluatedPropertyError"),\n    uniqueItemsError: createCustomError("UniqueItemsError"),\n    unknownPropertyError: createCustomError("UnknownPropertyError"),\n    valueNotEmptyError: createCustomError("ValueNotEmptyError")\n};\n/* harmony default export */ const validation_errors = (errors);\n\n// EXTERNAL MODULE: ./node_modules/valid-url/index.js\nvar valid_url = __webpack_require__(7853);\nvar valid_url_default = /*#__PURE__*/__webpack_require__.n(valid_url);\n// EXTERNAL MODULE: ./node_modules/smtp-address-parser/dist/lib/index.js\nvar lib = __webpack_require__(6125);\n;// ./node_modules/json-schema-library/dist/module/lib/validation/format.js\n\n\n\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst matchTime = /^(?<time>(?:([0-1]\\d|2[0-3]):[0-5]\\d:(?<second>[0-5]\\d|60)))(?:\\.\\d+)?(?<offset>(?:z|[+-]([0-1]\\d|2[0-3])(?::?[0-5]\\d)?))$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst isValidJsonPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&\'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&\'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&\'"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&\'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&\'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&\'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20"\'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\nconst isValidDurationString = /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/;\n// Default Json-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators = {\n    date: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\n            return undefined;\n        }\n        return draft.errors.formatDateError({ value, pointer, schema });\n    },\n    "date-time": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        const dateAndTime = value.split(/t/i);\n        if (dateAndTime.length === 2) {\n            const dateIsValid = formatValidators.date(node, dateAndTime[0]) === undefined;\n            const timeIsValid = formatValidators.time(node, dateAndTime[1]) === undefined;\n            if (dateIsValid && timeIsValid) {\n                return undefined;\n            }\n        }\n        return draft.errors.formatDateTimeError({ value, pointer, schema });\n    },\n    duration: (node, value) => {\n        const type = getTypeOf(value);\n        if (type !== "string") {\n            return undefined;\n        }\n        // weeks cannot be combined with other units\n        const isInvalidDurationString = /(\\d+M)(\\d+W)|(\\d+Y)(\\d+W)/;\n        if (!isValidDurationString.test(value) ||\n            isInvalidDurationString.test(value)) {\n            return node.draft.errors.formatDurationError({\n                value,\n                pointer: node.pointer,\n                schema: node.schema\n            });\n        }\n    },\n    email: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (value[0] === \'"\') {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        const [name, host, ...rest] = value.split("@");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (name[0] === "." || name.endsWith(".") || name.includes("..")) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&\'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    /**\n     * @draft 7\n     * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531\n     */\n    "idn-email": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        try {\n            (0,lib.parse)(value);\n            return undefined;\n        }\n        catch (e) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n    },\n    hostname: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string") {\n            return undefined;\n        }\n        if (value === "" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatHostnameError({ value, pointer, schema });\n    },\n    ipv4: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (value && value[0] === "0") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV4Error({ value, pointer, schema });\n    },\n    ipv6: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (value && value[0] === "0") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV6Error({ value, pointer, schema });\n    },\n    "json-pointer": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    "relative-json-pointer": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string") {\n            return undefined;\n        }\n        if (isValidRelativeJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    regex: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value === "string" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            }\n            catch (e) { } // eslint-disable-line no-empty\n            return draft.errors.formatRegExError({ value, pointer, schema });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === "object" || typeof value === "number" || Array.isArray(value)) {\n            return undefined;\n        }\n        return draft.errors.formatRegExError({ value, pointer, schema });\n    },\n    // hh:mm:ss.sTZD\n    // RFC 3339 https://datatracker.ietf.org/doc/html/rfc3339#section-4\n    time: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        // leap second\n        if (matches.groups.second === "60") {\n            // bail early\n            if (/23:59:60(z|\\+00:00)/i.test(value)) {\n                return undefined;\n            }\n            // check if sum matches 23:59\n            const minutes = matches.groups.time.match(/(\\d+):(\\d+):/);\n            const offsetMinutes = matches.groups.offset.match(/(\\d+):(\\d+)/);\n            if (offsetMinutes) {\n                const hour = parseInt(minutes[1]);\n                const offsetHour = parseInt(offsetMinutes[1]);\n                const min = parseInt(minutes[2]);\n                const offsetMin = parseInt(offsetMinutes[2]);\n                let deltaTime;\n                if (/^-/.test(matches.groups.offset)) {\n                    deltaTime = (hour + offsetHour) * 60 + (min + offsetMin);\n                }\n                else {\n                    deltaTime = (24 + hour - offsetHour) * 60 + (min - offsetMin);\n                }\n                const hours = Math.floor(deltaTime / 60);\n                const actualHour = hours % 24;\n                const actualMinutes = deltaTime - hours * 60;\n                if (actualHour === 23 && actualMinutes === 59) {\n                    return undefined;\n                }\n            }\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    uri: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (valid_url_default().isUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIError({ value, pointer, schema });\n    },\n    "uri-reference": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIReferenceError({ value, pointer, schema });\n    },\n    "uri-template": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURITemplateError({ value, pointer, schema });\n    },\n    url: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (value === "" || valid_url_default().isWebUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURLError({ value, pointer, schema });\n    },\n    uuid: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== "string" || value === "") {\n            return undefined;\n        }\n        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatUUIDError({ value, pointer, schema });\n    }\n};\n/* harmony default export */ const format = (formatValidators);\n\n;// ./node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js\n\n\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param draft       - draft to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nfunction getChildSchemaSelection(draft, property, schema = draft.rootSchema) {\n    var _a;\n    if (schema.oneOf) {\n        return schema.oneOf.map((item) => draft.createNode(item).resolveRef().schema);\n    }\n    if ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.oneOf) {\n        return schema.items.oneOf.map((item) => draft.createNode(item).resolveRef().schema);\n    }\n    // array.items[] found\n    if (Array.isArray(schema.items) && schema.items.length > +property) {\n        return [draft.step(draft.createNode(schema), property, {}).schema];\n    }\n    // array.items[] exceeded (or undefined), but additionalItems specified\n    if (schema.additionalItems && !isObject(schema.items)) {\n        // we fallback to a string if no schema is defined - might be subject for configuration\n        const additionalSchema = schema.additionalItems === true ? { type: "string" } : schema.additionalItems;\n        return [draft.createNode(additionalSchema).resolveRef().schema];\n    }\n    // array.items[] exceeded\n    if (Array.isArray(schema.items) && schema.items.length <= +property) {\n        return [];\n    }\n    const node = draft.step(draft.createNode(schema), property, {});\n    if (isJsonError(node)) {\n        const error = node;\n        return error;\n    }\n    return [node.schema];\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/getSchema.js\n\n\nconst emptyObject = {};\n/**\n * Returns a node containing json-schema of a data-json-pointer.\n *\n * To resolve dynamic schema where the type of json-schema is evaluated by\n * its value, a data object has to be passed in options.\n *\n * Per default this function will return `undefined` schema for valid properties\n * that do not have a defined schema. Use the option `withSchemaWarning: true` to\n * receive an error with `code: schema-warning` containing the location of its\n * last evaluated json-schema.\n *\n * Example:\n *\n * ```ts\n * draft.setSchema({ type: "object", properties: { title: { type: "string" } } });\n * const result = draft.getSchema({  pointer: "#/title" }, data: { title: "my header" });\n * const schema = isSchemaNode(result) ? result.schema : undefined;\n * // schema = { type: "string" }\n * ```\n *\n * @param draft\n * @param [options.pointer] - json pointer in data to get the json schema for\n * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n * @return json-error or node containing schema of requested json-pointer location\n */\nfunction getSchema(draft, options = emptyObject) {\n    const { pointer = "#", data, schema = draft.rootSchema, withSchemaWarning = false } = options;\n    const path = jsonPointer_default().split(pointer);\n    const node = draft.createNode(schema).resolveRef();\n    const result = _getSchema(node, path, data);\n    if (!withSchemaWarning && isJsonError(result) && result.code === "schema-warning") {\n        return draft.createNode(undefined);\n    }\n    return result;\n}\nfunction _getSchema(node, path, data = emptyObject) {\n    if (path.length === 0) {\n        return node.resolveRef();\n    }\n    const key = path.shift(); // step key\n    const nextNode = node.draft.step(node, key, data); // step schema\n    if (isJsonError(nextNode)) {\n        return nextNode;\n    }\n    // @ts-expect-error data\n    data = data[key]; // step data\n    return _getSchema(nextNode, path, data);\n}\n\n// EXTERNAL MODULE: ./node_modules/deepmerge/dist/cjs.js\nvar cjs = __webpack_require__(4744);\nvar cjs_default = /*#__PURE__*/__webpack_require__.n(cjs);\n;// ./node_modules/json-schema-library/dist/module/lib/utils/merge.js\n\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\n/* harmony default export */ const utils_merge = ((a, b) => cjs_default()(a, b, { arrayMerge: overwriteMerge }));\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nconst mergeArraysUnique = (a, b) => deepmerge(a, b, { arrayMerge: mergeUniqueItems });\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js\n\nfunction isEmpty(v) {\n    const type = getTypeOf(v);\n    switch (type) {\n        case "string":\n        case "array":\n            // @ts-expect-error tested as array - could use ts type guard\n            return (v === null || v === void 0 ? void 0 : v.length) === 0;\n        case "null":\n        case "undefined":\n            return true;\n        case "object":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/getTemplate.js\n/* eslint quote-props: 0, max-statements-per-line: ["error", { "max": 2 }] */\n\n\n\n\n\n\n\n\n\n\n\n\nconst defaultOptions = settings.templateDefaultOptions;\nlet cache;\nfunction shouldResolveRef(schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\nfunction getTemplate_resolveRef(draft, schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n    // @todo pointer + ref is redundant?\n    cache[pointer] = cache[pointer] || {};\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\n    cache[pointer][$ref] += 1;\n    return draft.createNode(schema, pointer).resolveRef().schema;\n}\nfunction convertValue(type, value) {\n    if (type === "string") {\n        return JSON.stringify(value);\n    }\n    else if (typeof value !== "string") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    }\n    catch (e) { } // eslint-disable-line no-empty\n    return null;\n}\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n *\n * @param draft\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(draft, schema, data, pointer, opts) {\n    // invalid schema\n    if (getTypeOf(schema) !== "object") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n    // resolve $ref and copy schema\n    let templateSchema = copy(getTemplate_resolveRef(draft, schema, pointer));\n    // @feature anyOf\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = getTemplate_resolveRef(draft, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = utils_merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const mayResolve = schema.allOf\n            .map((allOf, index) => shouldResolveRef(allOf, `${pointer}/allOf/${index}`))\n            .reduceRight((next, before) => next && before, true);\n        if (mayResolve) {\n            // before merging all-of, we need to resolve all if-then-else statesments\n            // we need to udpate data on the way to trigger if-then-else schemas sequentially.\n            // Note that this will make if-then-else order-dependent\n            const allOf = [];\n            let extendedData = copy(data);\n            for (let i = 0; i < schema.allOf.length; i += 1) {\n                const allNode = draft.createNode(schema.allOf[i], pointer);\n                allOf.push(resolveSchema(allNode, extendedData).schema);\n                extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);\n            }\n            const resolvedSchema = mergeAllOfSchema(draft, { allOf });\n            if (resolvedSchema) {\n                templateSchema = mergeSchema(templateSchema, resolvedSchema);\n            }\n        }\n    }\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\nconst isJsonSchema = (template) => template && typeof template === "object";\n/**\n * Create data object matching the given schema\n *\n * @param draft - json schema draft\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(draft, data, _schema, pointer, opts) {\n    var _a;\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error("Missing pointer");\n    }\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(draft, _schema, data, pointer, opts);\n    if (!isJsonSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\n        return schema.const;\n    }\n    // @feature oneOf\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type = schema.oneOf[0].type || schema.type || (schema.const && typeof schema.const) || getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        }\n        else {\n            // find correct schema for data\n            const oneNode = draft.createNode(schema, pointer);\n            const resolvedNode = resolveOneOfFuzzy(oneNode, data);\n            if (isJsonError(resolvedNode)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            }\n            else {\n                const resolvedSchema = resolvedNode.schema;\n                resolvedSchema.type = (_a = resolvedSchema.type) !== null && _a !== void 0 ? _a : schema.type;\n                schema = resolvedSchema;\n            }\n        }\n    }\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n    if (!isJsonSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n    // @attention - very special case to support file instances\n    if (data instanceof File) {\n        return data;\n    }\n    const type = Array.isArray(schema.type) ? selectType(schema.type, data, schema.default) : schema.type;\n    // reset invalid type\n    const javascriptTypeOfData = getTypeOf(data);\n    if (data != null && javascriptTypeOfData !== type && !(javascriptTypeOfData === "number" && type === "integer")) {\n        data = convertValue(type, data);\n    }\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n    const templateData = TYPE[type](draft, schema, data, pointer, opts);\n    return templateData;\n}\nfunction selectType(types, data, defaultValue) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\nconst TYPE = {\n    null: (draft, schema, data) => getDefault(schema, data, null),\n    string: (draft, schema, data) => getDefault(schema, data, ""),\n    number: (draft, schema, data) => getDefault(schema, data, 0),\n    integer: (draft, schema, data) => getDefault(schema, data, 0),\n    boolean: (draft, schema, data) => getDefault(schema, data, false),\n    object: (draft, schema, data, pointer, opts) => {\n        var _a;\n        const template = schema.default === undefined ? {} : schema.default;\n        const d = {}; // do not assign data here, to keep ordering from json-schema\n        const required = opts.extendDefaults === false && schema.default !== undefined ? [] : ((_a = schema.required) !== null && _a !== void 0 ? _a : []);\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\n                }\n            });\n        }\n        // @feature dependencies\n        // has to be done after resolving properties so dependency may trigger\n        const dNode = draft.createNode(schema, pointer);\n        let dependenciesSchema = resolveDependencies(dNode, d);\n        if (dependenciesSchema) {\n            dependenciesSchema = mergeSchema(schema, dependenciesSchema);\n            delete dependenciesSchema.dependencies;\n            const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);\n            Object.assign(d, dependencyData);\n        }\n        if (data) {\n            if (opts.removeInvalidData === true &&\n                (schema.additionalProperties === false || getTypeOf(schema.additionalProperties) === "object")) {\n                if (getTypeOf(schema.additionalProperties) === "object") {\n                    Object.keys(data).forEach((key) => {\n                        if (d[key] == null) {\n                            // merge valid missing data (additionals) to resulting object\n                            if (draft.isValid(data[key], schema.additionalProperties)) {\n                                d[key] = data[key];\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                // merge any missing data (additionals) to resulting object\n                Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n            }\n        }\n        // @feature if-then-else\n        const node = draft.createNode(schema, pointer);\n        const ifSchema = resolveIfSchema(node, d);\n        if (isSchemaNode(ifSchema)) {\n            const additionalData = getTemplate(draft, d, { type: "object", ...ifSchema.schema }, pointer, opts);\n            Object.assign(d, additionalData);\n        }\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (draft, schema, data, pointer, opts) => {\n        var _a, _b, _c;\n        const template = schema.default === undefined ? [] : schema.default;\n        const d = data || template;\n        const minItems = opts.extendDefaults === false && schema.default !== undefined ? 0 : ((_a = schema.minItems) !== null && _a !== void 0 ? _a : 0);\n        if (schema.items == null) {\n            if (schema.additionalItems) {\n                // items-array was processed & this is not an items-schema\n                // => all items are additionalItems\n                const itemCount = Math.max(minItems, d.length);\n                for (let i = 0; i < itemCount; i += 1) {\n                    d[i] = getTemplate(draft, d[i], schema.additionalItems, `${pointer}/additionalItems`, opts);\n                }\n            }\n            return data || []; // items are undefined\n        }\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            const length = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_c = (_b = schema.items) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0);\n            for (let i = 0; i < length; i += 1) {\n                if (schema.items[i]) {\n                    d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\n                }\n                else if (schema.additionalItems) {\n                    d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.additionalItems, `${pointer}/additionalItems`, opts);\n                }\n            }\n            return d;\n        }\n        // no items-schema - return\n        if (getTypeOf(schema.items) !== "object") {\n            return d;\n        }\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n        // build data for first oneOf-schema\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < minItems; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\n            }\n            return d;\n        }\n        // complete data selecting correct oneOf-schema\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                const oneNode = draft.createNode(templateSchema, pointer);\n                let one = resolveOneOfFuzzy(oneNode, value);\n                if (one == null || isJsonError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    }\n                    else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                }\n                else {\n                    // schema is valid\n                    d[i] = getTemplate(draft, value, one.schema, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n        // build data from items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\n            }\n            return d;\n        }\n        return d;\n    }\n};\nfunction getDefault(schema, templateValue, initValue) {\n    if (templateValue != null) {\n        return templateValue;\n    }\n    else if (schema.const) {\n        return schema.const;\n    }\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    }\n    else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\n/* harmony default export */ const lib_getTemplate = ((draft, data, schema = draft.rootSchema, opts) => {\n    cache = {};\n    if (opts) {\n        return getTemplate(draft, data, schema, "#", { ...defaultOptions, ...opts });\n    }\n    return getTemplate(draft, data, schema, "#", defaultOptions);\n});\n\n;// ./node_modules/json-schema-library/dist/module/lib/isValid.js\n/**\n * Test if the data is valid according to the given schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nfunction isValid(draft, value, schema = draft.rootSchema, pointer = "#") {\n    const node = draft.createNode(schema, pointer);\n    return draft.validate(node, value).length === 0;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js\n/* eslint no-bitwise: 0 */\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nfunction ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It\'s a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It\'s an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js\n/**\n * returns the floating point precision of a decimal number or 0\n */\nfunction getPrecision(value) {\n    const string = `${value}`;\n    if (string.includes("e-")) {\n        return parseInt(string.replace(/.*e-/, ""));\n    }\n    const index = string.indexOf(".");\n    return index === -1 ? 0 : string.length - (index + 1);\n}\n\n// EXTERNAL MODULE: ./node_modules/fast-deep-equal/index.js\nvar fast_deep_equal = __webpack_require__(2017);\nvar fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);\n;// ./node_modules/json-schema-library/dist/module/lib/validation/keyword.js\n\n\n\n\n\n\n\n\n\n\n\nconst keyword_hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value, property) => !(value[property] === undefined || !keyword_hasOwnProperty.call(value, property));\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation = {\n    additionalProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n        if (getTypeOf(schema.patternProperties) === "object" &&\n            schema.additionalProperties === false) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n        const errors = [];\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\n        const expectedProperties = Object.keys(schema.properties || {});\n        if (getTypeOf(schema.patternProperties) === "object") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const additionalIsObject = isObject(schema.additionalProperties);\n                // additionalProperties { oneOf: [] }\n                if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = draft.resolveOneOf(node.next(schema.additionalProperties), value[property]);\n                    if (isJsonError(result)) {\n                        errors.push(draft.errors.additionalPropertiesError({\n                            pointer,\n                            schema: schema.additionalProperties,\n                            value,\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            // pass all validation errors\n                            errors: result.data.errors\n                        }));\n                    }\n                    else {\n                        errors.push(...draft.validate(node.next(result, property), value[property]));\n                    }\n                    // additionalProperties {}\n                }\n                else if (additionalIsObject) {\n                    const res = draft.validate(node.next(schema.additionalProperties, property), value[property]);\n                    errors.push(...res);\n                }\n                else {\n                    errors.push(draft.errors.noAdditionalPropertiesError({\n                        pointer,\n                        schema,\n                        value,\n                        property: receivedProperties[i],\n                        properties: expectedProperties\n                    }));\n                }\n            }\n        }\n        return errors;\n    },\n    allOf: validateAllOf,\n    anyOf: validateAnyOf,\n    dependencies: validateDependencies,\n    enum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const type = getTypeOf(value);\n        if (type === "object" || type === "array") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        }\n        else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return draft.errors.enumError({ pointer, schema, value, values: schema.enum });\n    },\n    format: (node, value) => {\n        const { draft, schema } = node;\n        if (draft.validateFormat[schema.format]) {\n            const errors = draft.validateFormat[schema.format](node, value);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (node, value) => {\n        const { draft, schema, pointer } = node;\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidDataError({ pointer, value, schema });\n        }\n        const errors = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemNode = draft.step(node.next(schema), i, value);\n            if (isJsonError(itemNode)) {\n                return [itemNode];\n            }\n            const itemErrors = draft.validate(itemNode, itemData);\n            errors.push(...itemErrors);\n        }\n        return errors;\n    },\n    maximum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                value,\n                pointer,\n                schema\n            });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxItems: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return draft.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return draft.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return draft.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minLength: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return draft.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minItems: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return draft.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return draft.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.multipleOf) || typeof value !== "number") {\n            return undefined;\n        }\n        const valuePrecision = getPrecision(value);\n        const multiplePrecision = getPrecision(schema.multipleOf);\n        if (valuePrecision > multiplePrecision) {\n            // value with higher precision then multipleOf-precision can never be multiple\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        const precision = Math.pow(10, multiplePrecision);\n        const val = Math.round(value * precision);\n        const multiple = Math.round(schema.multipleOf * precision);\n        if ((val % multiple) / precision !== 0) {\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        // maybe also check overflow\n        // https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const errors = [];\n        if (draft.validate(node.next(schema.not), value).length === 0) {\n            errors.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));\n        }\n        return errors;\n    },\n    oneOf: validateOneOf,\n    pattern: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const pattern = new RegExp(schema.pattern, "u");\n        if (pattern.test(value) === false) {\n            return draft.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== "object") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    schema,\n                    value,\n                    patterns: Object.keys(pp).join(",")\n                }));\n            }\n        });\n        return errors;\n    },\n    properties: (node, value) => {\n        const { draft, schema } = node;\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemNode = draft.step(node, key, value);\n                if (isJsonError(itemNode)) {\n                    errors.push(itemNode);\n                }\n                else {\n                    const keyErrors = draft.validate(itemNode, value[key]);\n                    errors.push(...keyErrors);\n                }\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));\n            }\n            else {\n                const itemNode = draft.step(node, key, value);\n                const keyErrors = draft.validate(itemNode, value[key]);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (!hasProperty(value, property)) {\n                return draft.errors.requiredPropertyError({\n                    key: property,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (node, value) => {\n        const { schema } = node;\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            const { draft, schema, pointer } = node;\n            if (value[property] == null || value[property] === "") {\n                return draft.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n        const duplicates = [];\n        const errors = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (fast_deep_equal_default()(item, value[i]) && !duplicates.includes(i)) {\n                    errors.push(draft.errors.uniqueItemsError({\n                        pointer: `${pointer}/${i}`,\n                        duplicatePointer: `${pointer}/${index}`,\n                        arrayPointer: pointer,\n                        value: JSON.stringify(item),\n                        schema\n                    }));\n                    duplicates.push(i);\n                }\n            }\n        });\n        return errors;\n    }\n};\n/* harmony default export */ const keyword = (KeywordValidation);\n\n;// ./node_modules/json-schema-library/dist/module/lib/step.js\n\n\n\n\nconst stepType = {\n    array: (node, key, data) => {\n        const { draft, schema, pointer } = node;\n        const itemValue = data === null || data === void 0 ? void 0 : data[key];\n        const itemsType = getTypeOf(schema.items);\n        if (itemsType === "object") {\n            // @spec: ignore additionalItems, when items is schema-object\n            return reduceSchema(node.next(schema.items, key), itemValue);\n        }\n        if (itemsType === "array") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return node.next(createSchemaOf(itemValue), key);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return draft.errors.invalidDataError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.items[key]) {\n                return draft.resolveRef(node.next(schema.items[key], key));\n            }\n            if (schema.additionalItems === false) {\n                return draft.errors.additionalItemsError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return node.next(createSchemaOf(itemValue), key);\n            }\n            if (getTypeOf(schema.additionalItems) === "object") {\n                return node.next(schema.additionalItems, key);\n            }\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);\n        }\n        if (schema.additionalItems !== false && itemValue) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return node.next(createSchemaOf(itemValue), key);\n        }\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\n    },\n    object: (node, key, data) => {\n        var _a, _b;\n        const { draft, pointer } = node;\n        const reduction = reduceSchema(node, data);\n        const schema = ((_a = reduction.schema) !== null && _a !== void 0 ? _a : reduction);\n        // @feature properties\n        const property = (_b = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _b === void 0 ? void 0 : _b[key];\n        if (property !== undefined) {\n            // @todo patternProperties also validate properties\n            // @feature boolean schema\n            if (property === false) {\n                return draft.errors.forbiddenPropertyError({\n                    property: key,\n                    value: data,\n                    pointer,\n                    schema\n                });\n            }\n            else if (property === true) {\n                return node.next(createSchemaOf(data === null || data === void 0 ? void 0 : data[key]), key);\n            }\n            const nextPropertyNode = draft.resolveRef(node.next(property, key));\n            if (isJsonError(nextPropertyNode)) {\n                return nextPropertyNode;\n            }\n            // check if there is a oneOf selection, which must be resolved\n            if (nextPropertyNode && Array.isArray(nextPropertyNode.schema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                const nextNode = node.next(nextPropertyNode.schema, key);\n                const result = draft.resolveOneOf(nextNode, data[key]);\n                if (isJsonError(result)) {\n                    return result;\n                }\n                return nextNode.merge(result.schema, "oneOf");\n            }\n            if (nextPropertyNode) {\n                return nextPropertyNode;\n            }\n        }\n        // @feature patternProperties\n        const { patternProperties } = schema;\n        if (getTypeOf(patternProperties) === "object") {\n            // find matching property key\n            let regex;\n            const patterns = Object.keys(patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return node.next(patternProperties[patterns[i]], key);\n                }\n            }\n        }\n        // @feature additionalProperties\n        const { additionalProperties } = schema;\n        if (getTypeOf(additionalProperties) === "object") {\n            return node.next(schema.additionalProperties, key);\n        }\n        if (data && (additionalProperties === undefined || additionalProperties === true)) {\n            const generatedSchema = createSchemaOf(data[key]);\n            return generatedSchema ? node.next(generatedSchema, key) : undefined;\n        }\n        return draft.errors.unknownPropertyError({\n            property: key,\n            value: data,\n            pointer: `${pointer}`,\n            schema\n        });\n    }\n};\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  draft      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nfunction step(node, key, data) {\n    var _a;\n    const { draft, schema, pointer } = node;\n    const typeOfData = getTypeOf(data);\n    let schemaType = (_a = schema.type) !== null && _a !== void 0 ? _a : typeOfData;\n    // @draft >= 4 ?\n    if (Array.isArray(schemaType)) {\n        if (!schemaType.includes(typeOfData)) {\n            return draft.errors.typeError({\n                value: data,\n                pointer,\n                expected: schema.type,\n                received: typeOfData,\n                schema\n            });\n        }\n        schemaType = typeOfData;\n    }\n    const stepFunction = stepType[schemaType];\n    if (stepFunction) {\n        const childNode = stepFunction(node, `${key}`, data);\n        if (childNode === undefined) {\n            return draft.errors.schemaWarning({ pointer, value: data, schema, key });\n        }\n        return childNode;\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/validation/type.js\n/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-node.draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators = {\n    array: (node, value) => node.draft.typeKeywords.array\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    object: (node, value) => node.draft.typeKeywords.object\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    string: (node, value) => node.draft.typeKeywords.string\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    integer: (node, value) => node.draft.typeKeywords.number\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    number: (node, value) => node.draft.typeKeywords.number\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    boolean: (node, value) => node.draft.typeKeywords.boolean\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    null: (node, value) => node.draft.typeKeywords.null\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value))\n};\n/* harmony default export */ const type = (typeValidators);\n\n;// ./node_modules/json-schema-library/dist/module/lib/validate.js\n\n\n\n\n\n\nfunction getJsonSchemaType(value, expectedType) {\n    const jsType = getTypeOf(value);\n    if (jsType === "number" &&\n        (expectedType === "integer" ||\n            (Array.isArray(expectedType) && expectedType.includes("integer")))) {\n        return Number.isInteger(value) || isNaN(value) ? "integer" : "number";\n    }\n    return jsType;\n}\n/**\n * Validates data with json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nfunction validate(node, value) {\n    if (!isSchemaNode(node)) {\n        throw new Error("node expected");\n    }\n    const { draft, pointer } = node;\n    node = node.resolveRef();\n    const schema = node.schema;\n    if (schema == null) {\n        throw new Error("missing schema");\n    }\n    // @draft >= 07\n    if (getTypeOf(schema) === "boolean") {\n        if (schema) {\n            return [];\n        }\n        return [draft.errors.invalidDataError({ pointer, schema, value })];\n    }\n    if (isJsonError(schema)) {\n        return [schema];\n    }\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (fast_deep_equal_default()(schema.const, value)) {\n            return [];\n        }\n        return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];\n    }\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n    if (receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\n        return [\n            draft.errors.typeError({\n                pointer,\n                schema,\n                value,\n                received: receivedType,\n                expected: expectedType\n            })\n        ];\n    }\n    if (draft.validateType[receivedType] == null) {\n        return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];\n    }\n    // get type validation results\n    const errors = flattenArray(draft.validateType[receivedType](node, value));\n    return errors.filter(errorOrPromise); // ignore promises here\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/each.js\n\n\n/**\n * Iterates over data, retrieving its schema\n *\n * @param draft - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nfunction each(schemaNode, data, callback) {\n    const node = schemaNode.resolveRef();\n    const { draft, schema, pointer } = node;\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n    if (dataType === "object") {\n        Object.keys(data).forEach((key) => {\n            const nextNode = draft.step(node, key, data);\n            if (isSchemaNode(nextNode)) {\n                each(nextNode, data[key], callback);\n            }\n        });\n    }\n    else if (dataType === "array") {\n        data.forEach((next, key) => {\n            const nextNode = draft.step(node, key, data);\n            if (isSchemaNode(nextNode)) {\n                each(nextNode, data[key], callback);\n            }\n        });\n    }\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft04/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft04Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "uniqueItems"\n        ],\n        boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],\n        object: [\n            "additionalProperties",\n            "dependencies",\n            "enum",\n            "format",\n            "minProperties",\n            "maxProperties",\n            "patternProperties",\n            "properties",\n            "required",\n            "not",\n            "oneOf",\n            "allOf",\n            "anyOf"\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    createNode: createNode,\n    validateKeyword: keyword,\n    validateType: type,\n    validateFormat: format,\n    errors: validation_errors,\n    addRemoteSchema: addRemoteSchema,\n    compileSchema: compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef_strict_resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft04 extends Draft {\n    constructor(schema, config = {}) {\n        super(utils_merge(draft04Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js\n/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nfunction addRemoteSchema_addRemoteSchema(draft, url, schema) {\n    // @draft >= 6\n    schema.$id = schema.$id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js\n\n// import remotes from "../../../remotes";\n\n\n\nconst compile_COMPILED = "__compiled";\nconst compile_COMPILED_REF = "__ref";\nconst compile_GET_REF = "getRef";\nconst compile_GET_ROOT = "getRoot";\nconst GET_CONTEXT = "getContext";\nconst draft06_compile_suffixes = /(#|\\/)+$/g;\n/**\n * @draft 6, 2019-09\n * - starting with _draft 2019-09_ plain name fragments are no longer defined with $id,\n *  but instead with the new keyword $anchor (which has a different syntax)\n *  https://json-schema.org/draft/2019-09/release-notes#incompatible-changes\n * - in _draft 2019-09_ only $recursiveAnchor and $recursiveRef have been introduced\n * - starting with _draft 6_ id is named $id\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nfunction compile_compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    // @ts-expect-error incomplete JsonSchema type\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[compile_COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    // console.log("compile schema", schemaToCompile.$id);\n    const context = { ids: {}, anchors: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperties(compiledSchema, {\n        [compile_COMPILED]: { enumerable: false, value: true },\n        [GET_CONTEXT]: { enumerable: false, value: () => context },\n        [compile_GET_REF]: {\n            enumerable: false,\n            value: getRef.bind(null, context, compiledSchema)\n        }\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes("$ref") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, "$defs", {\n            enumerable: true,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith("http") && /(allOf|anyOf|oneOf|if)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf|if)\\/\\d+$/, "");\n                const parentSchema = (0,jsonPointer.get)(compiledSchema, parentPointer);\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\n            }\n            context.ids[schema.$id.replace(draft06_compile_suffixes, "")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, "#");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, "");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, "");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        // // @todo specify behaviour - we do not save ids with trailing slashes...\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$anchor) {\n            context.anchors[`${scope}#${schema.$anchor}`] = pointer;\n        }\n        if (schema.$ref && !schema[compile_COMPILED_REF]) {\n            Object.defineProperty(schema, compile_COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            Object.defineProperty(schema, compile_GET_ROOT, { enumerable: false, value: getRoot });\n        }\n    });\n    // console.log("ids", context.ids);\n    // console.log("anchors", context.anchors);\n    return compiledSchema;\n}\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js\n\n\n\nconst keyword_KeywordValidation = {\n    ...keyword,\n    // @draft >= 6\n    contains: (node, value) => {\n        var _a, _b;\n        const { draft, schema, pointer } = node;\n        if (schema.contains === false) {\n            return draft.errors.containsArrayError({ pointer, value, schema });\n        }\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return draft.errors.containsAnyError({ pointer, value, schema });\n            }\n            return undefined;\n        }\n        if (getTypeOf(schema.contains) !== "object") {\n            // ignore invalid schema\n            return undefined;\n        }\n        let count = 0;\n        for (let i = 0; i < value.length; i += 1) {\n            if (draft.validate(node.next(schema.contains, i), value[i]).length === 0) {\n                count++;\n            }\n        }\n        // @draft >= 2019-09\n        const max = (_a = schema.maxContains) !== null && _a !== void 0 ? _a : Infinity;\n        const min = (_b = schema.minContains) !== null && _b !== void 0 ? _b : 1;\n        if (max >= count && min <= count) {\n            return undefined;\n        }\n        if (max < count) {\n            return draft.errors.containsMaxError({ pointer, schema, delta: count - max, value });\n        }\n        if (min > count) {\n            return draft.errors.containsMinError({ pointer, schema, delta: min - count, value });\n        }\n        return draft.errors.containsError({ pointer, schema, value });\n    },\n    exclusiveMaximum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return draft.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return draft.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    // @feature if-then-else\n    if: validateIf,\n    maximum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== "object") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(draft.errors.patternPropertiesError({\n                            key,\n                            pointer,\n                            patterns: Object.keys(pp).join(","),\n                            schema,\n                            value\n                        }));\n                        return;\n                    }\n                    const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(","),\n                    schema,\n                    value\n                }));\n            }\n        });\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (node, value) => {\n        const { draft, schema, pointer } = node;\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value,\n                schema\n            });\n        }\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n        if (getTypeOf(schema.propertyNames) !== "object") {\n            // ignore invalid schema\n            return undefined;\n        }\n        const errors = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: "string" };\n        properties.forEach((prop) => {\n            const nextNode = node.next(propertySchema, prop);\n            const validationResult = draft.validate(nextNode, prop);\n            if (validationResult.length > 0) {\n                errors.push(draft.errors.invalidPropertyNameError({\n                    property: prop,\n                    pointer,\n                    validationError: validationResult[0],\n                    value: value[prop],\n                    schema\n                }));\n            }\n        });\n        return errors;\n    }\n};\n/* harmony default export */ const validation_keyword = (keyword_KeywordValidation);\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft06/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft06Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "contains",\n            "enum",\n            "if",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "uniqueItems"\n        ],\n        boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],\n        object: [\n            "additionalProperties",\n            "allOf",\n            "anyOf",\n            "dependencies",\n            "enum",\n            "format",\n            "if",\n            "maxProperties",\n            "minProperties",\n            "not",\n            "oneOf",\n            "patternProperties",\n            "properties",\n            "propertyNames",\n            "required"\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "if",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "enum",\n            "exclusiveMaximum",\n            "exclusiveMinimum",\n            "format",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf",\n            "allOf",\n            "anyOf",\n            "if"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    validateKeyword: validation_keyword,\n    validateType: type,\n    validateFormat: format,\n    errors: validation_errors,\n    createNode: createNode,\n    addRemoteSchema: addRemoteSchema_addRemoteSchema,\n    compileSchema: compile_compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef_strict_resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft06 extends Draft {\n    constructor(schema, config = {}) {\n        super(utils_merge(draft06Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft07/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft07Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "contains",\n            "enum",\n            "if",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "uniqueItems"\n        ],\n        boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],\n        object: [\n            "additionalProperties",\n            "allOf",\n            "anyOf",\n            "dependencies",\n            "enum",\n            "format",\n            "if",\n            "maxProperties",\n            "minProperties",\n            "not",\n            "oneOf",\n            "patternProperties",\n            "properties",\n            "propertyNames",\n            "required"\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "if",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "exclusiveMaximum",\n            "exclusiveMinimum",\n            "format",\n            "if",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    validateKeyword: validation_keyword,\n    validateType: type,\n    validateFormat: format,\n    errors: validation_errors,\n    createNode: createNode,\n    addRemoteSchema: addRemoteSchema_addRemoteSchema,\n    compileSchema: compile_compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef_strict_resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft07 extends Draft {\n    constructor(schema, config = {}) {\n        super(utils_merge(draft07Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft2019/validation/keyword.js\n\n\n\n\n/**\n * Get a list of tests to search for a matching pattern to a property\n */\nconst getPatternTests = (patternProperties) => isObject(patternProperties)\n    ? Object.keys(patternProperties).map((pattern) => new RegExp(pattern))\n    : [];\n/** tests if a property is evaluated by the given schema */\nfunction isPropertyEvaluated(schemaNode, propertyName, value) {\n    var _a, _b;\n    const node = schemaNode.draft.resolveRef(schemaNode);\n    const { schema } = node;\n    if (schema.additionalProperties === true) {\n        return true;\n    }\n    // PROPERTIES\n    if ((_a = schema.properties) === null || _a === void 0 ? void 0 : _a[propertyName]) {\n        const nextSchema = (_b = schema.properties) === null || _b === void 0 ? void 0 : _b[propertyName];\n        if (node.draft.isValid(value, nextSchema)) {\n            return true;\n        }\n    }\n    // PATTERN-PROPERTIES\n    const patterns = getPatternTests(schema.patternProperties);\n    if (patterns.find((pattern) => pattern.test(propertyName))) {\n        return true;\n    }\n    // ADDITIONAL-PROPERTIES\n    if (isObject(schema.additionalProperties)) {\n        const nextSchema = schema.additionalProperties;\n        return node.draft.validate(node.next(nextSchema), value);\n    }\n    return false;\n}\nconst validation_keyword_KeywordValidation = {\n    // ...omit(Keywords, "dependencies"),\n    ...validation_keyword,\n    dependencies: undefined,\n    dependentSchemas: validateDependentSchemas,\n    dependentRequired: validateDependentRequired,\n    /**\n     * @draft >= 2019-09\n     * Similar to additionalProperties, but can "see" into subschemas and across references\n     * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.2.4\n     */\n    unevaluatedProperties: (node, value) => {\n        var _a;\n        const { draft, schema, pointer } = node;\n        // if not in properties, evaluated by additionalProperties and not matches patternProperties\n        // @todo we need to know dynamic parent statements - they should not be counted as evaluated...\n        if (!isObject(value) || schema.unevaluatedProperties == null) {\n            return undefined;\n        }\n        let unevaluated = Object.keys(value);\n        if (unevaluated.length === 0) {\n            return undefined;\n        }\n        // resolve all dynamic schemas\n        const reduction = reduceSchema(node, value);\n        const resolvedSchema = ((_a = reduction.schema) !== null && _a !== void 0 ? _a : reduction);\n        // console.log("unevaluatedProperties", JSON.stringify(resolvedSchema, null, 2), value);\n        if (resolvedSchema.unevaluatedProperties === true) {\n            return undefined;\n        }\n        const testPatterns = getPatternTests(resolvedSchema.patternProperties);\n        unevaluated = unevaluated.filter((key) => {\n            var _a;\n            if ((_a = resolvedSchema.properties) === null || _a === void 0 ? void 0 : _a[key]) {\n                return false;\n            }\n            // special case: an evaluation in if statement counts too\n            // we have an unevaluated prop only if the if-schema does not match\n            if (isObject(schema.if) &&\n                isPropertyEvaluated(node.next({ type: "object", ...schema.if }), key, value[key])) {\n                return false;\n            }\n            if (testPatterns.find((pattern) => pattern.test(key))) {\n                return false;\n            }\n            // @todo is this evaluated by additionaProperties per property\n            if (resolvedSchema.additionalProperties) {\n                return false;\n            }\n            return true;\n        });\n        if (unevaluated.length === 0) {\n            return undefined;\n        }\n        const errors = [];\n        if (resolvedSchema.unevaluatedProperties === false) {\n            unevaluated.forEach((key) => {\n                errors.push(draft.errors.unevaluatedPropertyError({\n                    pointer: `${pointer}/${key}`,\n                    value: JSON.stringify(value[key]),\n                    schema\n                }));\n            });\n            return errors;\n        }\n        unevaluated.forEach((key) => {\n            if (isObject(resolvedSchema.unevaluatedProperties)) {\n                // note: only key changes\n                const keyErrors = draft.validate(node.next(resolvedSchema.unevaluatedProperties, key), value[key]);\n                errors.push(...keyErrors);\n            }\n        });\n        return errors;\n    },\n    /**\n     * @draft >= 2019-09\n     * Similar to additionalItems, but can "see" into subschemas and across references\n     * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.1.3\n     */\n    unevaluatedItems: (node, value) => {\n        var _a;\n        const { draft, schema, pointer } = node;\n        // if not in items, and not matches additionalItems\n        if (!Array.isArray(value) ||\n            value.length === 0 ||\n            schema.unevaluatedItems == null ||\n            schema.unevaluatedItems === true) {\n            return undefined;\n        }\n        // resolve all dynamic schemas\n        const reduction = reduceSchema(draft.resolveRef(node), value);\n        const resolvedSchema = ((_a = reduction.schema) !== null && _a !== void 0 ? _a : reduction);\n        // console.log("unevaluatedItems", JSON.stringify(resolvedSchema, null, 2), value);\n        if (resolvedSchema.unevaluatedItems === true || resolvedSchema.additionalItems === true) {\n            return undefined;\n        }\n        if (isObject(schema.if)) {\n            const nextSchemaNode = { type: "array", ...schema.if };\n            if (draft.isValid(value, nextSchemaNode)) {\n                if (Array.isArray(nextSchemaNode.items) &&\n                    nextSchemaNode.items.length === value.length) {\n                    return undefined;\n                }\n            }\n            // need to test remaining items?\n        }\n        if (isObject(resolvedSchema.items)) {\n            const nextSchemaNode = { ...resolvedSchema, unevaluatedItems: undefined };\n            const errors = draft.validate(node.next(nextSchemaNode), value);\n            return errors.map((e) => draft.errors.unevaluatedItemsError({ ...e.data }));\n        }\n        if (Array.isArray(resolvedSchema.items)) {\n            const items = [];\n            for (let i = resolvedSchema.items.length; i < value.length; i += 1) {\n                if (i < resolvedSchema.items.length) {\n                    if (draft.validate(node.next(resolvedSchema.items[i], i), value[i]).length > 0) {\n                        items.push({ index: i, value: value[i] });\n                    }\n                }\n                else {\n                    items.push({ index: i, value: value[i] });\n                }\n            }\n            return items.map((item) => draft.errors.unevaluatedItemsError({\n                pointer: `${pointer}/${item.index}`,\n                value: JSON.stringify(item.value),\n                schema: resolvedSchema.unevaluatedItems\n            }));\n        }\n        if (isObject(resolvedSchema.unevaluatedItems)) {\n            return value.map((item, index) => {\n                if (!draft.isValid(item, resolvedSchema.unevaluatedItems)) {\n                    return draft.errors.unevaluatedItemsError({\n                        pointer: `${pointer}/${index}`,\n                        value: JSON.stringify(item),\n                        schema: resolvedSchema.unevaluatedItems\n                    });\n                }\n            });\n        }\n        const errors = [];\n        value.forEach((item, index) => {\n            errors.push(draft.errors.unevaluatedItemsError({\n                pointer: `${pointer}/${index}`,\n                value: JSON.stringify(item),\n                schema\n            }));\n        });\n        return errors;\n    }\n};\n/* harmony default export */ const draft2019_validation_keyword = (validation_keyword_KeywordValidation);\n\n;// ./node_modules/json-schema-library/dist/module/lib/draft2019/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst draft2019Config = {\n    typeKeywords: {\n        array: [\n            "allOf",\n            "anyOf",\n            "contains",\n            "enum",\n            "if",\n            "items",\n            "maxItems",\n            "minItems",\n            "not",\n            "oneOf",\n            "unevaluatedItems",\n            "uniqueItems"\n        ],\n        boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],\n        object: [\n            "additionalProperties",\n            "allOf",\n            "anyOf",\n            // "dependencies",\n            "dependentSchemas",\n            "dependentRequired",\n            "enum",\n            "format",\n            "if",\n            "maxProperties",\n            "minProperties",\n            "not",\n            "oneOf",\n            "patternProperties",\n            "properties",\n            "propertyNames",\n            "required",\n            "unevaluatedProperties" // 2019-09\n        ],\n        string: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "format",\n            "if",\n            "maxLength",\n            "minLength",\n            "not",\n            "oneOf",\n            "pattern"\n        ],\n        number: [\n            "allOf",\n            "anyOf",\n            "enum",\n            "exclusiveMaximum",\n            "exclusiveMinimum",\n            "format",\n            "if",\n            "maximum",\n            "minimum",\n            "multipleOf",\n            "not",\n            "oneOf"\n        ],\n        null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]\n    },\n    validateKeyword: draft2019_validation_keyword,\n    validateType: type,\n    validateFormat: format,\n    errors: validation_errors,\n    createNode: createNode,\n    addRemoteSchema: addRemoteSchema_addRemoteSchema,\n    compileSchema: compile_compileSchema,\n    createSchemaOf: createSchemaOf,\n    each: each,\n    eachSchema: eachSchema,\n    getChildSchemaSelection: getChildSchemaSelection,\n    getSchema: getSchema,\n    getTemplate: lib_getTemplate,\n    isValid: isValid,\n    resolveAllOf: resolveAllOf,\n    resolveAnyOf: resolveAnyOf,\n    resolveOneOf: resolveOneOf,\n    resolveRef: resolveRef_resolveRef,\n    step: step,\n    validate: validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft2019 extends Draft {\n    constructor(schema, config = {}) {\n        super(utils_merge(draft2019Config, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js\n\n\n\n\n\nconst draftJsonEditorConfig = {\n    ...draft07Config,\n    resolveOneOf: resolveOneOfFuzzy,\n    resolveRef: resolveRef_resolveRef\n};\nclass JsonEditor extends Draft {\n    constructor(schema, config = {}) {\n        super(utils_merge(draftJsonEditorConfig, config), schema);\n    }\n}\n\n\n;// ./node_modules/json-schema-library/dist/module/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst config = { strings: strings };\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGtCQUFrQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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SztBQUN2QixvQkFBb0IsTUFBTztBQUMzQixZQUFZLGlCQUFNO0FBQ2xCLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixRQUFRO0FBQ1IsY0FBYztBQUNkLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2IsZUFBZTtBQUNmLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsUUFBUTtBQUNSLFlBQVk7QUFDWiw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLHdCQUF3QixLQUFLO0FBQzdCLG1DQUFtQztBQUNuQyxjQUFjLFdBQUs7QUFDbkI7QUFDQTtBQUNzQzs7O0FDbkhIO0FBQ21CO0FBQ2Y7QUFDTjtBQUNVO0FBQzNDO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCLGtCQUFrQixpQkFBaUI7QUFDbkMsY0FBYztBQUNkO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUIsbUNBQW1DO0FBQ25DLGNBQWMsV0FBSztBQUNuQjtBQUNBO0FBQzZDOzs7QUNma0M7QUFDdkM7QUFDK0I7QUFDbkI7QUFDRztBQUNiO0FBQ0c7QUFDRjtBQUNLO0FBQ0U7QUFDaUM7QUFDbkM7QUFDUjtBQUNKO0FBQ21CO0FBQ0E7QUFDQTtBQUNNO0FBQ1E7QUFDM0I7QUFDa0I7QUFDNUQsaUJBQWlCLE9BQU87QUFtQnJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2NvbmZpZy9zdHJpbmdzLmpzPzY0M2MiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2dldFR5cGVPZi5qcz9kNGU3Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9yZW5kZXIuanM/NjIzOSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvX18uanM/MDg1ZSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvY3JlYXRlQ3VzdG9tRXJyb3IuanM/ODRhOCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvZmxhdHRlbkFycmF5LmpzPzkzY2IiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2NvbmZpZy9zZXR0aW5ncy5qcz9lODg1Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi90eXBlcy5qcz9jNGQ0Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9maWx0ZXIuanM/MzQ1MCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvaXNPYmplY3QuanM/YTc0MiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZmVhdHVyZXMvb25lT2YuanM/MzUyMyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvbWVyZ2VTY2hlbWEuanM/NmNlNiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvb21pdC5qcz8yNTQxIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9mZWF0dXJlcy9pZi5qcz8wZTc4Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9zaGFsbG93Q2xvbmVTY2hlbWEuanM/YTlhMyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZmVhdHVyZXMvYWxsT2YuanM/ODkwNSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvc2NoZW1hTm9kZS5qcz82MjRmIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9yZXNvbHZlUmVmLnN0cmljdC5qcz84NTVmIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9yZXNvbHZlUmVmLmpzP2NkM2IiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3ZhbGlkYXRlQXN5bmMuanM/MjVmNSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdXRpbHMvdW5pcXVlSXRlbXMuanM/NDAwYiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZmVhdHVyZXMvZGVwZW5kZW5jaWVzLmpzP2RhNTAiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2ZlYXR1cmVzL2FueU9mLmpzPzczZDAiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3Jlc29sdmVEeW5hbWljU2NoZW1hLmpzPzQ1MWUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3JlZHVjZVNjaGVtYS5qcz9lYzkzIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9mYXN0LWNvcHkvZGlzdC9lc20vaW5kZXgubWpzPzUzODUiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2NvcHkuanM/OGZlZSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQvaW5kZXguanM/ZGUzZiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNC9hZGRSZW1vdGVTY2hlbWEuanM/Y2ZlZSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZWFjaFNjaGVtYS5qcz9kNTAyIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9jb21waWxlL2pvaW5TY29wZS5qcz8yMDBlIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9jb21waWxlL3NwbGl0UmVmLmpzPzY0OWEiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2NvbXBpbGUvZ2V0UmVmLmpzPzcxYzIiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2NvbXBpbGUvaW5kZXguanM/ZjkxOCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvY3JlYXRlU2NoZW1hT2YuanM/MzIyMSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdmFsaWRhdGlvbi9lcnJvcnMuanM/Y2Q4NyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdmFsaWRhdGlvbi9mb3JtYXQuanM/ZmExOCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24uanM/YjVmYSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZ2V0U2NoZW1hLmpzP2MyMTciLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL21lcmdlLmpzPzViMzYiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2lzRW1wdHkuanM/NjJmOSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZ2V0VGVtcGxhdGUuanM/MmY0MSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvaXNWYWxpZC5qcz9iNDY1Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi91dGlscy9wdW55Y29kZS51Y3MyZGVjb2RlLmpzPzZjOGYiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL3V0aWxzL2dldFByZWNpc2lvbi5qcz85ZjRmIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi92YWxpZGF0aW9uL2tleXdvcmQuanM/NWQyMCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvc3RlcC5qcz85NWU1Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi92YWxpZGF0aW9uL3R5cGUuanM/MDBjZSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvdmFsaWRhdGUuanM/Nzc0OSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZWFjaC5qcz8zZDQyIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9kcmFmdDA0L2luZGV4LmpzPzc3YTYiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2FkZFJlbW90ZVNjaGVtYS5qcz83ZjE3Iiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9kcmFmdDA2L2NvbXBpbGUvaW5kZXguanM/ZDcwYSIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNi92YWxpZGF0aW9uL2tleXdvcmQuanM/Nzk0NCIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQwNi9pbmRleC5qcz8xMzYwIiwid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1saWJyYXJ5L2Rpc3QvbW9kdWxlL2xpYi9kcmFmdDA3L2luZGV4LmpzPzAyMDkiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2RyYWZ0MjAxOS92YWxpZGF0aW9uL2tleXdvcmQuanM/ODNiMiIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9saWIvZHJhZnQyMDE5L2luZGV4LmpzPzc0OGQiLCJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWxpYnJhcnkvZGlzdC9tb2R1bGUvbGliL2pzb25lZGl0b3IvaW5kZXguanM/M2EzYyIsIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbGlicmFyeS9kaXN0L21vZHVsZS9pbmRleC5qcz83MmRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBtYXgtbGVuOiAwICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLy8gdmFsaWRhdGlvbiBlcnJvcnNcbiAgICBBZGRpdGlvbmFsSXRlbXNFcnJvcjogXCJBcnJheSBhdCBge3twb2ludGVyfX1gIG1heSBub3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGl0ZW0gYHt7a2V5fX1gXCIsXG4gICAgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcjogXCJBZGRpdGlvbmFsIHByb3BlcnR5IGB7e3Byb3BlcnR5fX1gIG9uIGB7e3BvaW50ZXJ9fWAgZG9lcyBub3QgbWF0Y2ggc2NoZW1hIGB7e3NjaGVtYX19YFwiLFxuICAgIEFsbE9mRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBkb2VzIG5vdCBtYXRjaCBzY2hlbWEgb2YgYHt7YWxsT2Z9fWBcIixcbiAgICBBbnlPZkVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYSBvZiBge3thbnlPZn19YFwiLFxuICAgIENvbnN0RXJyb3I6IFwiRXhwZWN0ZWQgdmFsdWUgYXQgYHt7cG9pbnRlcn19YCB0byBiZSBge3tleHBlY3RlZH19YCwgYnV0IHZhbHVlIGdpdmVuIGlzIGB7e3ZhbHVlfX1gXCIsXG4gICAgY29udGFpbnNBbnlFcnJvcjogXCJUaGUgYXJyYXkgYXQgYHt7cG9pbnRlcn19YCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGl0ZW1cIixcbiAgICBDb250YWluc0FycmF5RXJyb3I6IFwiVGhlIHByb3BlcnR5IGF0IGB7e3BvaW50ZXJ9fWAgbXVzdCBub3QgYmUgYW4gYXJyYXlcIixcbiAgICBDb250YWluc0Vycm9yOiBcIlRoZSBhcnJheSBhdCBge3twb2ludGVyfX1gIG11c3QgY29udGFpbiBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyBge3tzY2hlbWF9fWBcIixcbiAgICBDb250YWluc01pbkVycm9yOiBcIlRoZSBhcnJheSBhdCBge3twb2ludGVyfX1gIGNvbnRhaW5zIHt7ZGVsdGF9fSB0b28gZmV3IGl0ZW1zIG1hdGNoaW5nIGB7e3NjaGVtYX19YFwiLFxuICAgIENvbnRhaW5zTWF4RXJyb3I6IFwiVGhlIGFycmF5IGF0IGB7e3BvaW50ZXJ9fWAgY29udGFpbnMge3tkZWx0YX19IHRvbyBtYW55IGl0ZW1zIG1hdGNoaW5nIGB7e3NjaGVtYX19YFwiLFxuICAgIEVudW1FcnJvcjogXCJFeHBlY3RlZCBnaXZlbiB2YWx1ZSBge3t2YWx1ZX19YCBpbiBge3twb2ludGVyfX1gIHRvIGJlIG9uZSBvZiBge3t2YWx1ZXN9fWBcIixcbiAgICBGb3JiaWRkZW5Qcm9wZXJ0eUVycm9yOiBcIlByb3BlcnR5IG5hbWUgYHt7cHJvcGVydHl9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYWxsb3dlZFwiLFxuICAgIEZvcm1hdERhdGVFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIGRhdGVcIixcbiAgICBGb3JtYXREYXRlVGltZUVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgZGF0ZS10aW1lXCIsXG4gICAgRm9ybWF0RHVyYXRpb25FcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIGR1cmF0aW9uXCIsXG4gICAgRm9ybWF0RW1haWxFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIGVtYWlsXCIsXG4gICAgRm9ybWF0SG9zdG5hbWVFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIGhvc3RuYW1lXCIsXG4gICAgRm9ybWF0SVBWNEVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgSVB2NCBhZGRyZXNzXCIsXG4gICAgRm9ybWF0SVBWNExlYWRpbmdaZXJvRXJyb3I6IFwiSVB2NCBhZGRyZXNzZXMgc3RhcnRpbmcgd2l0aCB6ZXJvIGFyZSBpbnZhbGlkLCBzaW5jZSB0aGV5IGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbHNcIixcbiAgICBGb3JtYXRJUFY2RXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCBJUHY2IGFkZHJlc3NcIixcbiAgICBGb3JtYXRJUFY2TGVhZGluZ1plcm9FcnJvcjogXCJJUHY2IGFkZHJlc3NlcyBzdGFydGluZyB3aXRoIHplcm8gYXJlIGludmFsaWQsIHNpbmNlIHRoZXkgYXJlIGludGVycHJldGVkIGFzIG9jdGFsc1wiLFxuICAgIEZvcm1hdEpzb25Qb2ludGVyRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCBqc29uLXBvaW50ZXJcIixcbiAgICBGb3JtYXRSZWdFeEVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uXCIsXG4gICAgRm9ybWF0VGltZUVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgdGltZVwiLFxuICAgIEZvcm1hdFVSSUVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgdXJpXCIsXG4gICAgRm9ybWF0VVJJUmVmZXJlbmNlRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgYHt7cG9pbnRlcn19YCBpcyBub3QgYSB2YWxpZCB1cmktcmVmZXJlbmNlXCIsXG4gICAgRm9ybWF0VVJJVGVtcGxhdGVFcnJvcjogXCJWYWx1ZSBge3t2YWx1ZX19YCBhdCBge3twb2ludGVyfX1gIGlzIG5vdCBhIHZhbGlkIHVyaS10ZW1wbGF0ZVwiLFxuICAgIEZvcm1hdFVSTEVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgdXJsXCIsXG4gICAgRm9ybWF0VVVJREVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGF0IGB7e3BvaW50ZXJ9fWAgaXMgbm90IGEgdmFsaWQgdXVpZFwiLFxuICAgIEludmFsaWREYXRhRXJyb3I6IFwiTm8gdmFsdWUgbWF5IGJlIHNwZWNpZmllZCBpbiBge3twb2ludGVyfX1gXCIsXG4gICAgSW52YWxpZFByb3BlcnR5TmFtZUVycm9yOiBcIkludmFsaWQgcHJvcGVydHkgbmFtZSBge3twcm9wZXJ0eX19YCBhdCBge3twb2ludGVyfX1gXCIsXG4gICAgTWF4aW11bUVycm9yOiBcIlZhbHVlIGluIGB7e3BvaW50ZXJ9fWAgaXMgYHt7bGVuZ3RofX1gLCBidXQgc2hvdWxkIGJlIGB7e21heGltdW19fWAgYXQgbWF4aW11bVwiLFxuICAgIE1heEl0ZW1zRXJyb3I6IFwiVG9vIG1hbnkgaXRlbXMgaW4gYHt7cG9pbnRlcn19YCwgc2hvdWxkIGJlIGB7e21heGltdW19fWAgYXQgbW9zdCwgYnV0IGdvdCBge3tsZW5ndGh9fWBcIixcbiAgICBNYXhMZW5ndGhFcnJvcjogXCJWYWx1ZSBge3twb2ludGVyfX1gIHNob3VsZCBoYXZlIGEgbWF4aW11bSBsZW5ndGggb2YgYHt7bWF4TGVuZ3RofX1gLCBidXQgZ290IGB7e2xlbmd0aH19YC5cIixcbiAgICBNYXhQcm9wZXJ0aWVzRXJyb3I6IFwiVG9vIG1hbnkgcHJvcGVydGllcyBpbiBge3twb2ludGVyfX1gLCBzaG91bGQgYmUgYHt7bWF4UHJvcGVydGllc319YCBhdCBtb3N0LCBidXQgZ290IGB7e2xlbmd0aH19YFwiLFxuICAgIE1pbmltdW1FcnJvcjogXCJWYWx1ZSBpbiBge3twb2ludGVyfX1gIGlzIGB7e2xlbmd0aH19YCwgYnV0IHNob3VsZCBiZSBge3ttaW5pbXVtfX1gIGF0IG1pbmltdW1cIixcbiAgICBNaW5JdGVtc0Vycm9yOiBcIlRvbyBmZXcgaXRlbXMgaW4gYHt7cG9pbnRlcn19YCwgc2hvdWxkIGJlIGF0IGxlYXN0IGB7e21pbkl0ZW1zfX1gLCBidXQgZ290IGB7e2xlbmd0aH19YFwiLFxuICAgIE1pbkl0ZW1zT25lRXJyb3I6IFwiQXQgbGVhc3Qgb25lIGl0ZW0gaXMgcmVxdWlyZWQgaW4gYHt7cG9pbnRlcn19YFwiLFxuICAgIE1pbkxlbmd0aEVycm9yOiBcIlZhbHVlIGB7e3BvaW50ZXJ9fWAgc2hvdWxkIGhhdmUgYSBtaW5pbXVtIGxlbmd0aCBvZiBge3ttaW5MZW5ndGh9fWAsIGJ1dCBnb3QgYHt7bGVuZ3RofX1gLlwiLFxuICAgIE1pbkxlbmd0aE9uZUVycm9yOiBcIkEgdmFsdWUgaXMgcmVxdWlyZWQgaW4gYHt7cG9pbnRlcn19YFwiLFxuICAgIE1pblByb3BlcnRpZXNFcnJvcjogXCJUb28gZmV3IHByb3BlcnRpZXMgaW4gYHt7cG9pbnRlcn19YCwgc2hvdWxkIGJlIGF0IGxlYXN0IGB7e21pblByb3BlcnRpZXN9fWAsIGJ1dCBnb3QgYHt7bGVuZ3RofX1gXCIsXG4gICAgTWlzc2luZ0RlcGVuZGVuY3lFcnJvcjogXCJUaGUgcmVxdWlyZWQgcHJvcGVyeSAne3ttaXNzaW5nUHJvcGVydHl9fScgaW4gYHt7cG9pbnRlcn19YCBpcyBtaXNzaW5nXCIsXG4gICAgTWlzc2luZ09uZU9mUHJvcGVydHlFcnJvcjogXCJWYWx1ZSBhdCBge3twb2ludGVyfX1gIHByb3BlcnR5OiBge3twcm9wZXJ0eX19YFwiLFxuICAgIE11bHRpcGxlT2ZFcnJvcjogXCJFeHBlY3RlZCBge3t2YWx1ZX19YCBpbiBge3twb2ludGVyfX1gIHRvIGJlIG11bHRpcGxlIG9mIGB7e211bHRpcGxlT2Z9fWBcIixcbiAgICBNdWx0aXBsZU9uZU9mRXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgc2hvdWxkIG5vdCBtYXRjaCBtdWx0aXBsZSBzY2hlbWFzIGluIG9uZU9mIGB7e21hdGNoZXN9fWBcIixcbiAgICBOb0FkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3I6IFwiQWRkaXRpb25hbCBwcm9wZXJ0eSBge3twcm9wZXJ0eX19YCBpbiBge3twb2ludGVyfX1gIGlzIG5vdCBhbGxvd2VkXCIsXG4gICAgTm90RXJyb3I6IFwiVmFsdWUgYHt7dmFsdWV9fWAgYXQgcG9pbnRlciBzaG91bGQgbm90IG1hdGNoIHNjaGVtYSBge3tub3R9fWBcIixcbiAgICBPbmVPZkVycm9yOiBcIlZhbHVlIGB7e3ZhbHVlfX1gIGluIGB7e3BvaW50ZXJ9fWAgZG9lcyBub3QgbWF0Y2ggYW55IGdpdmVuIG9uZW9mIHNjaGVtYVwiLFxuICAgIE9uZU9mUHJvcGVydHlFcnJvcjogXCJGYWlsZWQgZmluZGluZyBhIG1hdGNoaW5nIG9uZU9mUHJvcGVydHkgc2NoZW1hIGluIGB7e3BvaW50ZXJ9fWAgd2hlcmUgYHt7cHJvcGVydHl9fWAgbWF0Y2hlcyBge3t2YWx1ZX19YFwiLFxuICAgIFBhdHRlcm5FcnJvcjogXCJWYWx1ZSBpbiBge3twb2ludGVyfX1gIHNob3VsZCBtYXRjaCBge3tkZXNjcmlwdGlvbn19YCwgYnV0IHJlY2VpdmVkIGB7e3JlY2VpdmVkfX1gXCIsXG4gICAgUGF0dGVyblByb3BlcnRpZXNFcnJvcjogXCJQcm9wZXJ0eSBge3trZXl9fWAgZG9lcyBub3QgbWF0Y2ggYW55IHBhdHRlcm5zIGluIGB7e3BvaW50ZXJ9fWAuIFZhbGlkIHBhdHRlcm5zIGFyZToge3twYXR0ZXJuc319XCIsXG4gICAgUmVxdWlyZWRQcm9wZXJ0eUVycm9yOiBcIlRoZSByZXF1aXJlZCBwcm9wZXJ0eSBge3trZXl9fWAgaXMgbWlzc2luZyBhdCBge3twb2ludGVyfX1gXCIsXG4gICAgU2NoZW1hV2FybmluZzogXCJGYWlsZWQgcmV0cmlldmluZyBhIHNjaGVtYSBmcm9tICd7e3BvaW50ZXJ9fScgdG8ga2V5ICd7e2tleX19J1wiLFxuICAgIFR5cGVFcnJvcjogXCJFeHBlY3RlZCBge3t2YWx1ZX19YCAoe3tyZWNlaXZlZH19KSBpbiBge3twb2ludGVyfX1gIHRvIGJlIG9mIHR5cGUgYHt7ZXhwZWN0ZWR9fWBcIixcbiAgICBVbmRlZmluZWRWYWx1ZUVycm9yOiBcIlZhbHVlIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBpbiBge3twb2ludGVyfX1gXCIsXG4gICAgVW5ldmFsdWF0ZWRQcm9wZXJ0eUVycm9yOiBcIkludmFsaWQgdW5ldmFsdWF0ZWQgcHJvcGVydHkgYHt7cG9pbnRlcn19YFwiLFxuICAgIFVuZXZhbHVhdGVkSXRlbXNFcnJvcjogXCJJbnZhbGlkIHVuZXZhbHVhdGVkIGl0ZW0gYHt7cG9pbnRlcn19YFwiLFxuICAgIFVuaXF1ZUl0ZW1zRXJyb3I6IFwiSXRlbXMgaW4gYXJyYXkgbXVzdCBiZSB1bmlxdWUuIFZhbHVlIGB7e3ZhbHVlfX1gIGluIGB7e3BvaW50ZXJ9fWAgaXMgYSBkdXBsaWNhdGUgb2Yge3tkdXBsaWNhdGVQb2ludGVyfX0uXCIsXG4gICAgVW5rbm93blByb3BlcnR5RXJyb3I6IFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCBzY2hlbWEgZm9yIHByb3BlcnR5IGB7e3BvaW50ZXJ9fWAgd2l0aGluIG9iamVjdFwiLFxuICAgIFZhbHVlTm90RW1wdHlFcnJvcjogXCJBIHZhbHVlIGZvciBge3twcm9wZXJ0eX19YCBpcyByZXF1aXJlZCBhdCBge3twb2ludGVyfX1gXCJcbn07XG4iLCJjb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUeXBlT2YodmFsdWUpIHtcbiAgICBjb25zdCB0eXBlID0gdG9TdHJpbmdcbiAgICAgICAgLmNhbGwodmFsdWUpXG4gICAgICAgIC5tYXRjaCgvXFxzKFteXFxdXSspXFxdLylcbiAgICAgICAgLnBvcCgpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi9nZXRUeXBlT2ZcIjtcbmNvbnN0IE9CSkVDVF9UWVBFID0gXCJvYmplY3RcIjtcbmNvbnN0IEFSUkFZX1RZUEUgPSBcImFycmF5XCI7XG4vKipcbiAqIFJlbmRlcnMgZGF0YSBpbnRvIGEgc3RyaW5nIGJ5IHt7dmFyaWFibGVzfX0uXG4gKiBHaXZlbiBhIHRlbXBsYXRlIHN0cmluZywgcmVtb3ZlcyBhbGwge3twcm9wZXJ0eX19IHN1YnN0cmluZ3MgYW5kIHJlcGxhY2VzIHRoZW0gd2l0aCB0aGUgcHJvcGVydHkgaW4gdGhlIGdpdmVuIGRhdGFcbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGUgLSB0ZW1wbGF0ZSBzdHJpbmcgY29udGFpbmluZyB2YXJpYWJsZXMgaW4gaGFuZGVsYmFycy9tdXN0YWNoZSBzdHlsZVxuICogQHBhcmFtIGRhdGEgLSBmbGF0IG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgbWF0Y2hpbmcgdmFyaWFibGVzXG4gKiBAcmV0dXJuIHJlbmRlcmVkIHN0cmluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW5kZXIodGVtcGxhdGUsIGRhdGEgPSB7fSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHtcXHtcXHcrXFx9XFx9L2csIChtYXRjaCkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBtYXRjaC5yZXBsYWNlKC9be31dL2csIFwiXCIpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IGRhdGFba2V5XTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVUeXBlID0gZ2V0VHlwZU9mKHZhcmlhYmxlKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlVHlwZSA9PT0gT0JKRUNUX1RZUEUgfHwgdmFyaWFibGVUeXBlID09PSBBUlJBWV9UWVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCBzdHJpbmdzIGZyb20gXCIuLi9jb25maWcvc3RyaW5nc1wiO1xuaW1wb3J0IHJlbmRlciBmcm9tIFwiLi9yZW5kZXJcIjtcbi8qKlxuICogUmVuZGVycyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIGRlZmluZWQgaW4gX19Ac2VlIGNvbmZpZy9zdHJpbmdzLmpzX19cbiAqIEBwYXJhbSBrZXl3b3JkXG4gKiBAcGFyYW0gZGF0YSAtIHRlbXBsYXRlIGRhdGFcbiAqIEBwYXJhbSBmYWxsYmFjayAtIGZhbGxiYWNrIHRlbXBsYXRlXG4gKiBAcmV0dXJuIHJlc3VsdGluZyBzdHJpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX18oa2V5d29yZCwgZGF0YSwgZmFsbGJhY2sgPSBrZXl3b3JkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gKF9hID0gc3RyaW5nc1trZXl3b3JkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsbGJhY2s7XG4gICAgcmV0dXJuIHJlbmRlcih0ZW1wbGF0ZSwgZGF0YSk7XG59XG4iLCJpbXBvcnQgX18gZnJvbSBcIi4vX19cIjtcbmZ1bmN0aW9uIGRhc2hDYXNlKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXJyb3IobmFtZSwgZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY29kZTogZGFzaENhc2UobmFtZSksXG4gICAgICAgIG1lc3NhZ2U6IF9fKG5hbWUsIGRhdGEpLFxuICAgICAgICBkYXRhXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBFcnJvciBDcmVhdG9yLiBJdHMgbWVzc2FnZXMgYXJlIGRlZmluZWQgYnkgc3RyaW5ncy1vYmplY3QgQHNlZSBjb25maWcvc3RyaW5ncy50c1xuICpcbiAqIEBwYXJhbSBuYW1lIC0gaWQgb2YgZXJyb3IgKGNhbWVsY2FzZWQpXG4gKiBAcmV0dXJuIGVycm9yIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXN0b21FcnJvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yLmJpbmQobnVsbCwgbmFtZSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmbGF0dGVuQXJyYXkobGlzdCwgcmVzdWx0ID0gW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBmbGF0dGVuQXJyYXkoaXRlbSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgREVDTEFSQVRPUl9PTkVPRjogXCJvbmVPZlByb3BlcnR5XCIsXG4gICAgLyoqIHNldCB0byBmYWxzZSB0byBub3Qgc2V0IF9fb25lT2ZJbmRleCBvbiByZXR1cm5lZCBzY2hlbWEgKi9cbiAgICBFWFBPU0VfT05FX09GX0lOREVYOiB0cnVlLFxuICAgIEdFVF9URU1QTEFURV9SRUNVUlNJT05fTElNSVQ6IDEsXG4gICAgcHJvcGVydHlCbGFja2xpc3Q6IFtcIl9pZFwiXSxcbiAgICB0ZW1wbGF0ZURlZmF1bHRPcHRpb25zOiB7XG4gICAgICAgIGFkZE9wdGlvbmFsUHJvcHM6IGZhbHNlLFxuICAgICAgICByZW1vdmVJbnZhbGlkRGF0YTogZmFsc2UsXG4gICAgICAgIGV4dGVuZERlZmF1bHRzOiB0cnVlXG4gICAgfVxufTtcbiIsIi8qKlxuICogdHMgdHlwZSBndWFyZCBmb3IganNvbiBlcnJvclxuICogQHJldHVybnMgdHJ1ZSBpZiBwYXNzZWQgdHlwZSBpcyBhIEpzb25FcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci50eXBlKSA9PT0gXCJlcnJvclwiO1xufVxuIiwiaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZXJyb3JPclByb21pc2UoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNKc29uRXJyb3IoZXJyb3IpIHx8IGlzUHJvbWlzZShlcnJvcik7XG59XG5leHBvcnQgZnVuY3Rpb24gZXJyb3JzT25seShlcnJvcikge1xuICAgIHJldHVybiBpc0pzb25FcnJvcihlcnJvcik7XG59XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi9nZXRUeXBlT2ZcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2KSB7XG4gICAgcmV0dXJuIGdldFR5cGVPZih2KSA9PT0gXCJvYmplY3RcIjtcbn1cbiIsIi8qKlxuICogQGRyYWZ0LTA0XG4gKi9cbmltcG9ydCBmbGF0dGVuQXJyYXkgZnJvbSBcIi4uL3V0aWxzL2ZsYXR0ZW5BcnJheVwiO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gXCIuLi9jb25maWcvc2V0dGluZ3NcIjtcbmltcG9ydCB7IGVycm9yT3JQcm9taXNlIH0gZnJvbSBcIi4uL3V0aWxzL2ZpbHRlclwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4uL3V0aWxzL2lzT2JqZWN0XCI7XG5jb25zdCB7IERFQ0xBUkFUT1JfT05FT0YsIEVYUE9TRV9PTkVfT0ZfSU5ERVggfSA9IHNldHRpbmdzO1xuZnVuY3Rpb24gc2V0T25lT2ZPcmlnaW4oc2NoZW1hLCBpbmRleCkge1xuICAgIGlmIChFWFBPU0VfT05FX09GX0lOREVYICYmIGlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICAgICAgc2NoZW1hLl9fb25lT2ZJbmRleCA9IGluZGV4O1xuICAgIH1cbn1cbi8qKlxuICogU2VsZWN0cyBhbmQgcmV0dXJucyBhIG9uZU9mIHNjaGVtYSBmb3IgdGhlIGdpdmVuIGRhdGFcbiAqXG4gKiBAcGFyYW0gZHJhZnQgLSB2YWxpZGF0b3JcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gc2NoZW1hIC0gY3VycmVudCBqc29uIHNjaGVtYSBjb250YWluaW5nIHByb3BlcnR5IG9uZU9mXG4gKiBAcGFyYW0gcG9pbnRlciAtIGpzb24gcG9pbnRlciB0byBkYXRhXG4gKiBAcmV0dXJuIG9uZU9mIHNjaGVtYSBvciBhbiBlcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9uZU9mKG5vZGUsIGRhdGEpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZHJhZnQsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgLy8gIWtleXdvcmQ6IG9uZU9mUHJvcGVydHlcbiAgICAvLyBhbiBhZGRpdGlvbmFsIDxERUNMQVJBVE9SX09ORU9GPiAoZGVmYXVsdCBgb25lT2ZQcm9wZXJ0eWApIG9uIHRoZSBzY2hlbWEgd2lsbCBleGFjdGx5IGRldGVybWluZSB0aGVcbiAgICAvLyBvbmVPZiB2YWx1ZSAoaWYgc2V0IGluIGRhdGEpXG4gICAgLy8gQGZpeG1lXG4gICAgLy8gYWJvcnQgaWYgbm8gZGF0YSBpcyBnaXZlbiBhbiBERUNMQVJBVE9SX09ORU9GIGlzIHNldCAodXNlZCBieSBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbilcbiAgICAvLyB0aGlzIGNhc2UgKGRhdGEgIT0gbnVsbCkgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnlcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmIHNjaGVtYVtERUNMQVJBVE9SX09ORU9GXSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgb25lT2ZQcm9wZXJ0eSA9IHNjaGVtYVtERUNMQVJBVE9SX09ORU9GXTtcbiAgICAgICAgY29uc3Qgb25lT2ZWYWx1ZSA9IGRhdGFbc2NoZW1hW0RFQ0xBUkFUT1JfT05FT0ZdXTtcbiAgICAgICAgaWYgKG9uZU9mVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taXNzaW5nT25lT2ZQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogb25lT2ZQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZU5vZGUgPSBub2RlLm5leHQoc2NoZW1hLm9uZU9mW2ldKS5yZXNvbHZlUmVmKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHROb2RlID0gZHJhZnQuc3RlcChvbmVOb2RlLCBvbmVPZlByb3BlcnR5LCBkYXRhKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25FcnJvcihyZXN1bHROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZsYXR0ZW5BcnJheShkcmFmdC52YWxpZGF0ZShyZXN1bHROb2RlLCBvbmVPZlZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGVycm9yT3JQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAZXZhbHVhdGlvbi1pbmZvXG4gICAgICAgICAgICAgICAgc2V0T25lT2ZPcmlnaW4ob25lTm9kZS5zY2hlbWEsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHROb2RlLm5leHQob25lTm9kZS5zY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMub25lT2ZQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBvbmVPZlByb3BlcnR5LFxuICAgICAgICAgICAgdmFsdWU6IG9uZU9mVmFsdWUsXG4gICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb25lTm9kZSA9IGRyYWZ0LnJlc29sdmVSZWYobm9kZS5uZXh0KHNjaGVtYS5vbmVPZltpXSkpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmxhdHRlbkFycmF5KGRyYWZ0LnZhbGlkYXRlKG9uZU5vZGUsIGRhdGEpKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihlcnJvck9yUHJvbWlzZSk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7IGluZGV4OiBpLCBzY2hlbWE6IG9uZU5vZGUuc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBAZXZhbHVhdGlvbi1pbmZvXG4gICAgICAgIHNldE9uZU9mT3JpZ2luKG1hdGNoZXNbMF0uc2NoZW1hLCBtYXRjaGVzWzBdLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIG5vZGUubmV4dChtYXRjaGVzWzBdLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tdWx0aXBsZU9uZU9mRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5vbmVPZkVycm9yKHtcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICBwb2ludGVyLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG9uZU9mOiBzY2hlbWEub25lT2YsXG4gICAgICAgIGVycm9yc1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmFua2luZyBmb3IgdGhlIGRhdGEgYW5kIGdpdmVuIHNjaGVtYVxuICpcbiAqIEBwYXJhbSBkcmFmdFxuICogQHBhcmFtIC0ganNvbiBzY2hlbWEgdHlwZTogb2JqZWN0XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIFtwb2ludGVyXVxuICogQHJldHVybiByYW5raW5nIHZhbHVlIChoaWdoZXIgaXMgYmV0dGVyKVxuICovXG5mdW5jdGlvbiBmdXp6eU9iamVjdFZhbHVlKG5vZGUsIGRhdGEpIHtcbiAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBzY2hlbWEucHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICBpZiAoZHJhZnQuaXNWYWxpZChkYXRhW2tleV0sIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0sIHBvaW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFNlbGVjdHMgYW5kIHJldHVybnMgYSBvbmVPZiBzY2hlbWEgZm9yIHRoZSBnaXZlbiBkYXRhXG4gKlxuICogQHBhcmFtIGRyYWZ0XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIFtzY2hlbWFdIC0gY3VycmVudCBqc29uIHNjaGVtYSBjb250YWluaW5nIHByb3BlcnR5IG9uZU9mXG4gKiBAcGFyYW0gW3BvaW50ZXJdIC0ganNvbiBwb2ludGVyIHRvIGRhdGFcbiAqIEByZXR1cm4gb25lT2Ygc2NoZW1hIG9yIGFuIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT25lT2ZGdXp6eShub2RlLCBkYXRhKSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIHBvaW50ZXIsIGRyYWZ0IH0gPSBub2RlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhIG9uZW9mIHNjaGVtYVwiKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8vICFrZXl3b3JkOiBvbmVPZlByb3BlcnR5XG4gICAgLy8gYW4gYWRkaXRpb25hbCA8REVDTEFSQVRPUl9PTkVPRj4gKGRlZmF1bHQgYG9uZU9mUHJvcGVydHlgKSBvbiB0aGUgc2NoZW1hIHdpbGwgZXhhY3RseSBkZXRlcm1pbmUgdGhlXG4gICAgLy8gb25lT2YgdmFsdWUgKGlmIHNldCBpbiBkYXRhKVxuICAgIC8vIEBmaXhtZVxuICAgIC8vIGFib3J0IGlmIG5vIGRhdGEgaXMgZ2l2ZW4gYW4gREVDTEFSQVRPUl9PTkVPRiBpcyBzZXQgKHVzZWQgYnkgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24pXG4gICAgLy8gdGhpcyBjYXNlIChkYXRhICE9IG51bGwpIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5XG4gICAgaWYgKGRhdGEgIT0gbnVsbCAmJiBzY2hlbWFbREVDTEFSQVRPUl9PTkVPRl0pIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IG9uZU9mUHJvcGVydHkgPSBzY2hlbWFbREVDTEFSQVRPUl9PTkVPRl07XG4gICAgICAgIGNvbnN0IG9uZU9mVmFsdWUgPSBkYXRhW3NjaGVtYVtERUNMQVJBVE9SX09ORU9GXV07XG4gICAgICAgIGlmIChvbmVPZlZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWlzc2luZ09uZU9mUHJvcGVydHlFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IG9uZU9mUHJvcGVydHksXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLm9uZU9mLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVOb2RlID0gZHJhZnQucmVzb2x2ZVJlZihub2RlLm5leHQoc2NoZW1hLm9uZU9mW2ldKSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHROb2RlID0gZHJhZnQuc3RlcChvbmVOb2RlLCBvbmVPZlByb3BlcnR5LCBkYXRhKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25FcnJvcihyZXN1bHROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZsYXR0ZW5BcnJheShkcmFmdC52YWxpZGF0ZShyZXN1bHROb2RlLCBvbmVPZlZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGVycm9yT3JQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAZXZhbHVhdGlvbi1pbmZvXG4gICAgICAgICAgICAgICAgc2V0T25lT2ZPcmlnaW4ob25lTm9kZS5zY2hlbWEsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHROb2RlLm5leHQob25lTm9kZS5zY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMub25lT2ZQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBvbmVPZlByb3BlcnR5LFxuICAgICAgICAgICAgdmFsdWU6IG9uZU9mVmFsdWUsXG4gICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBrZXl3b3JkOiBvbmVPZlxuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5vbmVPZi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvbmVOb2RlID0gZHJhZnQucmVzb2x2ZVJlZihub2RlLm5leHQoc2NoZW1hLm9uZU9mW2ldKSk7XG4gICAgICAgIGNvbnN0IG9uZSA9IG9uZU5vZGUuc2NoZW1hO1xuICAgICAgICBpZiAoZHJhZnQuaXNWYWxpZChkYXRhLCBvbmUsIHBvaW50ZXIpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBzY2hlbWE6IG9uZSwgaW5kZXg6IGkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEBldmFsdWF0aW9uLWluZm9cbiAgICAgICAgc2V0T25lT2ZPcmlnaW4obWF0Y2hlc1swXS5zY2hlbWEsIG1hdGNoZXNbMF0uaW5kZXgpO1xuICAgICAgICByZXR1cm4gbm9kZS5uZXh0KG1hdGNoZXNbMF0uc2NoZW1hKTtcbiAgICB9XG4gICAgLy8gZnV6enkgbWF0Y2ggb25lT2ZcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgbGV0IHNjaGVtYU9mSXRlbTtcbiAgICAgICAgbGV0IHNjaGVtYU9mSW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGZ1enp5R3JlYXRlc3QgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5vbmVPZi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qgb25lTm9kZSA9IGRyYWZ0LnJlc29sdmVSZWYobm9kZS5uZXh0KHNjaGVtYS5vbmVPZltpXSkpO1xuICAgICAgICAgICAgY29uc3QgZnV6enlWYWx1ZSA9IGZ1enp5T2JqZWN0VmFsdWUob25lTm9kZSwgZGF0YSk7XG4gICAgICAgICAgICBpZiAoZnV6enlHcmVhdGVzdCA8IGZ1enp5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmdXp6eUdyZWF0ZXN0ID0gZnV6enlWYWx1ZTtcbiAgICAgICAgICAgICAgICBzY2hlbWFPZkl0ZW0gPSBvbmVOb2RlLnNjaGVtYTtcbiAgICAgICAgICAgICAgICBzY2hlbWFPZkluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hT2ZJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMub25lT2ZFcnJvcih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIG9uZU9mOiBzY2hlbWEub25lT2ZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBldmFsdWF0aW9uLWluZm9cbiAgICAgICAgc2V0T25lT2ZPcmlnaW4oc2NoZW1hT2ZJdGVtLCBzY2hlbWFPZkluZGV4KTtcbiAgICAgICAgcmV0dXJuIG5vZGUubmV4dChzY2hlbWFPZkl0ZW0pO1xuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubXVsdGlwbGVPbmVPZkVycm9yKHsgbWF0Y2hlcywgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZTogZGF0YSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5vbmVPZkVycm9yKHtcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICBwb2ludGVyLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG9uZU9mOiBzY2hlbWEub25lT2ZcbiAgICB9KTtcbn1cbi8qKlxuICogdmFsaWRhdGVzIG9uZU9mIGRlZmluaXRpb24gZm9yIGdpdmVuIGlucHV0IGRhdGFcbiAqL1xuY29uc3QgdmFsaWRhdGVPbmVPZiA9IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICBjb25zdCBub2RlT3JFcnJvciA9IG5vZGUuZHJhZnQucmVzb2x2ZU9uZU9mKG5vZGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGlzSnNvbkVycm9yKG5vZGVPckVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVPckVycm9yO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCB7IHZhbGlkYXRlT25lT2YgfTtcbiIsImltcG9ydCBnZXRUeXBlT2YgZnJvbSBcIi4vZ2V0VHlwZU9mXCI7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCIuL3V0aWxzL2lzT2JqZWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTY2hlbWEoYSwgYiwgLi4ub21pdCkge1xuICAgIGlmICgoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLnR5cGUpID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKChhID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEudHlwZSkgPT09IFwiZXJyb3JcIikge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgY29uc3QgYVR5cGUgPSBnZXRUeXBlT2YoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRUeXBlT2YoYik7XG4gICAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0gbWVyZ2VTY2hlbWEyKGEsIGIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb21pdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkZWxldGUgc2NoZW1hW29taXRbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU2NoZW1hMihhLCBiLCBwcm9wZXJ0eSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaXNPYmplY3QoYSkgJiYgaXNPYmplY3QoYikpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqZWN0ID0ge307XG4gICAgICAgIFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uT2JqZWN0LmtleXMoYildXG4gICAgICAgICAgICAuZmlsdGVyKChpdGVtLCBpbmRleCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2YoaXRlbSkgPT09IGluZGV4KVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IChuZXdPYmplY3Rba2V5XSA9IG1lcmdlU2NoZW1hMihhW2tleV0sIGJba2V5XSwga2V5KSkpO1xuICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJyZXF1aXJlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYikuZmlsdGVyKChpdGVtLCBpbmRleCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2YoaXRlbSkgPT09IGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHkgPT09IFwiaXRlbXNcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoYVtpXSkgJiYgaXNPYmplY3QoYltpXSkgJiYgYVtpXS50eXBlID09PSBiW2ldLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gbWVyZ2VTY2hlbWEyKGFbaV0sIGJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goKF9hID0gYltpXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgYXBwZW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoYVtpXSkgJiYgaXNPYmplY3QoYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBtZXJnZVNjaGVtYTIoYVtpXSwgYltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gdW5kZWZpbmVkICYmIGJbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBhW2ldO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmQucHVzaChiW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmQucHVzaChiW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLmFwcGVuZF0uZmlsdGVyKChpdGVtLCBpbmRleCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2YoaXRlbSkgPT09IGluZGV4KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbiIsIi8qKlxuICogT21pdCBwcm9wZXJ0aWVzIGZyb20gaW5wdXQgc2NoZW1hLiBBY2NlcHRzIGFueSBudW1iZXIgb2YgcHJvcGVydGllcyB0b1xuICogcmVtb3ZlLiBFeGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKiBvbWl0KG15T2JqZWN0LCBcImlmXCIsIFwiZGVwZW5kZW5jaWVzXCIpO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIGlucHV0IG9iamVjdCB3aXRob3V0IHNwZWNpZmllZCBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0KG9iamVjdCwgLi4ua2V5c1RvT21pdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICgha2V5c1RvT21pdC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qKlxuICogcmV0dXJucyBpZi10aGVuLWVsc2UgYXMgYSBqc29uIHNjaGVtYS4gZG9lcyBub3QgbWVyZ2Ugd2l0aCBpbnB1dFxuICoganNvbiBzY2hlbWEuIHlvdSBwcm9iYWJseSB3aWxsIG5lZWQgdG8gZG8gc28gdG8gY29ycmVjdGx5IHJlc29sdmVcbiAqIHJlZmVyZW5jZXMuXG4gKlxuICogQHJldHVybnMganNvbiBzY2hlbWEgZGVmaW5lZCBieSBpZi10aGVuLWVsc2Ugb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSWZTY2hlbWEobm9kZSwgZGF0YSkge1xuICAgIGlmIChub2RlLnNjaGVtYS5pZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChub2RlLnNjaGVtYS5pZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gQGV2YWx1YXRpb24taW5mb1xuICAgICAgICAvLyBzY2hlbWEuX19pZmVsc2UgPSB0cnVlXG4gICAgICAgIHJldHVybiBub2RlLm5leHQobm9kZS5zY2hlbWEuZWxzZSk7XG4gICAgfVxuICAgIGlmIChub2RlLnNjaGVtYS5pZiAmJiAobm9kZS5zY2hlbWEudGhlbiB8fCBub2RlLnNjaGVtYS5lbHNlKSkge1xuICAgICAgICBjb25zdCBpZk5vZGUgPSBub2RlLmRyYWZ0LnJlc29sdmVSZWYobm9kZS5uZXh0KG5vZGUuc2NoZW1hLmlmKSk7XG4gICAgICAgIGNvbnN0IGlmRXJyb3JzID0gbm9kZS5kcmFmdC52YWxpZGF0ZShpZk5vZGUsIGRhdGEpO1xuICAgICAgICBpZiAoaWZFcnJvcnMubGVuZ3RoID09PSAwICYmIG5vZGUuc2NoZW1hLnRoZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHRoZW5Ob2RlID0gbm9kZS5uZXh0KG5vZGUuc2NoZW1hLnRoZW4pO1xuICAgICAgICAgICAgLy8gQGV2YWx1YXRpb24taW5mb1xuICAgICAgICAgICAgLy8gc2NoZW1hLl9faWZ0aGVuID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZHJhZnQucmVzb2x2ZVJlZih0aGVuTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlmRXJyb3JzLmxlbmd0aCAhPT0gMCAmJiBub2RlLnNjaGVtYS5lbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBlbHNlTm9kZSA9IG5vZGUubmV4dChub2RlLnNjaGVtYS5lbHNlKTtcbiAgICAgICAgICAgIC8vIEBldmFsdWF0aW9uLWluZm9cbiAgICAgICAgICAgIC8vIHNjaGVtYS5fX2lmZWxzZSA9IHRydWVcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRyYWZ0LnJlc29sdmVSZWYoZWxzZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEByZXR1cm5zIHZhbGlkYXRpb24gcmVzdWx0IG9mIGl0LXRoZW4tZWxzZSBzY2hlbWFcbiAqL1xuY29uc3QgdmFsaWRhdGVJZiA9IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkTm9kZSA9IHJlc29sdmVJZlNjaGVtYShub2RlLCB2YWx1ZSk7XG4gICAgaWYgKHJlc29sdmVkTm9kZSkge1xuICAgICAgICAvLyBAcmVjdXJzaXZlUmVmIG9rLCB3ZSBub3QganVzdCBhZGQgcGVyIHBvaW50ZXIsIGJ1dCBhbnkgZXZsdWF0aW9uIHRvIGR5bmFtaWMgc2NvcGUgLyB2YWxpZGF0aW9uIHBhdGhcbiAgICAgICAgcmV0dXJuIG5vZGUuZHJhZnQudmFsaWRhdGUocmVzb2x2ZWROb2RlLCB2YWx1ZSk7XG4gICAgfVxufTtcbmV4cG9ydCB7IHZhbGlkYXRlSWYgfTtcbiIsImV4cG9ydCBmdW5jdGlvbiBzaGFsbG93Q2xvbmVTY2hlbWFOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4geyAuLi5ub2RlIH07XG59XG4iLCJpbXBvcnQgeyBtZXJnZVNjaGVtYSB9IGZyb20gXCIuLi9tZXJnZVNjaGVtYVwiO1xuaW1wb3J0IHsgb21pdCB9IGZyb20gXCIuLi91dGlscy9vbWl0XCI7XG5pbXBvcnQgeyByZXNvbHZlSWZTY2hlbWEgfSBmcm9tIFwiLi9pZlwiO1xuaW1wb3J0IHsgc2hhbGxvd0Nsb25lU2NoZW1hTm9kZSB9IGZyb20gXCIuLi91dGlscy9zaGFsbG93Q2xvbmVTY2hlbWFcIjtcbi8qKlxuICogcmVzb2x2ZXMgc2NoZW1hXG4gKiB3aGVuIGNvbXBsZXRlIHRoaXMgd2lsbCBoYXZlIG11Y2ggZHVwbGljYXRpb24gdG8gc3RlcC5vYmplY3QgZXRjXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKG5vZGUsIGRhdGEpIHtcbiAgICBjb25zdCBpZlNjaGVtYSA9IHJlc29sdmVJZlNjaGVtYShub2RlLCBkYXRhKTtcbiAgICBpZiAoaWZTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGlmU2NoZW1hO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWEgPSBzaGFsbG93Q2xvbmVTY2hlbWFOb2RlKG5vZGUuc2NoZW1hKTtcbiAgICByZXR1cm4gbm9kZS5uZXh0KG9taXQoc2NoZW1hLCBcImlmXCIsIFwidGhlblwiLCBcImVsc2VcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBbGxPZihub2RlLCBkYXRhKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IG5vZGU7XG4gICAgbGV0IG1lcmdlZFNjaGVtYSA9IHNoYWxsb3dDbG9uZVNjaGVtYU5vZGUoc2NoZW1hKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBhbGxPZk5vZGUgPSBub2RlLm5leHQoc2NoZW1hLmFsbE9mW2ldKS5yZXNvbHZlUmVmKCk7XG4gICAgICAgIC8vIEB0b2RvIGludHJvZHVjZSBkcmFmdC5yZXNvbHZlU2NoZW1hIHRvIGl0ZXJhdGl2ZWx5IHJlc29sdmVcbiAgICAgICAgY29uc3QgYWxsT2ZTY2hlbWEgPSByZXNvbHZlU2NoZW1hKGFsbE9mTm9kZSwgZGF0YSkuc2NoZW1hO1xuICAgICAgICBtZXJnZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShtZXJnZWRTY2hlbWEsIGFsbE9mU2NoZW1hKTtcbiAgICB9XG4gICAgZGVsZXRlIG1lcmdlZFNjaGVtYS5hbGxPZjtcbiAgICByZXR1cm4gbm9kZS5uZXh0KG1lcmdlZFNjaGVtYSk7XG59XG4vKipcbiAqIEBhdHRlbnRpb246IHN1YnNjaGVtYXMgaGF2ZSB0byBiZSByZXNvbHZlZCB1cGZyb250IChlLmcuIGlmLWVsc2UgdGhhdCBkbyBub3QgYXBwbHkpXG4gKiBNZXJnZSBhbGwgYWxsT2Ygc3ViIHNjaGVtYSBpbnRvIGEgc2luZ2xlIHNjaGVtYS4gUmV0dXJucyB1bmRlZmluZWQgZm9yXG4gKiBtaXNzaW5nIGFsbE9mIGRlZmluaXRpb24uXG4gKlxuICogQHJldHVybnMganNvbiBzY2hlbWEgZGVmaW5lZCBieSBhbGxPZiBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQWxsT2ZTY2hlbWEoZHJhZnQsIHNjaGVtYSkge1xuICAgIGNvbnN0IHsgYWxsT2YgfSA9IHNjaGVtYTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsT2YpIHx8IGFsbE9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXNvbHZlZFNjaGVtYSA9IHt9O1xuICAgIGFsbE9mLmZvckVhY2goKHN1YnNjaGVtYSkgPT4ge1xuICAgICAgICBpZiAoc3Vic2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJTY2hlbWFOb2RlID0gZHJhZnQuY3JlYXRlTm9kZShzdWJzY2hlbWEpLnJlc29sdmVSZWYoKTtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSwgc3ViU2NoZW1hTm9kZS5zY2hlbWEpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXNvbHZlZFNjaGVtYTtcbn1cbi8qKlxuICogdmFsaWRhdGUgYWxsT2YgZGVmaW5pdGlvbiBmb3IgZ2l2ZW4gaW5wdXQgZGF0YVxuICovXG5jb25zdCB2YWxpZGF0ZUFsbE9mID0gKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hIH0gPSBub2RlO1xuICAgIGNvbnN0IHsgYWxsT2YgfSA9IHNjaGVtYTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsT2YpIHx8IGFsbE9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIHNjaGVtYS5hbGxPZi5mb3JFYWNoKChzdWJTY2hlbWEpID0+IHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZHJhZnQudmFsaWRhdGUobm9kZS5uZXh0KHN1YlNjaGVtYSksIHZhbHVlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG5leHBvcnQgeyB2YWxpZGF0ZUFsbE9mIH07XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tIFwiLi91dGlscy9pc09iamVjdFwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgbWVyZ2VTY2hlbWEgfSBmcm9tIFwiLi9tZXJnZVNjaGVtYVwiO1xuZnVuY3Rpb24gbWVyZ2Uoc2NoZW1hLCAuLi5vbWl0KSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZWZpbmVkIHNjaGVtYWApO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGhpcztcbiAgICBjb25zdCBtZXJnZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShub2RlLnNjaGVtYSwgc2NoZW1hLCAuLi5vbWl0KTtcbiAgICByZXR1cm4geyAuLi5ub2RlLCBzY2hlbWE6IG1lcmdlZFNjaGVtYSwgcGF0aDogWy4uLm5vZGUucGF0aCwgW25vZGUucG9pbnRlciwgbm9kZS5zY2hlbWFdXSB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlZigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcztcbiAgICByZXR1cm4gbm9kZS5kcmFmdC5yZXNvbHZlUmVmKG5vZGUpO1xufVxuZnVuY3Rpb24gbmV4dChzY2hlbWEsIGtleSkge1xuICAgIGlmIChpc0pzb25FcnJvcihzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZGVmaW5lZCBzY2hlbWFgKTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChzY2hlbWEpICYmIGdldFR5cGVPZihzY2hlbWEpICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBzY2hlbWEgdHlwZSAke2dldFR5cGVPZihzY2hlbWEpfWApO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBwb2ludGVyOiBrZXkgPyBgJHtub2RlLnBvaW50ZXJ9LyR7a2V5fWAgOiBub2RlLnBvaW50ZXIsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgcGF0aDogWy4uLm5vZGUucGF0aCwgW25vZGUucG9pbnRlciwgbm9kZS5zY2hlbWFdXVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTY2hlbWFOb2RlKHZhbHVlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB1bmtub3duIG9iamVjdFxuICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUubmV4dCAmJiB2YWx1ZS5wYXRoICYmIHZhbHVlLmRyYWZ0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoZHJhZnQsIHNjaGVtYSwgcG9pbnRlciA9IFwiI1wiKSB7XG4gICAgcmV0dXJuIHsgZHJhZnQsIHBvaW50ZXIsIHNjaGVtYSwgcGF0aDogW10sIG5leHQsIG1lcmdlLCByZXNvbHZlUmVmIH07XG59XG4iLCJpbXBvcnQgeyBpc1NjaGVtYU5vZGUgfSBmcm9tIFwiLi9zY2hlbWFOb2RlXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmVmKG5vZGUpIHtcbiAgICBpZiAoIWlzU2NoZW1hTm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbm9kZSBleHBlY3RlZFwiKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuc2NoZW1hID09IG51bGwgfHwgbm9kZS5zY2hlbWEuJHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBpZiAobm9kZS5zY2hlbWEuZ2V0Um9vdCkge1xuICAgICAgICAvLyB3ZSBhY3R1YWxseSBhbHdheXMgbmVlZCB0byByZXNvbHZlIHRoZSBzY2hlbWEgbGlrZSB0aGlzLCBzaW5jZSByZXR1cm5lZCBzdWJzY2hlbWFzXG4gICAgICAgIC8vIG11c3QgcmVzb2x2ZSByZWxhdGl2ZSBmcm9tIHRoZWlyIHNjaGVtYVxuICAgICAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IG5vZGUuc2NoZW1hLmdldFJvb3QoKS5nZXRSZWYobm9kZS5zY2hlbWEpO1xuICAgICAgICByZXR1cm4gbm9kZS5uZXh0KHJlc29sdmVkU2NoZW1hKTtcbiAgICB9XG4gICAgLy8gdHJ5b3V0IC0gdGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkLCBleGNlcHQgd2UgbWlzc2VkIHNvbWV0aGluZ1xuICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gbm9kZS5kcmFmdC5yb290U2NoZW1hLmdldFJlZihub2RlLnNjaGVtYSk7XG4gICAgcmV0dXJuIG5vZGUubmV4dChyZXNvbHZlZFNjaGVtYSk7XG59XG4iLCJpbXBvcnQgeyBpc1NjaGVtYU5vZGUgfSBmcm9tIFwiLi9zY2hlbWFOb2RlXCI7XG4vLyAxLiBodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L2pzb24tc2NoZW1hLWNvcmUjc2NvcGVzXG5mdW5jdGlvbiByZXNvbHZlUmVjdXJzaXZlUmVmKG5vZGUpIHtcbiAgICBjb25zdCBoaXN0b3J5ID0gbm9kZS5wYXRoO1xuICAgIC8vIGNvbnNvbGUubG9nKC4uLmhpc3RvcnkpO1xuICAgIC8vIFJFU1RSSUNUIEJZIENIQU5HRSBJTiBCQVNFLVVSTFxuICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gaGlzdG9yeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBzdGVwID0gaGlzdG9yeVtpXVsxXTtcbiAgICAgICAgaWYgKHN0ZXAuJGlkICYmIC9eaHR0cHM/OlxcL1xcLy8udGVzdChzdGVwLiRpZCkgJiYgc3RlcC4kcmVjdXJzaXZlQW5jaG9yICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZST00gVEhFUkUgRklORCBGSVJTVCBPQ0NVUkVOQ0UgT0YgQU5DSE9SXG4gICAgY29uc3QgZmlyc3RBbmNob3IgPSBoaXN0b3J5LmZpbmQoKHMsIGluZGV4KSA9PiBpbmRleCA+PSBzdGFydEluZGV4ICYmIHNbMV0uJHJlY3Vyc2l2ZUFuY2hvciA9PT0gdHJ1ZSk7XG4gICAgaWYgKGZpcnN0QW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5leHQoZmlyc3RBbmNob3JbMV0pO1xuICAgIH1cbiAgICAvLyBUSEVOIFJFVFVSTiBMQVRFU1QgQkFTRSBBUyBUQVJHRVRcbiAgICBmb3IgKGxldCBpID0gaGlzdG9yeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBzdGVwID0gaGlzdG9yeVtpXVsxXTtcbiAgICAgICAgaWYgKHN0ZXAuJGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0KHN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE9SIFJFVFVSTiBST09UXG4gICAgcmV0dXJuIG5vZGUubmV4dChub2RlLmRyYWZ0LnJvb3RTY2hlbWEpO1xufVxuLyoqXG4gKiBAdG9kbyB1cGRhdGUgdHlwZXNcbiAqIE5vdGU6IEpzb25TY2hlbWEgbXkgYmUgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJlZihub2RlKSB7XG4gICAgaWYgKCFpc1NjaGVtYU5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbm9kZVwiKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuc2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlLnNjaGVtYS4kcmVjdXJzaXZlUmVmKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlUmVmKHJlc29sdmVSZWN1cnNpdmVSZWYobm9kZSkpO1xuICAgIH1cbiAgICBpZiAobm9kZS5zY2hlbWEuJHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IG5vZGUuZHJhZnQucm9vdFNjaGVtYS5nZXRSZWYobm9kZS5zY2hlbWEpO1xuICAgIGlmIChyZXNvbHZlZFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubmV4dChyZXNvbHZlZFNjaGVtYSk7XG4gICAgfVxuICAgIC8vIEBkcmFmdCA+PSAyMDE5LTA5IHdlIG5vdyBtZXJnZSBzY2hlbWFzOiBpbiBkcmFmdCA8PSA3ICRyZWYgaXMgdHJlYXRlZCBhcyByZWZlcmVuY2UsIG5vdCBhcyBzY2hlbWFcbiAgICByZXR1cm4gbm9kZS5tZXJnZShyZXNvbHZlZFNjaGVtYSwgXCIkcmVmXCIpO1xufVxuIiwiaW1wb3J0IHsgZXJyb3JzT25seSB9IGZyb20gXCIuL3V0aWxzL2ZpbHRlclwiO1xuaW1wb3J0IGZsYXR0ZW5BcnJheSBmcm9tIFwiLi91dGlscy9mbGF0dGVuQXJyYXlcIjtcbmltcG9ydCB7IGlzSnNvbkVycm9yIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTm90aWZpY2F0aW9uKG9uRXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvciA9IGZsYXR0ZW5BcnJheShlcnJvcik7XG4gICAgICAgICAgICBlcnJvci5mb3JFYWNoKG5vdGlmeUVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNKc29uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbn1cbi8qKlxuICogQGFzeW5jXG4gKiBWYWxpZGF0ZSBkYXRhIGJ5IGEganNvbiBzY2hlbWFcbiAqXG4gKiBAcGFyYW0gZHJhZnQgLSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnMuc2NoZW1hIC0ganNvbiBzY2hlbWEgdG8gdXNlLCBkZWZhdWx0cyB0byBkcmFmdC5yb290U2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9ucy5wb2ludGVyIC0ganNvbiBwb2ludGVyIHBvaW50aW5nIHRvIGN1cnJlbnQgdmFsdWUuIFVzZWQgaW4gZXJyb3IgcmVwb3J0c1xuICogQHBhcmFtIG9wdGlvbnMub25FcnJvciAgIC0gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZXJyb3IgYXMgc29vbiBhcyBpdCBpcyByZXNvbHZlZFxuICogQHJldHVybiBsaXN0IG9mIGVycm9ycyBvciBlbXB0eVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKGRyYWZ0LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBwb2ludGVyLCBvbkVycm9yIH0gPSB7IHNjaGVtYTogZHJhZnQucm9vdFNjaGVtYSwgcG9pbnRlcjogXCIjXCIsIC4uLm9wdGlvbnMgfTtcbiAgICBsZXQgZXJyb3JzID0gZHJhZnQudmFsaWRhdGUoZHJhZnQuY3JlYXRlTm9kZShzY2hlbWEsIHBvaW50ZXIpLCB2YWx1ZSk7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzID0gZmxhdHRlbkFycmF5KGVycm9ycyk7XG4gICAgICAgIGNvbnN0IG5vdGlmeUVycm9yID0gY3JlYXRlRXJyb3JOb3RpZmljYXRpb24ob25FcnJvcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yc1tpXTtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50aGVuKG5vdGlmeUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSnNvbkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChlcnJvcnMpXG4gICAgICAgIC50aGVuKGZsYXR0ZW5BcnJheSlcbiAgICAgICAgLnRoZW4oKHJlc29sdmVkRXJyb3JzKSA9PiByZXNvbHZlZEVycm9ycy5maWx0ZXIoZXJyb3JzT25seSkpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCByZXNvbHZpbmcgcHJvbWlzZXNcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfSk7XG59XG4iLCIvKipcbiAqIEByZXR1cm5zIGxpc3Qgd2l0aCB1bmlxdWUgdmFsdWVzIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUl0ZW1zKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5maWx0ZXIoKGl0ZW0sIGluZGV4KSA9PiBsaXN0LmluZGV4T2YoaXRlbSkgPT09IGluZGV4KTtcbn1cbiIsImltcG9ydCBnZXRUeXBlT2YgZnJvbSBcIi4uL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgbWVyZ2VTY2hlbWEgfSBmcm9tIFwiLi4vbWVyZ2VTY2hlbWFcIjtcbmltcG9ydCB7IHVuaXF1ZUl0ZW1zIH0gZnJvbSBcIi4uL3V0aWxzL3VuaXF1ZUl0ZW1zXCI7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCIuLi91dGlscy9pc09iamVjdFwiO1xuLyoqXG4gKiBAdG9kbyBhZGQgc3VwcG9ydCBmb3IgZGVwZW5kZW50UmVxdWlyZWQgKGRyYWZ0IDIwMTktMDkpXG4gKiByZXR1cm5zIGRlcGVuZGVuY2llcyBhcyBhbiBvYmplY3QganNvbiBzY2hlbWEuIGRvZXMgbm90IG1lcmdlIHdpdGggaW5wdXRcbiAqIGpzb24gc2NoZW1hLiB5b3UgcHJvYmFibHkgd2lsbCBuZWVkIHRvIGRvIHNvIHRvIGNvcnJlY3RseSByZXNvbHZlXG4gKiByZWZlcmVuY2VzLlxuICpcbiAqIEByZXR1cm5zIG1lcmdlZCBqc29uIHNjaGVtYSBkZWZpbmVkIGJ5IGRlcGVuZGVuY2llcyBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVEZXBlbmRlbmNpZXMobm9kZSwgZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gbm9kZTtcbiAgICAvLyBAZHJhZnQgPj0gMjAxOS0wOSBkZXBlbmRlbnRTY2hlbWFzXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gKF9hID0gc2NoZW1hLmRlcGVuZGVuY2llcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2NoZW1hLmRlcGVuZGVudFNjaGVtYXM7XG4gICAgaWYgKCFpc09iamVjdChkZXBlbmRlbmNpZXMpIHx8ICFpc09iamVjdChkYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hID0geyByZXF1aXJlZDogW10gfTtcbiAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGRhdGFbcHJvcF0gPT0gbnVsbCAmJlxuICAgICAgICAgICAgISgoKF9hID0gc2NoZW1hLnJlcXVpcmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMocHJvcCkpIHx8ICgoX2IgPSByZXNvbHZlZFNjaGVtYS5yZXF1aXJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKHByb3ApKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW3Byb3BdO1xuICAgICAgICAvLyBkZXBlbmRlbmN5IGFycmF5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmVkU2NoZW1hLnJlcXVpcmVkLnB1c2goLi4uZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVwZW5kZW5jeSBzY2hlbWFcbiAgICAgICAgaWYgKGlzT2JqZWN0KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGROb2RlID0gbm9kZS5uZXh0KGRlcGVuZGVuY3kpLnJlc29sdmVSZWYoKTtcbiAgICAgICAgICAgIHJlc29sdmVkU2NoZW1hID0gbWVyZ2VTY2hlbWEocmVzb2x2ZWRTY2hlbWEsIGROb2RlLnNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICByZXNvbHZlZFNjaGVtYS5yZXF1aXJlZCA9IHVuaXF1ZUl0ZW1zKHJlc29sdmVkU2NoZW1hLnJlcXVpcmVkKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xuICAgIH1cbn1cbi8qKlxuICogQGRyYWZ0IDIwMTktMDlcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRGVwZW5kZW50UmVxdWlyZWQgPSAobm9kZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgY29uc3QgZGVwZW5kZW50UmVxdWlyZWQgPSBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWQ7XG4gICAgaWYgKCFpc09iamVjdChkZXBlbmRlbnRSZXF1aXJlZCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGRlcGVuZGVudFJlcXVpcmVkW3Byb3BlcnR5XTtcbiAgICAgICAgLy8gQGRyYWZ0ID49IDYgYm9vbGVhbiBzY2hlbWFcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMubWlzc2luZ0RlcGVuZGVuY3lFcnJvcih7IHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbZGVwZW5kZW5jaWVzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLm1pc3NpbmdEZXBlbmRlbmN5RXJyb3IoeyBtaXNzaW5nUHJvcGVydHk6IGRlcGVuZGVuY2llc1tpXSwgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbi8qKlxuICogQGRyYWZ0IDIwMTktMDlcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRGVwZW5kZW50U2NoZW1hcyA9IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICBjb25zdCBkZXBlbmRlbnRTY2hlbWFzID0gc2NoZW1hLmRlcGVuZGVudFNjaGVtYXM7XG4gICAgaWYgKCFpc09iamVjdChkZXBlbmRlbnRTY2hlbWFzKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW50U2NoZW1hc1twcm9wZXJ0eV07XG4gICAgICAgIC8vIEBkcmFmdCA+PSA2IGJvb2xlYW4gc2NoZW1hXG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLm1pc3NpbmdEZXBlbmRlbmN5RXJyb3IoeyBwb2ludGVyLCBzY2hlbWEsIHZhbHVlIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRlcGVuZGVuY2llcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkcmFmdC52YWxpZGF0ZShub2RlLm5leHQoZGVwZW5kZW5jaWVzKSwgdmFsdWUpLm1hcChlcnJvciA9PiBlcnJvcnMucHVzaChlcnJvcikpO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuLyoqXG4gKiB2YWxpZGF0ZSBkZXBlbmRlbmNpZXMgZGVmaW5pdGlvbiBmb3IgZ2l2ZW4gaW5wdXQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVEZXBlbmRlbmNpZXMgPSAobm9kZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgLy8gQGRyYWZ0ID49IDIwMTktMDkgZGVwZW5kZW50U2NoZW1hc1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHNjaGVtYS5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKCFpc09iamVjdChkZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQGRyYWZ0ID49IDYgYm9vbGVhbiBzY2hlbWFcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llc1twcm9wZXJ0eV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzW3Byb3BlcnR5XSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy5taXNzaW5nRGVwZW5kZW5jeUVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlcGVuZGVuY3lFcnJvcnM7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlT2YoZGVwZW5kZW5jaWVzW3Byb3BlcnR5XSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSBkZXBlbmRlbmNpZXNbcHJvcGVydHldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jeUVycm9ycyA9IHByb3BlcnR5VmFsdWVcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChkZXBlbmRlbmN5KSA9PiB2YWx1ZVtkZXBlbmRlbmN5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKG1pc3NpbmdQcm9wZXJ0eSkgPT4gZHJhZnQuZXJyb3JzLm1pc3NpbmdEZXBlbmRlbmN5RXJyb3IoeyBtaXNzaW5nUHJvcGVydHksIHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY3lFcnJvcnMgPSBkcmFmdC52YWxpZGF0ZShub2RlLm5leHQoZGVwZW5kZW5jaWVzW3Byb3BlcnR5XSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZXBlbmRlbmN5IGRlZmluaXRpb24gZm9yICR7cG9pbnRlcn0vJHtwcm9wZXJ0eX0uIE11c3QgYmUgc3RyaW5nW10gb3Igc2NoZW1hYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZGVwZW5kZW5jeUVycm9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZXJyb3JzIDogdW5kZWZpbmVkO1xufTtcbiIsIi8qKlxuICogQGRyYWZ0LTA0XG4gKi9cbmltcG9ydCB7IG1lcmdlU2NoZW1hIH0gZnJvbSBcIi4uL21lcmdlU2NoZW1hXCI7XG4vKipcbiAqIHJldHVybnMgbWVyZ2VkIHNjaGVtYSBvZiBhbGwgdmFsaWQgYW55T2Ygc3Vic2NoZW1hcyBmb3IgdGhlIGdpdmVuIGlucHV0IGRhdGEuXG4gKiBEb2VzIG5vdCBtZXJnZSB3aXRoIHJlc3QgaW5wdXQgc2NoZW1hLlxuICpcbiAqIEByZXR1cm5zIG1lcmdlZCBhbnlPZiBzdWJzY2hlbWFzIHdoaWNoIGFyZSB2YWxpZCB0byB0aGUgZ2l2ZW4gaW5wdXQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVmFsaWRBbnlPZlNjaGVtYShub2RlLCBkYXRhKSB7XG4gICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hIH0gPSBub2RlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpIHx8IHNjaGVtYS5hbnlPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRTY2hlbWE7XG4gICAgc2NoZW1hLmFueU9mLmZvckVhY2goKGFueVNjaGVtYSkgPT4ge1xuICAgICAgICBjb25zdCBhbnlOb2RlID0gZHJhZnQucmVzb2x2ZVJlZihub2RlLm5leHQoYW55U2NoZW1hKSk7XG4gICAgICAgIGlmIChkcmFmdC52YWxpZGF0ZShhbnlOb2RlLCBkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmVkU2NoZW1hID0gcmVzb2x2ZWRTY2hlbWEgPyBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSwgYW55Tm9kZS5zY2hlbWEpIDogYW55Tm9kZS5zY2hlbWE7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubmV4dChyZXNvbHZlZFNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBAdW51c2VkIHRoaXMgZnVuY3Rpb24gaXMgb25seSBleHBvc2VkIHZpYSBkcmFmdCBhbmQgbm90IHVzZWQgb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyBleHRlbmRlZCBpbnB1dCBzY2hlbWEgd2l0aCB2YWxpZCBhbnlPZiBzdWJzY2hlbWFzIG9yIEpzb25FcnJvciBpZlxuICogbm8gYW55T2Ygc2NoZW1hIG1hdGNoZXMgaW5wdXQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFueU9mKG5vZGUsIGRhdGEpIHtcbiAgICBjb25zdCB7IGFueU9mIH0gPSBub2RlLnNjaGVtYTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW55T2YpIHx8IGFueU9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWROb2RlID0gbWVyZ2VWYWxpZEFueU9mU2NoZW1hKG5vZGUsIGRhdGEpO1xuICAgIGlmIChyZXNvbHZlZE5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBwb2ludGVyLCBzY2hlbWEgfSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlLmRyYWZ0LmVycm9ycy5hbnlPZkVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZTogZGF0YSwgYW55T2Y6IEpTT04uc3RyaW5naWZ5KGFueU9mKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUubWVyZ2UocmVzb2x2ZWROb2RlLnNjaGVtYSwgXCJhbnlPZlwiKTtcbn1cbi8qKlxuICogdmFsaWRhdGUgYW55T2YgZGVmaW5pdGlvbiBmb3IgZ2l2ZW4gaW5wdXQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBbnlPZiA9IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSB8fCBzY2hlbWEuYW55T2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwidmFsaWRhdGUgYW55IG9mXCIsIHBvaW50ZXIsIHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5hbnlPZi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IGRyYWZ0LnJlc29sdmVSZWYobm9kZS5uZXh0KHNjaGVtYS5hbnlPZltpXSkpO1xuICAgICAgICBpZiAoZHJhZnQudmFsaWRhdGUobmV4dE5vZGUsIHZhbHVlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5hbnlPZkVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSwgYW55T2Y6IHNjaGVtYS5hbnlPZiB9KTtcbn07XG4iLCJpbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpc1NjaGVtYU5vZGUgfSBmcm9tIFwiLi9zY2hlbWFOb2RlXCI7XG5pbXBvcnQgeyBtZXJnZVNjaGVtYSB9IGZyb20gXCIuL21lcmdlU2NoZW1hXCI7XG5pbXBvcnQgeyByZXNvbHZlSWZTY2hlbWEgfSBmcm9tIFwiLi9mZWF0dXJlcy9pZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZURlcGVuZGVuY2llcyB9IGZyb20gXCIuL2ZlYXR1cmVzL2RlcGVuZGVuY2llc1wiO1xuaW1wb3J0IHsgbWVyZ2VBbGxPZlNjaGVtYSB9IGZyb20gXCIuL2ZlYXR1cmVzL2FsbE9mXCI7XG5pbXBvcnQgeyBtZXJnZVZhbGlkQW55T2ZTY2hlbWEgfSBmcm9tIFwiLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZU9uZU9mRnV6enkgYXMgcmVzb2x2ZU9uZU9mIH0gZnJvbSBcIi4vZmVhdHVyZXMvb25lT2ZcIjtcbmltcG9ydCB7IG9taXQgfSBmcm9tIFwiLi91dGlscy9vbWl0XCI7XG5jb25zdCB0b09taXQgPSBbXCJhbGxPZlwiLCBcImFueU9mXCIsIFwib25lT2ZcIiwgXCJkZXBlbmRlbmNpZXNcIiwgXCJpZlwiLCBcInRoZW5cIiwgXCJlbHNlXCJdO1xuY29uc3QgZHluYW1pY1Byb3BlcnRpZXMgPSBbXCJhbGxPZlwiLCBcImFueU9mXCIsIFwib25lT2ZcIiwgXCJkZXBlbmRlbmNpZXNcIiwgXCJpZlwiXTtcbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNTY2hlbWEoc2NoZW1hKSB7XG4gICAgY29uc3QgZ2l2ZW5Qcm9wcyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgcmV0dXJuIGR5bmFtaWNQcm9wZXJ0aWVzLmZpbmRJbmRleCgocHJvcCkgPT4gZ2l2ZW5Qcm9wcy5pbmNsdWRlcyhwcm9wKSkgIT09IC0xO1xufVxuLyoqXG4gKiBAbm90ZSB0aGlzIHV0aWxpdHkgZG9lcyBub3QgcmVmZXJlbmNlIGRyYWZ0IG1ldGhvZHMgZm9yIHJlc29sdXRpb25cbiAqIEB0b2RvIGNvbnNpZGVyIHVzaW5nIGRyYWZ0IG1ldGhvZHNcbiAqIEB0b2RvIGNvbnNpZGVyIGV4cG9zaW5nIHNlcGFyYXRlIGluZm8tb2JqZWN0IChvbmVPZi1JbmRleClcbiAqXG4gKiBSZXNvbHZlcyBhbGwgZHluYW1pYyBzY2hlbWEgZGVmaW5pdGlvbnMgZm9yIHRoZSBnaXZlbiBpbnB1dCBkYXRhIGFuZCByZXR1cm5zXG4gKiB0aGUgcmVzdWx0aW5nIGpzb24tc2NoZW1hIHdpdGhvdXQgYW55IGR5bmFtaWMgc2NoZW1hIGRlZmluaXRpb25zLiBUaGUgcmVzdWx0XG4gKiBpcyBub3QgbWVyZ2VkIHdpdGggdGhlIG9yaWdpbmFsIGlucHV0IHNjaGVtYSwgdGh1cyBzdGF0aWMgZGVmaW5pdGlvbnMgb2YgdGhlXG4gKiBpbnB1dCBzY2hlbWEgYXJlIHVudG91Y2hlZCBhbmQgbWlzc2luZy4gRm9yIGEgZnVsbCBzY2hlbWEgZGVmaW5pdGlvbiBvZiB0aGlzXG4gKiBpbnB1dCBkYXRhIHlvdSBoYXZlIHRvIG1lcmdlIHRoZSByZXN1bHQgd2l0aCB0aGUgb3JpZ2luYWwgc2NoZW1hXG4gKiAoQHNlZSByZWR1Y2VTY2hlbWEpXG4gKlxuICogZHluYW1pYyBzY2hlbWEgZGVmaW5pdGlvbnM6IGRlcGVuZGVuY2llcywgYWxsT2YsIGFueU9mLCBvbmVPZiwgaWZcbiAqXG4gKiBAcmV0dXJucyBzdGF0aWMgc2NoZW1hIGZyb20gcmVzb2x2ZWQgZHluYW1pYyBzY2hlbWEgZGVmaW5pdGlvbnMgZm9yIHRoaXNcbiAqICBzcGVjaWZpYyBpbnB1dCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRHluYW1pY1NjaGVtYShzY2hlbWFOb2RlLCBkYXRhKSB7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hO1xuICAgIGxldCBlcnJvcjtcbiAgICBjb25zdCBub2RlID0gc2NoZW1hTm9kZS5kcmFmdC5yZXNvbHZlUmVmKHNjaGVtYU5vZGUpO1xuICAgIGNvbnN0IHsgZHJhZnQgfSA9IG5vZGU7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNTY2hlbWFOb2RlKG5vZGUpID8gbm9kZS5zY2hlbWEgOiBub2RlO1xuICAgIC8vIEBmZWF0dXJlIG9uZU9mXG4gICAgaWYgKHNjaGVtYS5vbmVPZikge1xuICAgICAgICBjb25zdCBvbmVPZlNjaGVtYSA9IHJlc29sdmVPbmVPZihub2RlLCBkYXRhKTtcbiAgICAgICAgaWYgKGlzSnNvbkVycm9yKG9uZU9mU2NoZW1hKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBvbmVPZlNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbmVPZlNjaGVtYSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXNvbHZlZFNjaGVtYSAhPT0gdm9pZCAwID8gcmVzb2x2ZWRTY2hlbWEgOiB7fSwgb25lT2ZTY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAZmVhdHVyZSBhbGxPZlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgY29uc3QgYWxsT2YgPSBzY2hlbWEuYWxsT2YubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAvLyBiZWZvcmUgbWVyZ2luZyBhbGxPZiBzY2hlbWEgd2UgbmVlZCB0byByZXNvbHZlIGFsbCBzdWJzY2hlbWFzXG4gICAgICAgICAgICAvLyBpZiBub3QsIHdlIHdvdWxkIHdyb25nbHkgbWVyZ2Ugb25lT2YsIGlmLXRoZW4gc3RhdGVtZW50cywgZXRjXG4gICAgICAgICAgICBpZiAoaXNEeW5hbWljU2NoZW1hKHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSBvZiByZWR1Y2VTY2hlbWFcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlRHluYW1pY1NjaGVtYShub2RlLm5leHQocyksIGRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIG5vdGU6IHJlc3VsdCBoYXMgbm8gc2NvcGVcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgaXNKc29uRXJyb3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFNjaGVtYSA9IG1lcmdlU2NoZW1hKHMsIHJlc3VsdC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbWl0KGZpbmFsU2NoZW1hLCAuLi50b09taXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYWxsT2ZTY2hlbWEgPSBtZXJnZUFsbE9mU2NoZW1hKGRyYWZ0LCB7IGFsbE9mIH0pO1xuICAgICAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXNvbHZlZFNjaGVtYSAhPT0gdm9pZCAwID8gcmVzb2x2ZWRTY2hlbWEgOiB7fSwgYWxsT2ZTY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBmZWF0dXJlIGFueU9mXG4gICAgY29uc3QgYW55Tm9kZSA9IG1lcmdlVmFsaWRBbnlPZlNjaGVtYShub2RlLCBkYXRhKTtcbiAgICBpZiAoYW55Tm9kZSAmJiBhbnlOb2RlLnNjaGVtYSkge1xuICAgICAgICByZXNvbHZlZFNjaGVtYSA9IG1lcmdlU2NoZW1hKHJlc29sdmVkU2NoZW1hICE9PSBudWxsICYmIHJlc29sdmVkU2NoZW1hICE9PSB2b2lkIDAgPyByZXNvbHZlZFNjaGVtYSA6IHt9LCBhbnlOb2RlLnNjaGVtYSk7XG4gICAgfVxuICAgIC8vIEBmZWF0dXJlIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IGRlcGVuZGVuY2llc1NjaGVtYSA9IHJlc29sdmVEZXBlbmRlbmNpZXMobm9kZSwgZGF0YSk7XG4gICAgaWYgKGRlcGVuZGVuY2llc1NjaGVtYSkge1xuICAgICAgICByZXNvbHZlZFNjaGVtYSA9IG1lcmdlU2NoZW1hKHJlc29sdmVkU2NoZW1hICE9PSBudWxsICYmIHJlc29sdmVkU2NoZW1hICE9PSB2b2lkIDAgPyByZXNvbHZlZFNjaGVtYSA6IHt9LCBkZXBlbmRlbmNpZXNTY2hlbWEpO1xuICAgIH1cbiAgICAvLyBAZmVhdHVyZSBpZi10aGVuLWVsc2VcbiAgICBjb25zdCBpZk5vZGVSZXNvbHZlZCA9IHJlc29sdmVJZlNjaGVtYShub2RlLCBkYXRhKTtcbiAgICBpZiAoaXNTY2hlbWFOb2RlKGlmTm9kZVJlc29sdmVkKSkge1xuICAgICAgICByZXNvbHZlZFNjaGVtYSA9IG1lcmdlU2NoZW1hKHJlc29sdmVkU2NoZW1hICE9PSBudWxsICYmIHJlc29sdmVkU2NoZW1hICE9PSB2b2lkIDAgPyByZXNvbHZlZFNjaGVtYSA6IHt9LCBpZk5vZGVSZXNvbHZlZC5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWRTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGlmIChpc0pzb25FcnJvcihyZXNvbHZlZFNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xuICAgIH1cbiAgICBjb25zdCBuZXN0ZWRTY2hlbWEgPSByZXNvbHZlRHluYW1pY1NjaGVtYShub2RlLm5leHQocmVzb2x2ZWRTY2hlbWEpLCBkYXRhKTtcbiAgICBpZiAoaXNTY2hlbWFOb2RlKG5lc3RlZFNjaGVtYSkpIHtcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZVNjaGVtYShyZXNvbHZlZFNjaGVtYSwgbmVzdGVkU2NoZW1hLnNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsU2NoZW1hID0gb21pdChyZXNvbHZlZFNjaGVtYSwgLi4udG9PbWl0KTtcbiAgICByZXR1cm4gbm9kZS5uZXh0KGZpbmFsU2NoZW1hKTtcbn1cbiIsImltcG9ydCB7IGlzU2NoZW1hTm9kZSB9IGZyb20gXCIuL3NjaGVtYU5vZGVcIjtcbmltcG9ydCB7IHJlc29sdmVEeW5hbWljU2NoZW1hIH0gZnJvbSBcIi4vcmVzb2x2ZUR5bmFtaWNTY2hlbWFcIjtcbmNvbnN0IHRvT21pdCA9IFtcImFsbE9mXCIsIFwiYW55T2ZcIiwgXCJvbmVPZlwiLCBcImRlcGVuZGVuY2llc1wiLCBcImlmXCIsIFwidGhlblwiLCBcImVsc2VcIl07XG4vKipcbiAqIHJlZHVjZXMganNvbiBzY2hlbWEgYnkgbWVyZ2luZyBkeW5hbWljIGNvbnN0cnVjdHMgbGlrZSBpZi10aGVuLWVsc2UsXG4gKiBkZXBlbmRlbmNpZXMsIGFsbE9mLCBhbnlPZiwgb25lT2YsIGV0YyBpbnRvIGEgc3RhdGljIGpzb24gc2NoZW1hXG4gKiBvbWl0dGluZyB0aG9zZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEByZXR1cm5zIGlucHV0IHNjaGVtYSByZWR1Y2VkIGJ5IGR5bmFtaWMgc2NoZW1hIGRlZmluaXRpb25zIGZvciB0aGUgZ2l2ZW5cbiAqIGlucHV0IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVNjaGVtYShub2RlLCBkYXRhKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlRHluYW1pY1NjaGVtYShub2RlLCBkYXRhKTtcbiAgICBpZiAoaXNTY2hlbWFOb2RlKHJlc29sdmVkU2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gbm9kZS5tZXJnZShyZXNvbHZlZFNjaGVtYS5zY2hlbWEsIC4uLnRvT21pdCk7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7IC8vIGVycm9yXG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuIiwidmFyIHRvU3RyaW5nRnVuY3Rpb24gPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciB0b1N0cmluZ09iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vKipcbiAqIEBjbGFzc2Rlc2MgRmFsbGJhY2sgY2FjaGUgZm9yIHdoZW4gV2Vha01hcCBpcyBub3QgbmF0aXZlbHkgc3VwcG9ydGVkXG4gKi9cbnZhciBMZWdhY3lDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZWdhY3lDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgTGVnYWN5Q2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgIH07XG4gICAgTGVnYWN5Q2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1t0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KV07XG4gICAgfTtcbiAgICBMZWdhY3lDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBMZWdhY3lDYWNoZTtcbn0oKSk7XG5mdW5jdGlvbiBjcmVhdGVDYWNoZUxlZ2FjeSgpIHtcbiAgICByZXR1cm4gbmV3IExlZ2FjeUNhY2hlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZU1vZGVybigpIHtcbiAgICByZXR1cm4gbmV3IFdlYWtNYXAoKTtcbn1cbi8qKlxuICogR2V0IGEgbmV3IGNhY2hlIG9iamVjdCB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBjcmVhdGVDYWNoZSA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IGNyZWF0ZUNhY2hlTW9kZXJuIDogY3JlYXRlQ2FjaGVMZWdhY3k7XG4vKipcbiAqIEdldCBhbiBlbXB0eSB2ZXJzaW9uIG9mIHRoZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm90b3R5cGUgaXQgaGFzLlxuICovXG5mdW5jdGlvbiBnZXRDbGVhbkNsb25lKHByb3RvdHlwZSkge1xuICAgIGlmICghcHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIHZhciBDb25zdHJ1Y3RvciA9IHByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoQ29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBjcmVhdGUocHJvdG90eXBlKTtcbiAgICB9XG4gICAgaWYgKENvbnN0cnVjdG9yICYmXG4gICAgICAgIH50b1N0cmluZ0Z1bmN0aW9uLmNhbGwoQ29uc3RydWN0b3IpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGUocHJvdG90eXBlKTtcbn1cbmZ1bmN0aW9uIGdldFJlZ0V4cEZsYWdzTGVnYWN5KHJlZ0V4cCkge1xuICAgIHZhciBmbGFncyA9ICcnO1xuICAgIGlmIChyZWdFeHAuZ2xvYmFsKSB7XG4gICAgICAgIGZsYWdzICs9ICdnJztcbiAgICB9XG4gICAgaWYgKHJlZ0V4cC5pZ25vcmVDYXNlKSB7XG4gICAgICAgIGZsYWdzICs9ICdpJztcbiAgICB9XG4gICAgaWYgKHJlZ0V4cC5tdWx0aWxpbmUpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ20nO1xuICAgIH1cbiAgICBpZiAocmVnRXhwLnVuaWNvZGUpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgIH1cbiAgICBpZiAocmVnRXhwLnN0aWNreSkge1xuICAgICAgICBmbGFncyArPSAneSc7XG4gICAgfVxuICAgIHJldHVybiBmbGFncztcbn1cbmZ1bmN0aW9uIGdldFJlZ0V4cEZsYWdzTW9kZXJuKHJlZ0V4cCkge1xuICAgIHJldHVybiByZWdFeHAuZmxhZ3M7XG59XG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgdG8gYXBwbHkgdG8gdGhlIGNvcGllZCByZWdleHAuXG4gKi9cbnZhciBnZXRSZWdFeHBGbGFncyA9IC90ZXN0L2cuZmxhZ3MgPT09ICdnJyA/IGdldFJlZ0V4cEZsYWdzTW9kZXJuIDogZ2V0UmVnRXhwRmxhZ3NMZWdhY3k7XG5mdW5jdGlvbiBnZXRUYWdMZWdhY3kodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHRvU3RyaW5nT2JqZWN0LmNhbGwodmFsdWUpO1xuICAgIHJldHVybiB0eXBlLnN1YnN0cmluZyg4LCB0eXBlLmxlbmd0aCAtIDEpO1xufVxuZnVuY3Rpb24gZ2V0VGFnTW9kZXJuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgZ2V0VGFnTGVnYWN5KHZhbHVlKTtcbn1cbi8qKlxuICogR2V0IHRoZSB0YWcgb2YgdGhlIHZhbHVlIHBhc3NlZCwgc28gdGhhdCB0aGUgY29ycmVjdCBjb3BpZXIgY2FuIGJlIHVzZWQuXG4gKi9cbnZhciBnZXRUYWcgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IGdldFRhZ01vZGVybiA6IGdldFRhZ0xlZ2FjeTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX2EgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd25Qcm9wZXJ0eSA9IF9hLmhhc093blByb3BlcnR5LCBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IF9hLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFNVUFBPUlRTX1NZTUJPTCA9IHR5cGVvZiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBnZXRTdHJpY3RQcm9wZXJ0aWVzTW9kZXJuKG9iamVjdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKTtcbn1cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJpdGVzIHVzZWQgd2hlbiBjb3B5aW5nIG9iamVjdHMgc3RyaWN0bHkuIFRoaXMgaW5jbHVkZXMgYm90aCBrZXlzIGFuZCBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3RyaWN0UHJvcGVydGllcyA9IFNVUFBPUlRTX1NZTUJPTFxuICAgID8gZ2V0U3RyaWN0UHJvcGVydGllc01vZGVyblxuICAgIDogZ2V0T3duUHJvcGVydHlOYW1lcztcbi8qKlxuICogU3RyaWNsdHkgY29weSBhbGwgcHJvcGVydGllcyBjb250YWluZWQgb24gdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY29weU93blByb3BlcnRpZXNTdHJpY3QodmFsdWUsIGNsb25lLCBzdGF0ZSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gZ2V0U3RyaWN0UHJvcGVydGllcyh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGhfMSA9IHByb3BlcnRpZXMubGVuZ3RoLCBwcm9wZXJ0eSA9IHZvaWQgMCwgZGVzY3JpcHRvciA9IHZvaWQgMDsgaW5kZXggPCBsZW5ndGhfMTsgKytpbmRleCkge1xuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaW5kZXhdO1xuICAgICAgICBpZiAocHJvcGVydHkgPT09ICdjYWxsZWUnIHx8IHByb3BlcnR5ID09PSAnY2FsbGVyJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIC8vIEluIGV4dHJhIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgY2Fubm90IGJlIHJldHJpdmVkLCBmYWxsIGJhY2sgdG9cbiAgICAgICAgICAgIC8vIHRoZSBsb29zZSBhc3NpZ25tZW50LlxuICAgICAgICAgICAgY2xvbmVbcHJvcGVydHldID0gc3RhdGUuY29waWVyKHZhbHVlW3Byb3BlcnR5XSwgc3RhdGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBjbG9uZSB0aGUgdmFsdWUgaWYgYWN0dWFsbHkgYSB2YWx1ZSwgbm90IGEgZ2V0dGVyIC8gc2V0dGVyLlxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZ2V0ICYmICFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHN0YXRlLmNvcGllcihkZXNjcmlwdG9yLnZhbHVlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KGNsb25lLCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUZWUgYWJvdmUgY2FuIGZhaWwgb24gbm9kZSBpbiBlZGdlIGNhc2VzLCBzbyBmYWxsIGJhY2sgdG8gdGhlIGxvb3NlIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICBjbG9uZVtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogRGVlcGx5IGNvcHkgdGhlIGluZGV4ZWQgdmFsdWVzIGluIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5TG9vc2UoYXJyYXksIHN0YXRlKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoYXJyYXksIGNsb25lKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aF8yID0gYXJyYXkubGVuZ3RoOyBpbmRleCA8IGxlbmd0aF8yOyArK2luZGV4KSB7XG4gICAgICAgIGNsb25lW2luZGV4XSA9IHN0YXRlLmNvcGllcihhcnJheVtpbmRleF0sIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgaW5kZXhlZCB2YWx1ZXMgaW4gdGhlIGFycmF5LCBhcyB3ZWxsIGFzIGFueSBjdXN0b20gcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5U3RyaWN0KGFycmF5LCBzdGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcigpO1xuICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAgc3RhdGUuY2FjaGUuc2V0KGFycmF5LCBjbG9uZSk7XG4gICAgcmV0dXJuIGNvcHlPd25Qcm9wZXJ0aWVzU3RyaWN0KGFycmF5LCBjbG9uZSwgc3RhdGUpO1xufVxuLyoqXG4gKiBDb3B5IHRoZSBjb250ZW50cyBvZiB0aGUgQXJyYXlCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgX3N0YXRlKSB7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyLnNsaWNlKDApO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQmxvYiB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlCbG9iKGJsb2IsIF9zdGF0ZSkge1xuICAgIHJldHVybiBibG9iLnNsaWNlKDAsIGJsb2Iuc2l6ZSwgYmxvYi50eXBlKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IERhdGFWaWV3IHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weURhdGFWaWV3KGRhdGFWaWV3LCBzdGF0ZSkge1xuICAgIHJldHVybiBuZXcgc3RhdGUuQ29uc3RydWN0b3IoY29weUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRGF0ZSBiYXNlZCBvbiB0aGUgdGltZSBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlEYXRlKGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcihkYXRlLmdldFRpbWUoKSk7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5TWFwTG9vc2UobWFwLCBzdGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcigpO1xuICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAgc3RhdGUuY2FjaGUuc2V0KG1hcCwgY2xvbmUpO1xuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGNsb25lLnNldChrZXksIHN0YXRlLmNvcGllcih2YWx1ZSwgc3RhdGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIG9yaWdpbmFsLCBhcyB3ZWxsIGFzIGFueSBjdXN0b20gcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29weU1hcFN0cmljdChtYXAsIHN0YXRlKSB7XG4gICAgcmV0dXJuIGNvcHlPd25Qcm9wZXJ0aWVzU3RyaWN0KG1hcCwgY29weU1hcExvb3NlKG1hcCwgc3RhdGUpLCBzdGF0ZSk7XG59XG5mdW5jdGlvbiBjb3B5T2JqZWN0TG9vc2VMZWdhY3kob2JqZWN0LCBzdGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IGdldENsZWFuQ2xvbmUoc3RhdGUucHJvdG90eXBlKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChvYmplY3QsIGNsb25lKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHN0YXRlLmNvcGllcihvYmplY3Rba2V5XSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIGNvcHlPYmplY3RMb29zZU1vZGVybihvYmplY3QsIHN0YXRlKSB7XG4gICAgdmFyIGNsb25lID0gZ2V0Q2xlYW5DbG9uZShzdGF0ZS5wcm90b3R5cGUpO1xuICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAgc3RhdGUuY2FjaGUuc2V0KG9iamVjdCwgY2xvbmUpO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBjbG9uZVtrZXldID0gc3RhdGUuY29waWVyKG9iamVjdFtrZXldLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aF8zID0gc3ltYm9scy5sZW5ndGgsIHN5bWJvbCA9IHZvaWQgMDsgaW5kZXggPCBsZW5ndGhfMzsgKytpbmRleCkge1xuICAgICAgICBzeW1ib2wgPSBzeW1ib2xzW2luZGV4XTtcbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpKSB7XG4gICAgICAgICAgICBjbG9uZVtzeW1ib2xdID0gc3RhdGUuY29waWVyKG9iamVjdFtzeW1ib2xdLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgcHJvcGVydGllcyAoa2V5cyBhbmQgc3ltYm9scykgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbnZhciBjb3B5T2JqZWN0TG9vc2UgPSBTVVBQT1JUU19TWU1CT0xcbiAgICA/IGNvcHlPYmplY3RMb29zZU1vZGVyblxuICAgIDogY29weU9iamVjdExvb3NlTGVnYWN5O1xuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgcHJvcGVydGllcyAoa2V5cyBhbmQgc3ltYm9scykgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwsIGFzIHdlbGxcbiAqIGFzIGFueSBoaWRkZW4gb3Igbm9uLWVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdFN0cmljdChvYmplY3QsIHN0YXRlKSB7XG4gICAgdmFyIGNsb25lID0gZ2V0Q2xlYW5DbG9uZShzdGF0ZS5wcm90b3R5cGUpO1xuICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAgc3RhdGUuY2FjaGUuc2V0KG9iamVjdCwgY2xvbmUpO1xuICAgIHJldHVybiBjb3B5T3duUHJvcGVydGllc1N0cmljdChvYmplY3QsIGNsb25lLCBzdGF0ZSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwcmltaXRpdmUgd3JhcHBlciBmcm9tIHRoZSB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlQcmltaXRpdmVXcmFwcGVyKHByaW1pdGl2ZU9iamVjdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKHByaW1pdGl2ZU9iamVjdC52YWx1ZU9mKCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgUmVnRXhwIGJhc2VkIG9uIHRoZSB2YWx1ZSBhbmQgZmxhZ3Mgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5UmVnRXhwKHJlZ0V4cCwgc3RhdGUpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IocmVnRXhwLnNvdXJjZSwgZ2V0UmVnRXhwRmxhZ3MocmVnRXhwKSk7XG4gICAgY2xvbmUubGFzdEluZGV4ID0gcmVnRXhwLmxhc3RJbmRleDtcbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIFJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUgKGFuIGlkZW50aXR5IGZ1bmN0aW9uKS5cbiAqXG4gKiBAbm90ZVxuICogVEhpcyBpcyB1c2VkIGZvciBvYmplY3RzIHRoYXQgY2Fubm90IGJlIGNvcGllZCwgc3VjaCBhcyBXZWFrTWFwLlxuICovXG5mdW5jdGlvbiBjb3B5U2VsZih2YWx1ZSwgX3N0YXRlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weVNldExvb3NlKHNldCwgc3RhdGUpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IoKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChzZXQsIGNsb25lKTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xvbmUuYWRkKHN0YXRlLmNvcGllcih2YWx1ZSwgc3RhdGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSB2YWx1ZXMgb2YgdGhlIG9yaWdpbmFsLCBhcyB3ZWxsIGFzIGFueSBjdXN0b20gcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29weVNldFN0cmljdChzZXQsIHN0YXRlKSB7XG4gICAgcmV0dXJuIGNvcHlPd25Qcm9wZXJ0aWVzU3RyaWN0KHNldCwgY29weVNldExvb3NlKHNldCwgc3RhdGUpLCBzdGF0ZSk7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmouX19wcm90b19fOyB9KTtcbnZhciBERUZBVUxUX0xPT1NFX09QVElPTlMgPSB7XG4gICAgYXJyYXk6IGNvcHlBcnJheUxvb3NlLFxuICAgIGFycmF5QnVmZmVyOiBjb3B5QXJyYXlCdWZmZXIsXG4gICAgYmxvYjogY29weUJsb2IsXG4gICAgZGF0YVZpZXc6IGNvcHlEYXRhVmlldyxcbiAgICBkYXRlOiBjb3B5RGF0ZSxcbiAgICBlcnJvcjogY29weVNlbGYsXG4gICAgbWFwOiBjb3B5TWFwTG9vc2UsXG4gICAgb2JqZWN0OiBjb3B5T2JqZWN0TG9vc2UsXG4gICAgcmVnRXhwOiBjb3B5UmVnRXhwLFxuICAgIHNldDogY29weVNldExvb3NlLFxufTtcbnZhciBERUZBVUxUX1NUUklDVF9PUFRJT05TID0gYXNzaWduKHt9LCBERUZBVUxUX0xPT1NFX09QVElPTlMsIHtcbiAgICBhcnJheTogY29weUFycmF5U3RyaWN0LFxuICAgIG1hcDogY29weU1hcFN0cmljdCxcbiAgICBvYmplY3Q6IGNvcHlPYmplY3RTdHJpY3QsXG4gICAgc2V0OiBjb3B5U2V0U3RyaWN0LFxufSk7XG4vKipcbiAqIEdldCB0aGUgY29waWVycyB1c2VkIGZvciBlYWNoIHNwZWNpZmljIG9iamVjdCB0YWcuXG4gKi9cbmZ1bmN0aW9uIGdldFRhZ1NwZWNpZmljQ29waWVycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQXJndW1lbnRzOiBvcHRpb25zLm9iamVjdCxcbiAgICAgICAgQXJyYXk6IG9wdGlvbnMuYXJyYXksXG4gICAgICAgIEFycmF5QnVmZmVyOiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBCbG9iOiBvcHRpb25zLmJsb2IsXG4gICAgICAgIEJvb2xlYW46IGNvcHlQcmltaXRpdmVXcmFwcGVyLFxuICAgICAgICBEYXRhVmlldzogb3B0aW9ucy5kYXRhVmlldyxcbiAgICAgICAgRGF0ZTogb3B0aW9ucy5kYXRlLFxuICAgICAgICBFcnJvcjogb3B0aW9ucy5lcnJvcixcbiAgICAgICAgRmxvYXQzMkFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBGbG9hdDY0QXJyYXk6IG9wdGlvbnMuYXJyYXlCdWZmZXIsXG4gICAgICAgIEludDhBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgSW50MTZBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgSW50MzJBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgTWFwOiBvcHRpb25zLm1hcCxcbiAgICAgICAgTnVtYmVyOiBjb3B5UHJpbWl0aXZlV3JhcHBlcixcbiAgICAgICAgT2JqZWN0OiBvcHRpb25zLm9iamVjdCxcbiAgICAgICAgUHJvbWlzZTogY29weVNlbGYsXG4gICAgICAgIFJlZ0V4cDogb3B0aW9ucy5yZWdFeHAsXG4gICAgICAgIFNldDogb3B0aW9ucy5zZXQsXG4gICAgICAgIFN0cmluZzogY29weVByaW1pdGl2ZVdyYXBwZXIsXG4gICAgICAgIFdlYWtNYXA6IGNvcHlTZWxmLFxuICAgICAgICBXZWFrU2V0OiBjb3B5U2VsZixcbiAgICAgICAgVWludDhBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgVWludDhDbGFtcGVkQXJyYXk6IG9wdGlvbnMuYXJyYXlCdWZmZXIsXG4gICAgICAgIFVpbnQxNkFycmF5OiBvcHRpb25zLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50MzJBcnJheTogb3B0aW9ucy5hcnJheUJ1ZmZlcixcbiAgICAgICAgVWludDY0QXJyYXk6IG9wdGlvbnMuYXJyYXlCdWZmZXIsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY3VzdG9tIGNvcGllciBiYXNlZCBvbiB0aGUgb2JqZWN0LXNwZWNpZmljIGNvcHkgbWV0aG9kcyBwYXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvcGllcihvcHRpb25zKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRPcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUX0xPT1NFX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciB0YWdTcGVjaWZpY0NvcGllcnMgPSBnZXRUYWdTcGVjaWZpY0NvcGllcnMobm9ybWFsaXplZE9wdGlvbnMpO1xuICAgIHZhciBhcnJheSA9IHRhZ1NwZWNpZmljQ29waWVycy5BcnJheSwgb2JqZWN0ID0gdGFnU3BlY2lmaWNDb3BpZXJzLk9iamVjdDtcbiAgICBmdW5jdGlvbiBjb3BpZXIodmFsdWUsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnByb3RvdHlwZSA9IHN0YXRlLkNvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmNhY2hlLmdldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICBzdGF0ZS5Db25zdHJ1Y3RvciA9IHN0YXRlLnByb3RvdHlwZSAmJiBzdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIHBsYWluIG9iamVjdHNcbiAgICAgICAgaWYgKCFzdGF0ZS5Db25zdHJ1Y3RvciB8fCBzdGF0ZS5Db25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJyYXlzXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZ1NwZWNpZmljQ29waWVyID0gdGFnU3BlY2lmaWNDb3BpZXJzW2dldFRhZyh2YWx1ZSldO1xuICAgICAgICBpZiAodGFnU3BlY2lmaWNDb3BpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWdTcGVjaWZpY0NvcGllcih2YWx1ZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogb2JqZWN0KHZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb3BpZXIodmFsdWUsIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYWNoZTogY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICAgIGNvcGllcjogY29waWVyLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBjb3BpZXIgYmFzZWQgb24gdGhlIG9iamVjdC1zcGVjaWZpYyBjb3B5IG1ldGhvZHMgcGFzc2VkLCBkZWZhdWx0aW5nIHRvIHRoZVxuICogc2FtZSBpbnRlcm5hbHMgYXMgYGNvcHlTdHJpY3RgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJpY3RDb3BpZXIob3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVDb3BpZXIoYXNzaWduKHt9LCBERUZBVUxUX1NUUklDVF9PUFRJT05TLCBvcHRpb25zKSk7XG59XG4vKipcbiAqIENvcHkgYW4gdmFsdWUgZGVlcGx5IGFzIG11Y2ggYXMgcG9zc2libGUsIHdoZXJlIHN0cmljdCByZWNyZWF0aW9uIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWFpbnRhaW5lZC4gQWxsIHByb3BlcnRpZXMgKGluY2x1ZGluZyBub24tZW51bWVyYWJsZSBvbmVzKSBhcmUgY29waWVkIHdpdGggdGhlaXJcbiAqIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3JzIG9uIGJvdGggb2JqZWN0cyBhbmQgYXJyYXlzLlxuICovXG52YXIgY29weVN0cmljdCA9IGNyZWF0ZVN0cmljdENvcGllcih7fSk7XG4vKipcbiAqIENvcHkgYW4gdmFsdWUgZGVlcGx5IGFzIG11Y2ggYXMgcG9zc2libGUuXG4gKi9cbnZhciBpbmRleCA9IGNyZWF0ZUNvcGllcih7fSk7XG5cbmV4cG9ydCB7IGNvcHlTdHJpY3QsIGNyZWF0ZUNvcGllciwgY3JlYXRlU3RyaWN0Q29waWVyLCBpbmRleCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgY29weSBmcm9tIFwiZmFzdC1jb3B5XCI7XG5leHBvcnQgZGVmYXVsdCBjb3B5O1xuIiwiaW1wb3J0IGNvcHkgZnJvbSBcIi4uL3V0aWxzL2NvcHlcIjtcbmltcG9ydCB7IGlzSnNvbkVycm9yIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBpc1NjaGVtYU5vZGUgfSBmcm9tIFwiLi4vc2NoZW1hTm9kZVwiO1xuZXhwb3J0IGNsYXNzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNjaGVtYSkge1xuICAgICAgICAvKiogY2FjaGUgZm9yIHJlbW90ZSBzY2hlbWFzICovXG4gICAgICAgIHRoaXMucmVtb3RlcyA9IHt9O1xuICAgICAgICAvKiogZXJyb3IgY3JlYXRvcnMgYnkgaWQgKi9cbiAgICAgICAgdGhpcy5lcnJvcnMgPSB7fTtcbiAgICAgICAgLyoqIG1hcCBmb3IgdmFsaWQga2V5d29yZHMgb2YgYSB0eXBlICAqL1xuICAgICAgICB0aGlzLnR5cGVLZXl3b3JkcyA9IHt9O1xuICAgICAgICAvKioga2V5d29yZCB2YWxpZGF0b3JzICAqL1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5d29yZCA9IHt9O1xuICAgICAgICAvKiogdHlwZSB2YWxpZGF0b3JzICAqL1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZSA9IHt9O1xuICAgICAgICAvKiogZm9ybWF0IHZhbGlkYXRvcnMgICovXG4gICAgICAgIHRoaXMudmFsaWRhdGVGb3JtYXQgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudHlwZUtleXdvcmRzID0gY29weShjb25maWcudHlwZUtleXdvcmRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUtleXdvcmQgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcudmFsaWRhdGVLZXl3b3JkKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcudmFsaWRhdGVUeXBlKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm1hdCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy52YWxpZGF0ZUZvcm1hdCk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLmVycm9ycyk7XG4gICAgICAgIHRoaXMuc2V0U2NoZW1hKHNjaGVtYSk7XG4gICAgfVxuICAgIGdldCByb290U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3Jvb3RTY2hlbWE7XG4gICAgfVxuICAgIHNldCByb290U2NoZW1hKHJvb3RTY2hlbWEpIHtcbiAgICAgICAgaWYgKHJvb3RTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19yb290U2NoZW1hID0gdGhpcy5jb25maWcuY29tcGlsZVNjaGVtYSh0aGlzLCByb290U2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgYSBqc29uLXNjaGVtYSB0byBiZSByZWZlcmVuY2VkIGZyb20gYW5vdGhlciBqc29uLXNjaGVtYVxuICAgICAqIEBwYXJhbSB1cmwgLSBiYXNlLXVybCBvZiBqc29uLXNjaGVtYSAoYWthIGlkKVxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBqc29uLXNjaGVtYSByb290XG4gICAgICovXG4gICAgYWRkUmVtb3RlU2NoZW1hKHVybCwgc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFkZFJlbW90ZVNjaGVtYSh0aGlzLCB1cmwsIHNjaGVtYSk7XG4gICAgfVxuICAgIGNvbXBpbGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvbXBpbGVTY2hlbWEodGhpcywgc2NoZW1hLCAoX2EgPSB0aGlzLnJvb3RTY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNjaGVtYSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjaGVtYU9mKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNyZWF0ZVNjaGVtYU9mKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGRhdGEsIHJldHJpZXZpbmcgaXRzIHNjaGVtYVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSB0aGUgZGF0YSB0byBpdGVyYXRlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gd2lsbCBiZSBjYWxsZWQgd2l0aCAoc2NoZW1hLCBkYXRhLCBwb2ludGVyKSBvbiBlYWNoIGl0ZW1cbiAgICAgKiBAcGFyYW0gW3NjaGVtYV0gLSB0aGUgc2NoZW1hIG1hdGNoaW5nIHRoZSBkYXRhLiBEZWZhdWx0cyB0byByb290U2NoZW1hXG4gICAgICogQHBhcmFtIFtwb2ludGVyXSAtIHBvaW50ZXIgdG8gY3VycmVudCBkYXRhLiBEZWZhdWx0IHRvIHJvb3RQb2ludGVyXG4gICAgICovXG4gICAgZWFjaChkYXRhLCBjYWxsYmFjaywgc2NoZW1hLCBwb2ludGVyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoc2NoZW1hICE9PSBudWxsICYmIHNjaGVtYSAhPT0gdm9pZCAwID8gc2NoZW1hIDogdGhpcy5yb290U2NoZW1hLCBwb2ludGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmVhY2gobm9kZSwgZGF0YSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlYWNoU2NoZW1hKGNhbGxiYWNrLCBzY2hlbWEgPSB0aGlzLnJvb3RTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmVhY2hTY2hlbWEoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldENoaWxkU2NoZW1hU2VsZWN0aW9uKHByb3BlcnR5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmdldENoaWxkU2NoZW1hU2VsZWN0aW9uKHRoaXMsIHByb3BlcnR5LCBzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqc29uLXNjaGVtYSBvZiBhIGRhdGEtanNvbi1wb2ludGVyLlxuICAgICAqXG4gICAgICogVG8gcmVzb2x2ZSBkeW5hbWljIHNjaGVtYSB3aGVyZSB0aGUgdHlwZSBvZiBqc29uLXNjaGVtYSBpcyBldmFsdWF0ZWQgYnlcbiAgICAgKiBpdHMgdmFsdWUsIGEgZGF0YSBvYmplY3QgaGFzIHRvIGJlIHBhc3NlZCBpbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogUGVyIGRlZmF1bHQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgdmFsaWQgcHJvcGVydGllcyB0aGF0XG4gICAgICogZG8gbm90IGhhdmUgYSBkZWZpbmVkIHNjaGVtYS4gVXNlIHRoZSBvcHRpb24gYHdpdGhTY2hlbWFXYXJuaW5nOiB0cnVlYCB0b1xuICAgICAqIHJlY2VpdmUgYW4gZXJyb3Igd2l0aCBgY29kZTogc2NoZW1hLXdhcm5pbmdgIGNvbnRhaW5pbmcgdGhlIGxvY2F0aW9uIG9mIGl0c1xuICAgICAqIGxhc3QgZXZhbHVhdGVkIGpzb24tc2NoZW1hLlxuICAgICAqXG4gICAgICogTm90ZXNcbiAgICAgKiAgICAgIC0gdXNlcyBkcmFmdC5zdGVwIHRvIHdhbGsgdGhyb3VnaCBkYXRhIGFuZCBzY2hlbWFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFmdFxuICAgICAqIEBwYXJhbSBwb2ludGVyIC0ganNvbiBwb2ludGVyIGluIGRhdGEgdG8gZ2V0IHRoZSBqc29uIHNjaGVtYSBmb3JcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMuZGF0YV0gLSB0aGUgZGF0YSBvYmplY3QsIHdoaWNoIGluY2x1ZGVzIHRoZSBqc29uIHBvaW50ZXJzIHZhbHVlLiBUaGlzIGlzIG9wdGlvbmFsLCBhc1xuICAgICAqICAgIGxvbmcgYXMgbm8gb25lT2YsIGFueU9mLCBldGMgc3RhdGVtZW50IGlzIHBhcnQgb2YgdGhlIHBvaW50ZXJzIHNjaGVtYVxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5zY2hlbWFdIC0gdGhlIGpzb24gc2NoZW1hIHRvIGl0ZXJhdGUuIERlZmF1bHRzIHRvIGRyYWZ0LnJvb3RTY2hlbWFcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMud2l0aFNjaGVtYVdhcm5pbmddIC0gaWYgdHJ1ZSByZXR1cm5zIGFuIGVycm9yIGluc3RlYWQgb2YgYHVuZGVmaW5lZGAgZm9yIHZhbGlkIHByb3BlcnRpZXMgbWlzc2luZyBhIHNjaGVtYSBkZWZpbml0aW9uXG4gICAgICogQHJldHVybiByZXNvbHZlZCBqc29uLXNjaGVtYSBvYmplY3Qgb2YgcmVxdWVzdGVkIGpzb24tcG9pbnRlciBsb2NhdGlvblxuICAgICAqL1xuICAgIGdldFNjaGVtYShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0U2NoZW1hTm9kZShvcHRpb25zKTtcbiAgICAgICAgaWYgKGlzU2NoZW1hTm9kZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRTY2hlbWFOb2RlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmdldFNjaGVtYSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRhdGEgb2JqZWN0IG1hdGNoaW5nIHRoZSBnaXZlbiBzY2hlbWFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbZGF0YV0gLSBvcHRpb25hbCB0ZW1wbGF0ZSBkYXRhXG4gICAgICogQHBhcmFtIFtzY2hlbWFdIC0ganNvbiBzY2hlbWEsIGRlZmF1bHRzIHRvIHJvb3RTY2hlbWFcbiAgICAgKiBAcmV0dXJuIGNyZWF0ZWQgdGVtcGxhdGUgZGF0YVxuICAgICAqL1xuICAgIGdldFRlbXBsYXRlKGRhdGEsIHNjaGVtYSwgb3B0cyA9IHRoaXMuY29uZmlnLnRlbXBsYXRlRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmdldFRlbXBsYXRlKHRoaXMsIGRhdGEsIHNjaGVtYSwgb3B0cyk7XG4gICAgfVxuICAgIGlzVmFsaWQoZGF0YSwgc2NoZW1hLCBwb2ludGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5pc1ZhbGlkKHRoaXMsIGRhdGEsIHNjaGVtYSwgcG9pbnRlcik7XG4gICAgfVxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBwb2ludGVyID0gXCIjXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNyZWF0ZU5vZGUodGhpcywgc2NoZW1hLCBwb2ludGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZUFueU9mKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnJlc29sdmVBbnlPZihub2RlLCBkYXRhKTtcbiAgICB9XG4gICAgcmVzb2x2ZUFsbE9mKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnJlc29sdmVBbGxPZihub2RlLCBkYXRhKTtcbiAgICB9XG4gICAgcmVzb2x2ZVJlZihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5yZXNvbHZlUmVmKG5vZGUpO1xuICAgIH1cbiAgICByZXNvbHZlT25lT2Yobm9kZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucmVzb2x2ZU9uZU9mKG5vZGUsIGRhdGEpO1xuICAgIH1cbiAgICBzZXRTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHRoaXMucm9vdFNjaGVtYSA9IHNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUganNvbi1zY2hlbWEgb2YgdGhlIGdpdmVuIG9iamVjdCBwcm9wZXJ0eSBvciBhcnJheSBpdGVtLlxuICAgICAqIGUuZy4gaXQgc3RlcHMgYnkgb25lIGtleSBpbnRvIHRoZSBkYXRhXG4gICAgICpcbiAgICAgKiBUaGlzIGhlbHBlciBkZXRlcm1pbmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgcHJvcGVydHkgd2l0aGluIHRoZSBzY2hlbWEgKGFkZGl0aW9uYWwgcHJvcGVydGllcywgb25lT2YsIC4uLikgYW5kXG4gICAgICogcmV0dXJucyB0aGUgY29ycmVjdCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIG5vZGVcbiAgICAgKiBAcGFyYW0gIGtleSAgICAgICAtIHByb3BlcnR5LW5hbWUgb3IgYXJyYXktaW5kZXhcbiAgICAgKiBAcGFyYW0gIGRhdGEgICAgICAtIHBhcmVudCBvZiBrZXlcbiAgICAgKiBAcmV0dXJuIHNjaGVtYS1ub2RlIGNvbnRhaW5pbmcgY2hpbGQgc2NoZW1hIG9yIGVycm9yIGlmIGZhaWxlZCByZXNvbHZpbmcga2V5XG4gICAgICovXG4gICAgc3RlcChub2RlLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnN0ZXAobm9kZSwga2V5LCBkYXRhKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoZGF0YSwgc2NoZW1hID0gdGhpcy5yb290U2NoZW1hLCBwb2ludGVyKSB7XG4gICAgICAgIGlmIChpc1NjaGVtYU5vZGUoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RGF0YSA9IHNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGludXB0Tm9kZSA9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcudmFsaWRhdGUoaW51cHROb2RlLCBpbnB1dERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0pzb25FcnJvcihkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtkYXRhXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jcmVhdGVOb2RlKHNjaGVtYSwgcG9pbnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy52YWxpZGF0ZShub2RlLCBkYXRhKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIHJlZ2lzdGVyIGEganNvbi1zY2hlbWEgdG8gYmUgcmVmZXJlbmNlZCBmcm9tIGFub3RoZXIganNvbi1zY2hlbWFcbiAqIEBwYXJhbSB1cmwgICAgYmFzZS11cmwgb2YganNvbi1zY2hlbWEgKGFrYSBpZClcbiAqIEBwYXJhbSBzY2hlbWFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkUmVtb3RlU2NoZW1hKGRyYWZ0LCB1cmwsIHNjaGVtYSkge1xuICAgIHNjaGVtYS5pZCA9IHNjaGVtYS5pZCB8fCB1cmw7XG4gICAgZHJhZnQucmVtb3Rlc1t1cmxdID0gZHJhZnQuY29tcGlsZVNjaGVtYShzY2hlbWEpO1xufVxuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tIFwiLi91dGlscy9pc09iamVjdFwiO1xuZnVuY3Rpb24gZWFjaFByb3BlcnR5KHByb3BlcnR5LCBzY2hlbWEsIGNhbGxiYWNrLCBwb2ludGVyKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2NoZW1hW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZGVwbmRlbmNpZXMgbGlzdCAob2YgcHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIiRkZWZzXCIpIHtcbiAgICAgICAgICAgIGVhY2hQcm9wZXJ0eShcIiRkZWZzXCIsIHRhcmdldFtrZXldLCBjYWxsYmFjaywgYCR7cG9pbnRlcn0vJHtwcm9wZXJ0eX0vJGRlZnNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVhY2hTY2hlbWEodGFyZ2V0W2tleV0sIGNhbGxiYWNrLCBgJHtwb2ludGVyfS8ke3Byb3BlcnR5fS8ke2tleX1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZWFjaEl0ZW0ocHJvcGVydHksIHNjaGVtYSwgY2FsbGJhY2ssIHBvaW50ZXIpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBzY2hlbWFbcHJvcGVydHldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGFyZ2V0LmZvckVhY2goKHMsIGtleSkgPT4gZWFjaFNjaGVtYShzLCBjYWxsYmFjaywgYCR7cG9pbnRlcn0vJHtwcm9wZXJ0eX0vJHtrZXl9YCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hTY2hlbWEoc2NoZW1hLCBjYWxsYmFjaywgcG9pbnRlciA9IFwiXCIpIHtcbiAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVudHlwZWRcbiAgICBpZiAoY2FsbGJhY2soc2NoZW1hLCBwb2ludGVyKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNPYmplY3Qoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVhY2hQcm9wZXJ0eShcInByb3BlcnRpZXNcIiwgc2NoZW1hLCBjYWxsYmFjaywgcG9pbnRlcik7XG4gICAgZWFjaFByb3BlcnR5KFwicGF0dGVyblByb3BlcnRpZXNcIiwgc2NoZW1hLCBjYWxsYmFjaywgcG9pbnRlcik7XG4gICAgZWFjaFNjaGVtYShzY2hlbWEubm90LCBjYWxsYmFjaywgYCR7cG9pbnRlcn0vbm90YCk7XG4gICAgZWFjaFNjaGVtYShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIGNhbGxiYWNrLCBgJHtwb2ludGVyfS9hZGRpdGlvbmFsUHJvcGVydGllc2ApO1xuICAgIGVhY2hQcm9wZXJ0eShcImRlcGVuZGVuY2llc1wiLCBzY2hlbWEsIGNhbGxiYWNrLCBwb2ludGVyKTtcbiAgICAvLyBpdGVtc1xuICAgIGlzT2JqZWN0KHNjaGVtYS5pdGVtcykgJiYgZWFjaFNjaGVtYShzY2hlbWEuaXRlbXMsIGNhbGxiYWNrLCBgJHtwb2ludGVyfS9pdGVtc2ApO1xuICAgIGVhY2hJdGVtKFwiaXRlbXNcIiwgc2NoZW1hLCBjYWxsYmFjaywgcG9pbnRlcik7XG4gICAgLy8gYWRkaXRpb25hbCBpdGVtc1xuICAgIGVhY2hTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywgY2FsbGJhY2ssIGAke3BvaW50ZXJ9L2FkZGl0aW9uYWxJdGVtc2ApO1xuICAgIC8vIGR5bmFtaWMgc2NoZW1hc1xuICAgIGVhY2hJdGVtKFwiYWxsT2ZcIiwgc2NoZW1hLCBjYWxsYmFjaywgcG9pbnRlcik7XG4gICAgZWFjaEl0ZW0oXCJhbnlPZlwiLCBzY2hlbWEsIGNhbGxiYWNrLCBwb2ludGVyKTtcbiAgICBlYWNoSXRlbShcIm9uZU9mXCIsIHNjaGVtYSwgY2FsbGJhY2ssIHBvaW50ZXIpO1xuICAgIGVhY2hTY2hlbWEoc2NoZW1hLmlmLCBjYWxsYmFjaywgYCR7cG9pbnRlcn0vaWZgKTtcbiAgICBlYWNoU2NoZW1hKHNjaGVtYS50aGVuLCBjYWxsYmFjaywgYCR7cG9pbnRlcn0vdGhlbmApO1xuICAgIGVhY2hTY2hlbWEoc2NoZW1hLmVsc2UsIGNhbGxiYWNrLCBgJHtwb2ludGVyfS9lbHNlYCk7XG4gICAgLy8gZGVmaW5pdGlvbnNcbiAgICBlYWNoUHJvcGVydHkoXCJkZWZpbml0aW9uc1wiLCBzY2hlbWEsIGNhbGxiYWNrLCBwb2ludGVyKTtcbiAgICBlYWNoUHJvcGVydHkoXCIkZGVmc1wiLCBzY2hlbWEsIGNhbGxiYWNrLCBwb2ludGVyKTtcbn1cbiIsIi8qIGVzbGludCBtYXgtc3RhdGVtZW50cy1wZXItbGluZTogW1wiZXJyb3JcIiwgeyBcIm1heFwiOiAyIH1dICovXG5jb25zdCBzdWZmaXhlcyA9IC8oIykrJC87XG5jb25zdCB0cmFpbGluZ0hhc2ggPSAvIyQvO1xuY29uc3Qgc3RhcnRpbmdIYXNoQW5kU2xhc2ggPSAvXlsjL10rLztcbmNvbnN0IGlzRG9tYWluID0gL15bXjpdKzpcXC9cXC9bXi9dK1xcLy87XG5jb25zdCB0cmFpbGluZ0ZyYWdtZW50cyA9IC9cXC9bXi9dKiQvO1xuY29uc3QgaWRBbmRQb2ludGVyID0gLyMuKiQvO1xuLy8gQHRvZG8gYWRkIG1pc3NpbmcgdGVzdCBmb3IgdXJuIGlkc1xuY29uc3QgaXNVUk4gPSAvXnVybjp1dWlkOlswLTlBLUZhLWZdLztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGpvaW5TY29wZShwcmV2aW91cywgaWQpIHtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCAmJiBpZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIiNcIjtcbiAgICB9XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzLnJlcGxhY2UodHJhaWxpbmdIYXNoLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGlzVVJOLnRlc3QoaWQpKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzID09IG51bGwgfHwgcHJldmlvdXMgPT09IFwiXCIgfHwgcHJldmlvdXMgPT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBpZC5yZXBsYWNlKHRyYWlsaW5nSGFzaCwgXCJcIik7XG4gICAgfVxuICAgIGlmIChpZFswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke3ByZXZpb3VzLnJlcGxhY2UoaWRBbmRQb2ludGVyLCBcIlwiKX0ke2lkLnJlcGxhY2Uoc3VmZml4ZXMsIFwiXCIpfWA7XG4gICAgfVxuICAgIGlmIChpc0RvbWFpbi50ZXN0KGlkKSkge1xuICAgICAgICByZXR1cm4gaWQucmVwbGFjZSh0cmFpbGluZ0hhc2gsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoaXNEb21haW4udGVzdChwcmV2aW91cykgJiYgaWQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIGRvbWFpbiB0aGF0IHNob3VsZCBiZSBqb2luZWQgd2l0aCBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAgIC8vIHRodXMgd2UgaGF2ZSB0byByZW1vdmUgYWxsIHBhdGhzIGZyb20gZG9tYWluIGJlZm9yZSBqb2luaW5nXG4gICAgICAgIHJldHVybiBgJHtwcmV2aW91cy5yZXBsYWNlKC8oXlteOl0rOlxcL1xcL1teL10rKSguKikvLCBcIiQxXCIpfS8ke2lkLnJlcGxhY2Uoc3RhcnRpbmdIYXNoQW5kU2xhc2gsIFwiXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcmV2aW91cy5yZXBsYWNlKHRyYWlsaW5nRnJhZ21lbnRzLCBcIlwiKX0vJHtpZC5yZXBsYWNlKHN0YXJ0aW5nSGFzaEFuZFNsYXNoLCBcIlwiKX1gO1xufVxuIiwiY29uc3Qgc3VmZml4ZXMgPSAvKCMpKyQvZztcbmNvbnN0IGVtcHR5VmFsdWVzID0gW1wiXCIsIG51bGwsIFwiI1wiXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwbGl0UmVmKCRyZWYpIHtcbiAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMoJHJlZikpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAkcmVmID0gJHJlZi5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKTtcbiAgICBpZiAoJHJlZi5pbmRleE9mKFwiI1wiKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFskcmVmLnJlcGxhY2UoLygjfFxcLykrJC9nLCBcIlwiKV07XG4gICAgfVxuICAgIGlmICgkcmVmLmluZGV4T2YoXCIjXCIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbJHJlZi5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9ICRyZWYuc3BsaXQoXCIjXCIpO1xuICAgIHJlc3VsdFswXSA9IHJlc3VsdFswXS5yZXBsYWNlKC8oI3xcXC8pKyQvZywgXCJcIik7XG4gICAgcmVzdWx0WzFdID0gYCMke3Jlc3VsdFsxXS5yZXBsYWNlKHN1ZmZpeGVzLCBcIlwiKX1gO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBnZXQgfSBmcm9tIFwiQHNhZ29sZC9qc29uLXBvaW50ZXJcIjtcbmltcG9ydCBzcGxpdFJlZiBmcm9tIFwiLi9zcGxpdFJlZlwiO1xuaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi4vZ2V0VHlwZU9mXCI7XG5jb25zdCBzdWZmaXhlcyA9IC8oIykrJC9nO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiBnZXRUeXBlT2YodmFsKSA9PT0gXCJvYmplY3RcIjtcbi8vIDEuIGNvbWJpbmVkIGlzIGtub3duXG4vLyAyLiBiYXNlIG9yIHBvaW50ZXIgaXMga25vd25cbi8vIDMuIGJhc2UgKyBwb2ludGVyIGlzIGtub3duXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWYoY29udGV4dCwgcm9vdFNjaGVtYSwgJHNlYXJjaCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgbGV0ICRyZWY7XG4gICAgaWYgKGlzT2JqZWN0KCRzZWFyY2gpKSB7XG4gICAgICAgICRyZWYgPSAkc2VhcmNoLl9fcmVmIHx8ICRzZWFyY2guJHJlZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICRyZWYgPSAkc2VhcmNoO1xuICAgIH1cbiAgICBpZiAoJHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByb290U2NoZW1hO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbiRyZWZcIiwgJHJlZik7XG4gICAgbGV0IHNjaGVtYTtcbiAgICAvLyBpcyBpdCBhIGtub3duICRyZWY/XG4gICAgY29uc3QgJHJlbW90ZSA9ICRyZWYucmVwbGFjZShzdWZmaXhlcywgXCJcIik7XG4gICAgaWYgKGNvbnRleHQucmVtb3Rlc1skcmVtb3RlXSAhPSBudWxsKSB7XG4gICAgICAgIHNjaGVtYSA9IGNvbnRleHQucmVtb3Rlc1skcmVtb3RlXTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCLCuyByZW1vdGVcIik7XG4gICAgICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiwrvCuyByZXJlc29sdmVcIiwgc2NoZW1hKTtcbiAgICAgICAgICAgIC8vIEB0b2RvIGFkZCBtaXNzaW5nIHRlc3QgZm9yIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgcmV0dXJuIGdldFJlZihjb250ZXh0LCBzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCLCu8K7IHJldHVyblwiLCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEBkcmFmdCAyMDE5LTA5XG4gICAgY29uc3QgJGFuY2hvciA9IChfYSA9IGNvbnRleHQuYW5jaG9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyRyZWZdO1xuICAgIGlmICgkYW5jaG9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiwrsgYW5jaG9yXCIsICRhbmNob3IpO1xuICAgICAgICByZXR1cm4gZ2V0KHJvb3RTY2hlbWEsICRhbmNob3IpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5pZHNbJHJlZl0gIT0gbnVsbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIsK7IGlkXCIsIGNvbnRleHQuaWRzWyRyZWZdKTtcbiAgICAgICAgc2NoZW1hID0gZ2V0KHJvb3RTY2hlbWEsIGNvbnRleHQuaWRzWyRyZWZdKTtcbiAgICAgICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuJHJlZikge1xuICAgICAgICAgICAgLy8gQHRvZG8gYWRkIG1pc3NpbmcgdGVzdCBmb3IgdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVmKGNvbnRleHQsIHJvb3RTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY29uc3QgJGlucHV0UmVmID0gJHJlZjtcbiAgICAvLyBpcyBpdCBhIHJlZiB3aXRoIGhvc3QvcG9pbnRlcj9cbiAgICBjb25zdCBmcmFnbWVudHMgPSBzcGxpdFJlZigkcmVmKTtcbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcm9vdFNjaGVtYTtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCLCuyBmcmFnMVwiLCBmcmFnbWVudHMpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImlkc1wiLCByb290U2NoZW1hLmdldENvbnRleHQoKS5pZHMpO1xuICAgICAgICAkcmVmID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICBpZiAoY29udGV4dC5yZW1vdGVzWyRyZWZdKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIsK7IHJlbW90ZVwiKTtcbiAgICAgICAgICAgIHNjaGVtYSA9IGNvbnRleHQucmVtb3Rlc1skcmVmXTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVmKGNvbnRleHQsIHJvb3RTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuaWRzWyRyZWZdKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIsK7IGlkXCIpO1xuICAgICAgICAgICAgc2NoZW1hID0gZ2V0KHJvb3RTY2hlbWEsIGNvbnRleHQuaWRzWyRyZWZdKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVmKGNvbnRleHQsIHJvb3RTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0b2RvIHdoeSB0aGlzIHNwZWNpYWwgY2FzZVxuICAgICAgICBjb25zdCByb290Q29udGV4dFJlZiA9IChfYiA9IHJvb3RTY2hlbWEuZ2V0Q29udGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwocm9vdFNjaGVtYSkuaWRzWyRyZWZdO1xuICAgICAgICBpZiAocm9vdENvbnRleHRSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWYoY29udGV4dCwgcm9vdFNjaGVtYSwgcm9vdENvbnRleHRSZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFnbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiwrsgZnJhZzJcIiwgZnJhZ21lbnRzKTtcbiAgICAgICAgY29uc3QgYmFzZSA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgJHJlZiA9IGZyYWdtZW50c1sxXTtcbiAgICAgICAgLy8gQHRvZG8gdGhpcyBpcyB1bm5lY2Vzc2FyeSBkdWUgdG8gaW5jb25zaXN0ZW5jaWVzXG4gICAgICAgIGNvbnN0IGZyb21SZW1vdGUgPSAoX2MgPSBjb250ZXh0LnJlbW90ZXNbYmFzZV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbnRleHQucmVtb3Rlc1tgJHtiYXNlfS9gXTtcbiAgICAgICAgaWYgKGZyb21SZW1vdGUpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiwrsgcmVtb3RlXCIpO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSByZXRyaWV2ZWQgYSBkaWZmZXJlbnQgY29tcGlsZWQganNvbi1zY2hlbWEuIFRoaXMgY29tcGlsZWQgc2NoZW1hIGNvbnRhaW5zIGFcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIHNjb3BlIChjb250ZXh0KSB3aGVyZSB3ZSBtaWdodCBuZWVkIHRvIHdvcmsgd2l0aFxuICAgICAgICAgICAgLy8gQU5DSE9SXG4gICAgICAgICAgICBpZiAoZnJvbVJlbW90ZS5nZXRDb250ZXh0ICYmIGZyb21SZW1vdGUuZ2V0Q29udGV4dCgpLmFuY2hvcnNbJGlucHV0UmVmXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCLCuyByZW1vdGUgwrsgYW5jaG9yXCIpO1xuICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBpcyBzdG9yZWQgd2l0aCBpdHMgc2NvcGUgKGlkKSBpdCBpcyBkZWZpbmVkIGluLiBUaHVzIGNvbGxpc2lvbnMgYXJlXG4gICAgICAgICAgICAgICAgLy8gYXZvaWRlZCwgYnV0IHRoZSBjdXJyZW50IGNvbmRpdGlvbiBpcyByZXF1aXJlZCB0byByZXNvbHZlIHRoZSBhbmNob3IgZm9yIG5vd1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tUmVtb3RlLmdldFJlZigkaW5wdXRSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUEFUSCAoZ2V0X3JlZilcbiAgICAgICAgICAgIGlmIChmcm9tUmVtb3RlLmdldFJlZikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiwrsgcmVtb3RlIMK7IHJlZlwiKTtcbiAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSByZWZlcmVuY2UgaW4gdGhlIG5ldyBzY2hlbWFcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVJlbW90ZS5nZXRSZWYoJHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2xvZyhcIndhcm5pbmc6IHVuY29tcGlsZWQgcmVtb3RlIC0gY29udGV4dCBtYXkgYmUgd3JvbmdcIiwgYmFzZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVmKGNvbnRleHQsIGZyb21SZW1vdGUsICRyZWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0b2RvIHRoaXMgaXMgdW5uZWNlc3NhcnkgZHVlIHRvIGluY29uc2lzdGVuY2llc1xuICAgICAgICBjb25zdCBmcm9tSWQgPSAoX2QgPSBjb250ZXh0Lmlkc1tiYXNlXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29udGV4dC5pZHNbYCR7YmFzZX0vYF07XG4gICAgICAgIGlmIChmcm9tSWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiwrsgaWRcIiwgZnJvbUlkKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWYoY29udGV4dCwgZ2V0KHJvb3RTY2hlbWEsIGZyb21JZCksICRyZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiwrsgb3RoZXJcIik7XG4gICAgc2NoZW1hID0gZ2V0KHJvb3RTY2hlbWEsIChfZSA9IGNvbnRleHQuaWRzWyRyZWZdKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAkcmVmKTtcbiAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS4kcmVmKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWYoY29udGV4dCwgcm9vdFNjaGVtYSwgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbiIsIi8qIGVzbGludCBtYXgtc3RhdGVtZW50cy1wZXItbGluZTogW1wiZXJyb3JcIiwgeyBcIm1heFwiOiAyIH1dICovXG5pbXBvcnQgeyBlYWNoU2NoZW1hIH0gZnJvbSBcIi4uL2VhY2hTY2hlbWFcIjtcbmltcG9ydCBqb2luU2NvcGUgZnJvbSBcIi4vam9pblNjb3BlXCI7XG5pbXBvcnQgZ2V0UmVmIGZyb20gXCIuL2dldFJlZlwiO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSBcIkBzYWdvbGQvanNvbi1wb2ludGVyXCI7XG5jb25zdCBDT01QSUxFRCA9IFwiX19jb21waWxlZFwiO1xuY29uc3QgQ09NUElMRURfUkVGID0gXCJfX3JlZlwiO1xuY29uc3QgR0VUX1JFRiA9IFwiZ2V0UmVmXCI7XG5jb25zdCBHRVRfUk9PVCA9IFwiZ2V0Um9vdFwiO1xuY29uc3Qgc3VmZml4ZXMgPSAvKCN8XFwvKSskL2c7XG4vKipcbiAqIGNvbXBpbGVzIHRoZSBpbnB1dCByb290IHNjaGVtYSBmb3IgYCRyZWZgIHJlc29sdXRpb24gYW5kIHJldHVybnMgaXQgYWdhaW5cbiAqIEBhdHRlbnRpb24gdGhpcyBtb2RpZmllcyBpbnB1dCBzY2hlbWEgYnV0IG1haW50YWlucyBkYXRhLXN0cnVjdHVyZSBhbmQgdGh1cyByZXR1cm5zXG4gKiB0aGUgc2FtZSBvYmplY3Qgd2l0aCBKU09OLnN0cmluZ2lmeVxuICpcbiAqIGZvciBhIGNvbXBpbGVkIGpzb24tc2NoZW1hIHlvdSBjYW4gY2FsbCBnZXRSZWYgb24gYW55IGNvbnRhaW5lZCBzY2hlbWEgKGxvY2F0aW9uIG9mIHR5cGUpLlxuICogdGhpcyByZXNvbHZlcyBhICRyZWYgdGFyZ2V0IHRvIGEgdmFsaWQgc2NoZW1hIChmb3IgYSB2YWxpZCAkcmVmKVxuICpcbiAqIEBwYXJhbSBkcmFmdFxuICogQHBhcmFtIHNjaGVtYVRvQ29tcGlsZSAtIGpzb24tc2NoZW1hIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSBbcm9vdFNjaGVtYV0gLSBjb21waWxlZCByb290IGpzb24tc2NoZW1hIHRvIHVzZSBmb3IgZGVmaW5pdGlvbnMgcmVzb2x1dGlvblxuICogQHBhcmFtIFtmb3JjZV0gPSBmYWxzZSAtIGZvcmNlIGNvbXBpbGUganNvbi1zY2hlbWFcbiAqIEByZXR1cm4gY29tcGlsZWQgaW5wdXQganNvbi1zY2hlbWFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGlsZVNjaGVtYShkcmFmdCwgc2NoZW1hVG9Db21waWxlLCByb290U2NoZW1hID0gc2NoZW1hVG9Db21waWxlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFzY2hlbWFUb0NvbXBpbGUgfHwgc2NoZW1hVG9Db21waWxlW0NPTVBJTEVEXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFUb0NvbXBpbGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7IGlkczoge30sIHJlbW90ZXM6IGRyYWZ0LnJlbW90ZXMgfTtcbiAgICBjb25zdCByb290U2NoZW1hQXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShzY2hlbWFUb0NvbXBpbGUpO1xuICAgIGNvbnN0IGNvbXBpbGVkU2NoZW1hID0gSlNPTi5wYXJzZShyb290U2NoZW1hQXNTdHJpbmcpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbXBpbGVkU2NoZW1hLCB7XG4gICAgICAgIC8vIGZsYWcgdGhpcyBzY2hlbWEgYXMgY29tcGlsZWRcbiAgICAgICAgW0NPTVBJTEVEXTogeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IHRydWUgfSxcbiAgICAgICAgLy8gYWRkIGdldFJlZi1oZWxwZXIgdG8gdGhpcyBvYmplY3RcbiAgICAgICAgW0dFVF9SRUZdOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRSZWYuYmluZChudWxsLCBjb250ZXh0LCBjb21waWxlZFNjaGVtYSlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGJhaWwgZWFybHksIHdoZW4gbm8gJHJlZnMgYXJlIGRlZmluZWRcbiAgICBpZiAoZm9yY2UgPT09IGZhbHNlICYmIHJvb3RTY2hlbWFBc1N0cmluZy5pbmNsdWRlcyhcIiRyZWZcIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBjb21waWxlZFNjaGVtYTtcbiAgICB9XG4gICAgLy8gY29tcGlsZSB0aGlzIHNjaGVtYSB1bmRlciByb290U2NoZW1hLCBtYWtpbmcgZGVmaW5pdGlvbnMgYXZhaWxhYmxlIHRvICRyZWYtcmVzb2x1dGlvblxuICAgIGlmIChzY2hlbWFUb0NvbXBpbGUgIT09IHJvb3RTY2hlbWEpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBpbGVkU2NoZW1hLCBcImRlZmluaXRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHJvb3RTY2hlbWEuZGVmaW5pdGlvbnMsIHJvb3RTY2hlbWEuJGRlZnMsIHNjaGVtYVRvQ29tcGlsZS5kZWZpbml0aW9ucywgc2NoZW1hVG9Db21waWxlLiRkZWZzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0ge307XG4gICAgY29uc3QgZ2V0Um9vdCA9ICgpID0+IGNvbXBpbGVkU2NoZW1hO1xuICAgIGVhY2hTY2hlbWEoY29tcGlsZWRTY2hlbWEsIChzY2hlbWEsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc2NoZW1hLmlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgc2NoZW1hIGJlaW5nIG1lcmdlZCBvbiByb290IG9iamVjdCwgd2UgY2Fubm90IG92ZXJyaWRlXG4gICAgICAgICAgICAvLyBwYXJlbnRzIGxvY2F0aW9ucywgYnV0IG11c3QgcmV1c2UgaXRcbiAgICAgICAgICAgIGlmIChzY2hlbWEuaWQuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgLyhhbGxPZnxhbnlPZnxvbmVPZilcXC9cXGQrJC8udGVzdChwb2ludGVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBvaW50ZXIgPSBwb2ludGVyLnJlcGxhY2UoL1xcLyhhbGxPZnxhbnlPZnxvbmVPZilcXC9cXGQrJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IGdldChjb21waWxlZFNjaGVtYSwgcGFyZW50UG9pbnRlcik7XG4gICAgICAgICAgICAgICAgc2NoZW1hLmlkID0gKF9hID0gcGFyZW50U2NoZW1hLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzY2hlbWEuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0Lmlkc1tzY2hlbWEuaWQucmVwbGFjZShzdWZmaXhlcywgXCJcIildID0gcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB1cCBzY29wZXMgYW5kIGFkZCB0aGVtIHRvICRyZWYtcmVzb2x1dGlvbiBtYXBcbiAgICAgICAgcG9pbnRlciA9IGAjJHtwb2ludGVyfWAucmVwbGFjZSgvIyMrLywgXCIjXCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1BvaW50ZXIgPSBwb2ludGVyLnJlcGxhY2UoL1xcL1teL10rJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBwYXJlbnRQb2ludGVyID0gcG9pbnRlci5yZXBsYWNlKC9cXC9bXi9dK1xcL1teL10rJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1Njb3BlID0gc2NvcGVzW3ByZXZpb3VzUG9pbnRlcl0gfHwgc2NvcGVzW3BhcmVudFBvaW50ZXJdO1xuICAgICAgICBjb25zdCBzY29wZSA9IGpvaW5TY29wZShwcmV2aW91c1Njb3BlLCBzY2hlbWEuaWQpO1xuICAgICAgICBzY29wZXNbcG9pbnRlcl0gPSBzY29wZTtcbiAgICAgICAgaWYgKGNvbnRleHQuaWRzW3Njb3BlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmlkc1tzY29wZV0gPSBwb2ludGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuJHJlZiAmJiAhc2NoZW1hW0NPTVBJTEVEX1JFRl0pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWEsIENPTVBJTEVEX1JFRiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBqb2luU2NvcGUoc2NvcGUsIHNjaGVtYS4kcmVmKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBAdG9kbyBjdXJyZW50bHkgbm90IHVzZWQ6XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCBHRVRfUk9PVCwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IGdldFJvb3QgfSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImNvbXBpbGVkIHJlZlwiLCBzY29wZSwgc2NoZW1hLiRyZWYsIFwiPT5cIiwgam9pblNjb3BlKHNjb3BlLCBzY2hlbWEuJHJlZikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY29udGV4dC5pZHMsIG51bGwsIDIpKTtcbiAgICByZXR1cm4gY29tcGlsZWRTY2hlbWE7XG59XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tIFwiLi91dGlscy9pc09iamVjdFwiO1xuLyoqXG4gKiBDcmVhdGUgYSBzaW1wbGUganNvbiBzY2hlbWEgZm9yIHRoZSBnaXZlbiBpbnB1dCBkYXRhXG4gKiBAcGFyYW0gIGRhdGEgLSBkYXRhIHRvIGdldCBqc29uIHNjaGVtYSBmb3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU2NoZW1hT2YoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICB0eXBlOiBnZXRUeXBlT2YoZGF0YSlcbiAgICB9O1xuICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpc09iamVjdChkYXRhKSkge1xuICAgICAgICBzY2hlbWEucHJvcGVydGllcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXkpID0+IChzY2hlbWEucHJvcGVydGllc1trZXldID0gY3JlYXRlU2NoZW1hT2YoZGF0YVtrZXldKSkpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgc2NoZW1hLml0ZW1zID0gY3JlYXRlU2NoZW1hT2YoZGF0YVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWEuaXRlbXMgPSBkYXRhLm1hcChjcmVhdGVTY2hlbWFPZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbiIsIi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDAgKi9cbmltcG9ydCB7IGNyZWF0ZUN1c3RvbUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2NyZWF0ZUN1c3RvbUVycm9yXCI7XG5jb25zdCBlcnJvcnMgPSB7XG4gICAgYWRkaXRpb25hbEl0ZW1zRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQWRkaXRpb25hbEl0ZW1zRXJyb3JcIiksXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yXCIpLFxuICAgIGFsbE9mRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQWxsT2ZFcnJvclwiKSxcbiAgICBhbnlPZkVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkFueU9mRXJyb3JcIiksXG4gICAgY29uc3RFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJDb25zdEVycm9yXCIpLFxuICAgIGNvbnRhaW5zQW55RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQ29udGFpbnNBbnlFcnJvclwiKSxcbiAgICBjb250YWluc0FycmF5RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQ29udGFpbnNBcnJheUVycm9yXCIpLFxuICAgIGNvbnRhaW5zRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiQ29udGFpbnNFcnJvclwiKSxcbiAgICBjb250YWluc01heEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkNvbnRhaW5zTWF4RXJyb3JcIiksXG4gICAgY29udGFpbnNNaW5FcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJDb250YWluc01pbkVycm9yXCIpLFxuICAgIGVudW1FcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJFbnVtRXJyb3JcIiksXG4gICAgZm9yYmlkZGVuUHJvcGVydHlFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JiaWRkZW5Qcm9wZXJ0eUVycm9yXCIpLFxuICAgIGZvcm1hdERhdGVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXREYXRlRXJyb3JcIiksXG4gICAgZm9ybWF0RGF0ZVRpbWVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXREYXRlVGltZUVycm9yXCIpLFxuICAgIGZvcm1hdER1cmF0aW9uRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0RHVyYXRpb25FcnJvclwiKSxcbiAgICBmb3JtYXRFbWFpbEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdEVtYWlsRXJyb3JcIiksXG4gICAgZm9ybWF0SG9zdG5hbWVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRIb3N0bmFtZUVycm9yXCIpLFxuICAgIGZvcm1hdElQVjRFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRJUFY0RXJyb3JcIiksXG4gICAgZm9ybWF0SVBWNExlYWRpbmdaZXJvRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0SVBWNExlYWRpbmdaZXJvRXJyb3JcIiksXG4gICAgZm9ybWF0SVBWNkVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdElQVjZFcnJvclwiKSxcbiAgICBmb3JtYXRJUFY2TGVhZGluZ1plcm9FcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRJUFY2TGVhZGluZ1plcm9FcnJvclwiKSxcbiAgICBmb3JtYXRKc29uUG9pbnRlckVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdEpzb25Qb2ludGVyRXJyb3JcIiksXG4gICAgZm9ybWF0UmVnRXhFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRSZWdFeEVycm9yXCIpLFxuICAgIGZvcm1hdFRpbWVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRUaW1lRXJyb3JcIiksXG4gICAgZm9ybWF0VVJJRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0VVJJRXJyb3JcIiksXG4gICAgZm9ybWF0VVJJUmVmZXJlbmNlRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiRm9ybWF0VVJJUmVmZXJlbmNlRXJyb3JcIiksXG4gICAgZm9ybWF0VVJJVGVtcGxhdGVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRVUklUZW1wbGF0ZUVycm9yXCIpLFxuICAgIGZvcm1hdFVSTEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkZvcm1hdFVSTEVycm9yXCIpLFxuICAgIGZvcm1hdFVVSURFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJGb3JtYXRVVUlERXJyb3JcIiksXG4gICAgaW52YWxpZERhdGFFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJJbnZhbGlkRGF0YUVycm9yXCIpLFxuICAgIGludmFsaWRQcm9wZXJ0eU5hbWVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJJbnZhbGlkUHJvcGVydHlOYW1lRXJyb3JcIiksXG4gICAgaW52YWxpZFNjaGVtYUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkludmFsaWRTY2hlbWFFcnJvclwiKSxcbiAgICBpbnZhbGlkVHlwZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIkludmFsaWRUeXBlRXJyb3JcIiksXG4gICAgbWF4aW11bUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1heGltdW1FcnJvclwiKSxcbiAgICBtYXhJdGVtc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1heEl0ZW1zRXJyb3JcIiksXG4gICAgbWF4TGVuZ3RoRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWF4TGVuZ3RoRXJyb3JcIiksXG4gICAgbWF4UHJvcGVydGllc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1heFByb3BlcnRpZXNFcnJvclwiKSxcbiAgICBtaW5pbXVtRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWluaW11bUVycm9yXCIpLFxuICAgIG1pbkl0ZW1zRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWluSXRlbXNFcnJvclwiKSxcbiAgICBtaW5JdGVtc09uZUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1pbkl0ZW1zT25lRXJyb3JcIiksXG4gICAgbWluTGVuZ3RoRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWluTGVuZ3RoRXJyb3JcIiksXG4gICAgbWluTGVuZ3RoT25lRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTWluTGVuZ3RoT25lRXJyb3JcIiksXG4gICAgbWluUHJvcGVydGllc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1pblByb3BlcnRpZXNFcnJvclwiKSxcbiAgICBtaXNzaW5nRGVwZW5kZW5jeUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk1pc3NpbmdEZXBlbmRlbmN5RXJyb3JcIiksXG4gICAgbWlzc2luZ09uZU9mUHJvcGVydHlFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNaXNzaW5nT25lT2ZQcm9wZXJ0eUVycm9yXCIpLFxuICAgIG11bHRpcGxlT2ZFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJNdWx0aXBsZU9mRXJyb3JcIiksXG4gICAgbXVsdGlwbGVPbmVPZkVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk11bHRpcGxlT25lT2ZFcnJvclwiKSxcbiAgICBub0FkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiTm9BZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yXCIpLFxuICAgIG5vdEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIk5vdEVycm9yXCIpLFxuICAgIG9uZU9mRXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiT25lT2ZFcnJvclwiKSxcbiAgICBvbmVPZlByb3BlcnR5RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiT25lT2ZQcm9wZXJ0eUVycm9yXCIpLFxuICAgIHBhdHRlcm5FcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJQYXR0ZXJuRXJyb3JcIiksXG4gICAgcGF0dGVyblByb3BlcnRpZXNFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJQYXR0ZXJuUHJvcGVydGllc0Vycm9yXCIpLFxuICAgIHJlcXVpcmVkUHJvcGVydHlFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJSZXF1aXJlZFByb3BlcnR5RXJyb3JcIiksXG4gICAgc2NoZW1hV2FybmluZzogY3JlYXRlQ3VzdG9tRXJyb3IoXCJTY2hlbWFXYXJuaW5nXCIpLFxuICAgIHR5cGVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJUeXBlRXJyb3JcIiksXG4gICAgdW5kZWZpbmVkVmFsdWVFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJVbmRlZmluZWRWYWx1ZUVycm9yXCIpLFxuICAgIHVuZXZhbHVhdGVkSXRlbXNFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXCJVbmV2YWx1YXRlZEl0ZW1zRXJyb3JcIiksXG4gICAgdW5ldmFsdWF0ZWRQcm9wZXJ0eUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlVuZXZhbHVhdGVkUHJvcGVydHlFcnJvclwiKSxcbiAgICB1bmlxdWVJdGVtc0Vycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlVuaXF1ZUl0ZW1zRXJyb3JcIiksXG4gICAgdW5rbm93blByb3BlcnR5RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFwiVW5rbm93blByb3BlcnR5RXJyb3JcIiksXG4gICAgdmFsdWVOb3RFbXB0eUVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcIlZhbHVlTm90RW1wdHlFcnJvclwiKVxufTtcbmV4cG9ydCBkZWZhdWx0IGVycm9ycztcbiIsImltcG9ydCB2YWxpZFVybCBmcm9tIFwidmFsaWQtdXJsXCI7XG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZUlkbkVtYWlsIH0gZnJvbSBcInNtdHAtYWRkcmVzcy1wYXJzZXJcIjtcbmltcG9ydCBnZXRUeXBlT2YgZnJvbSBcIi4uL2dldFR5cGVPZlwiO1xuY29uc3QgaXNWYWxpZElQVjQgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvO1xuY29uc3QgaXNWYWxpZElQVjYgPSAvXigoKFswLTlhLWZdezEsNH06KXs3fShbMC05YS1mXXsxLDR9fDopKXwoKFswLTlhLWZdezEsNH06KXs2fSg6WzAtOWEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezV9KCgoOlswLTlhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezR9KCgoOlswLTlhLWZdezEsNH0pezEsM30pfCgoOlswLTlhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXszfSgoKDpbMC05YS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05YS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezJ9KCgoOlswLTlhLWZdezEsNH0pezEsNX0pfCgoOlswLTlhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7MX0oKCg6WzAtOWEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05YS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05YS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSQvaTtcbmNvbnN0IGlzVmFsaWRIb3N0bmFtZSA9IC9eKD89LnsxLDI1NX0kKVswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KD86XFwuWzAtOUEtWmEtel0oPzooPzpbMC05QS1aYS16XXwtKXswLDYxfVswLTlBLVphLXpdKT8pKlxcLj8kLztcbmNvbnN0IG1hdGNoRGF0ZSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IG1hdGNoVGltZSA9IC9eKD88dGltZT4oPzooWzAtMV1cXGR8MlswLTNdKTpbMC01XVxcZDooPzxzZWNvbmQ+WzAtNV1cXGR8NjApKSkoPzpcXC5cXGQrKT8oPzxvZmZzZXQ+KD86enxbKy1dKFswLTFdXFxkfDJbMC0zXSkoPzo6P1swLTVdXFxkKT8pKSQvaTtcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5jb25zdCBpc1ZhbGlkSnNvblBvaW50ZXIgPSAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvO1xuY29uc3QgaXNWYWxpZFJlbGF0aXZlSnNvblBvaW50ZXIgPSAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC87XG5jb25zdCBpc1ZhbGlkVVJJUmVmID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbi8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbmNvbnN0IGlzVmFsaWRVUklUZW1wbGF0ZSA9IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pO1xuY29uc3QgaXNWYWxpZER1cmF0aW9uU3RyaW5nID0gL15QKD8hJCkoXFxkK1kpPyhcXGQrTSk/KFxcZCtXKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/JC87XG4vLyBEZWZhdWx0IEpzb24tU2NoZW1hIGZvcm1hdHM6IGRhdGUtdGltZSwgZW1haWwsIGhvc3RuYW1lLCBpcHY0LCBpcHY2LCB1cmksIHVyaXJlZlxuY29uc3QgZm9ybWF0VmFsaWRhdG9ycyA9IHtcbiAgICBkYXRlOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jZndvcmtlci9jZndvcmtlci9ibG9iL21haW4vcGFja2FnZXMvanNvbi1zY2hlbWEvc3JjL2Zvcm1hdC50c1xuICAgICAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChtYXRjaERhdGUpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RGF0ZVRpbWVFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgICAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBkYXkgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgICAgICBjb25zdCBpc0xlYXBZZWFyID0geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gICAgICAgIGlmIChtb250aCA+PSAxICYmXG4gICAgICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICAgICAgZGF5ID49IDEgJiZcbiAgICAgICAgICAgIGRheSA8PSAobW9udGggPT0gMiAmJiBpc0xlYXBZZWFyID8gMjkgOiBEQVlTW21vbnRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXREYXRlRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgXCJkYXRlLXRpbWVcIjogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlQW5kVGltZSA9IHZhbHVlLnNwbGl0KC90L2kpO1xuICAgICAgICBpZiAoZGF0ZUFuZFRpbWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlSXNWYWxpZCA9IGZvcm1hdFZhbGlkYXRvcnMuZGF0ZShub2RlLCBkYXRlQW5kVGltZVswXSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVJc1ZhbGlkID0gZm9ybWF0VmFsaWRhdG9ycy50aW1lKG5vZGUsIGRhdGVBbmRUaW1lWzFdKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGRhdGVJc1ZhbGlkICYmIHRpbWVJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdERhdGVUaW1lRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgZHVyYXRpb246IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZU9mKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Vla3MgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgdW5pdHNcbiAgICAgICAgY29uc3QgaXNJbnZhbGlkRHVyYXRpb25TdHJpbmcgPSAvKFxcZCtNKShcXGQrVyl8KFxcZCtZKShcXGQrVykvO1xuICAgICAgICBpZiAoIWlzVmFsaWREdXJhdGlvblN0cmluZy50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgaXNJbnZhbGlkRHVyYXRpb25TdHJpbmcudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRyYWZ0LmVycm9ycy5mb3JtYXREdXJhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwb2ludGVyOiBub2RlLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBub2RlLnNjaGVtYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVtYWlsOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0V4b2R1c01vdmVtZW50L3NjaGVtYXNhZmUvYmxvYi9tYXN0ZXIvc3JjL2Zvcm1hdHMuanNcbiAgICAgICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdEVtYWlsRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtuYW1lLCBob3N0LCAuLi5yZXN0XSA9IHZhbHVlLnNwbGl0KFwiQFwiKTtcbiAgICAgICAgaWYgKCFuYW1lIHx8ICFob3N0IHx8IHJlc3QubGVuZ3RoICE9PSAwIHx8IG5hbWUubGVuZ3RoID4gNjQgfHwgaG9zdC5sZW5ndGggPiAyNTMpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RW1haWxFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVbMF0gPT09IFwiLlwiIHx8IG5hbWUuZW5kc1dpdGgoXCIuXCIpIHx8IG5hbWUuaW5jbHVkZXMoXCIuLlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRFbWFpbEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9eW2EtejAtOS4tXSskL2kudGVzdChob3N0KSB8fCAhL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyQvaS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdEVtYWlsRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaG9zdC5zcGxpdChcIi5cIikuZXZlcnkoKHBhcnQpID0+IC9eW2EtejAtOV0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQvaS50ZXN0KHBhcnQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRFbWFpbEVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGRyYWZ0IDdcbiAgICAgKiBbUkZDNjUzMV0gaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI1JGQzY1MzFcbiAgICAgKi9cbiAgICBcImlkbi1lbWFpbFwiOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZUlkbkVtYWlsKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RW1haWxFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhvc3RuYW1lOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCBpc1ZhbGlkSG9zdG5hbWUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRIb3N0bmFtZUVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9LFxuICAgIGlwdjQ6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWzBdID09PSBcIjBcIikge1xuICAgICAgICAgICAgLy8gbGVhZGluZyB6ZXJvZXMgc2hvdWxkIGJlIHJlamVjdGVkLCBhcyB0aGV5IGFyZSB0cmVhdGVkIGFzIG9jdGFsc1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRJUFY0TGVhZGluZ1plcm9FcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAxNSAmJiBpc1ZhbGlkSVBWNC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdElQVjRFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICBpcHY2OiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVswXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIC8vIGxlYWRpbmcgemVyb2VzIHNob3VsZCBiZSByZWplY3RlZCwgYXMgdGhleSBhcmUgdHJlYXRlZCBhcyBvY3RhbHNcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0SVBWNkxlYWRpbmdaZXJvRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gNDUgJiYgaXNWYWxpZElQVjYudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRJUFY2RXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgXCJqc29uLXBvaW50ZXJcIjogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZEpzb25Qb2ludGVyLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0SnNvblBvaW50ZXJFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkUmVsYXRpdmVKc29uUG9pbnRlci50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdEpzb25Qb2ludGVyRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgcmVnZXg6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgL1xcXFxaJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0UmVnRXhFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdjcgdGVzdHMsIGlnbm9yZSBub24tcmVnZXggdmFsdWVzXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0UmVnRXhFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICAvLyBoaDptbTpzcy5zVFpEXG4gICAgLy8gUkZDIDMzMzkgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNFxuICAgIHRpbWU6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nmd29ya2VyL2Nmd29ya2VyL2Jsb2IvbWFpbi9wYWNrYWdlcy9qc29uLXNjaGVtYS9zcmMvZm9ybWF0LnRzXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChtYXRjaFRpbWUpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0RGF0ZVRpbWVFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGVhcCBzZWNvbmRcbiAgICAgICAgaWYgKG1hdGNoZXMuZ3JvdXBzLnNlY29uZCA9PT0gXCI2MFwiKSB7XG4gICAgICAgICAgICAvLyBiYWlsIGVhcmx5XG4gICAgICAgICAgICBpZiAoLzIzOjU5OjYwKHp8XFwrMDA6MDApL2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgc3VtIG1hdGNoZXMgMjM6NTlcbiAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBtYXRjaGVzLmdyb3Vwcy50aW1lLm1hdGNoKC8oXFxkKyk6KFxcZCspOi8pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0TWludXRlcyA9IG1hdGNoZXMuZ3JvdXBzLm9mZnNldC5tYXRjaCgvKFxcZCspOihcXGQrKS8pO1xuICAgICAgICAgICAgaWYgKG9mZnNldE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob3VyID0gcGFyc2VJbnQobWludXRlc1sxXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG9mZnNldE1pbnV0ZXNbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KG1pbnV0ZXNbMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldE1pbiA9IHBhcnNlSW50KG9mZnNldE1pbnV0ZXNbMl0pO1xuICAgICAgICAgICAgICAgIGxldCBkZWx0YVRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKC9eLS8udGVzdChtYXRjaGVzLmdyb3Vwcy5vZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVGltZSA9IChob3VyICsgb2Zmc2V0SG91cikgKiA2MCArIChtaW4gKyBvZmZzZXRNaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFUaW1lID0gKDI0ICsgaG91ciAtIG9mZnNldEhvdXIpICogNjAgKyAobWluIC0gb2Zmc2V0TWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKGRlbHRhVGltZSAvIDYwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxIb3VyID0gaG91cnMgJSAyNDtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxNaW51dGVzID0gZGVsdGFUaW1lIC0gaG91cnMgKiA2MDtcbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsSG91ciA9PT0gMjMgJiYgYWN0dWFsTWludXRlcyA9PT0gNTkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdERhdGVUaW1lRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICB1cmk6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkVXJsLmlzVXJpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdFVSSUVycm9yKHsgdmFsdWUsIHBvaW50ZXIsIHNjaGVtYSB9KTtcbiAgICB9LFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkVVJJUmVmLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0VVJJUmVmZXJlbmNlRXJyb3IoeyB2YWx1ZSwgcG9pbnRlciwgc2NoZW1hIH0pO1xuICAgIH0sXG4gICAgXCJ1cmktdGVtcGxhdGVcIjogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZFVSSVRlbXBsYXRlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuZm9ybWF0VVJJVGVtcGxhdGVFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICB1cmw6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWxpZFVybC5pc1dlYlVyaSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JtYXRVUkxFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfSxcbiAgICB1dWlkOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmZvcm1hdFVVSURFcnJvcih7IHZhbHVlLCBwb2ludGVyLCBzY2hlbWEgfSk7XG4gICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdFZhbGlkYXRvcnM7XG4iLCJpbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCIuL3V0aWxzL2lzT2JqZWN0XCI7XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIHBvc3NpYmxlIGNoaWxkLXNjaGVtYXMgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBrZXkuIEluIGNhc2Ugb2YgYSBvbmVPZiBzZWxlY3Rpb24sIG11bHRpcGxlIHNjaGVtYXNcbiAqIGNvdWxkIGJlIGFkZGVkIGF0IHRoZSBnaXZlbiBwcm9wZXJ0eSAoZS5nLiBpdGVtLWluZGV4KSwgdGh1cyBhbiBhcnJheSBvZiBvcHRpb25zIGlzIHJldHVybmVkLiBJbiBhbGwgb3RoZXIgY2FzZXNcbiAqIGEgbGlzdCB3aXRoIGEgc2luZ2xlIGl0ZW0gd2lsbCBiZSByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSBkcmFmdCAgICAgICAtIGRyYWZ0IHRvIHVzZVxuICogQHBhcmFtIHByb3BlcnR5ICAgIC0gcGFyZW50IHNjaGVtYSBvZiBmb2xsb3dpbmcgcHJvcGVydHlcbiAqIEBwYXJhbSBbc2NoZW1hXSAgICAtIHBhcmVudCBzY2hlbWEgb2YgZm9sbG93aW5nIHByb3BlcnR5XG4gKiBAcmV0dXJuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENoaWxkU2NoZW1hU2VsZWN0aW9uKGRyYWZ0LCBwcm9wZXJ0eSwgc2NoZW1hID0gZHJhZnQucm9vdFNjaGVtYSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc2NoZW1hLm9uZU9mKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEub25lT2YubWFwKChpdGVtKSA9PiBkcmFmdC5jcmVhdGVOb2RlKGl0ZW0pLnJlc29sdmVSZWYoKS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoKF9hID0gc2NoZW1hLml0ZW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25lT2YpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5pdGVtcy5vbmVPZi5tYXAoKGl0ZW0pID0+IGRyYWZ0LmNyZWF0ZU5vZGUoaXRlbSkucmVzb2x2ZVJlZigpLnNjaGVtYSk7XG4gICAgfVxuICAgIC8vIGFycmF5Lml0ZW1zW10gZm91bmRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpICYmIHNjaGVtYS5pdGVtcy5sZW5ndGggPiArcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIFtkcmFmdC5zdGVwKGRyYWZ0LmNyZWF0ZU5vZGUoc2NoZW1hKSwgcHJvcGVydHksIHt9KS5zY2hlbWFdO1xuICAgIH1cbiAgICAvLyBhcnJheS5pdGVtc1tdIGV4Y2VlZGVkIChvciB1bmRlZmluZWQpLCBidXQgYWRkaXRpb25hbEl0ZW1zIHNwZWNpZmllZFxuICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zICYmICFpc09iamVjdChzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgIC8vIHdlIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIG5vIHNjaGVtYSBpcyBkZWZpbmVkIC0gbWlnaHQgYmUgc3ViamVjdCBmb3IgY29uZmlndXJhdGlvblxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsU2NoZW1hID0gc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gdHJ1ZSA/IHsgdHlwZTogXCJzdHJpbmdcIiB9IDogc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcbiAgICAgICAgcmV0dXJuIFtkcmFmdC5jcmVhdGVOb2RlKGFkZGl0aW9uYWxTY2hlbWEpLnJlc29sdmVSZWYoKS5zY2hlbWFdO1xuICAgIH1cbiAgICAvLyBhcnJheS5pdGVtc1tdIGV4Y2VlZGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSAmJiBzY2hlbWEuaXRlbXMubGVuZ3RoIDw9ICtwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBkcmFmdC5zdGVwKGRyYWZ0LmNyZWF0ZU5vZGUoc2NoZW1hKSwgcHJvcGVydHksIHt9KTtcbiAgICBpZiAoaXNKc29uRXJyb3Iobm9kZSkpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBub2RlO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBbbm9kZS5zY2hlbWFdO1xufVxuIiwiaW1wb3J0IGdwIGZyb20gXCJAc2Fnb2xkL2pzb24tcG9pbnRlclwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi90eXBlc1wiO1xuY29uc3QgZW1wdHlPYmplY3QgPSB7fTtcbi8qKlxuICogUmV0dXJucyBhIG5vZGUgY29udGFpbmluZyBqc29uLXNjaGVtYSBvZiBhIGRhdGEtanNvbi1wb2ludGVyLlxuICpcbiAqIFRvIHJlc29sdmUgZHluYW1pYyBzY2hlbWEgd2hlcmUgdGhlIHR5cGUgb2YganNvbi1zY2hlbWEgaXMgZXZhbHVhdGVkIGJ5XG4gKiBpdHMgdmFsdWUsIGEgZGF0YSBvYmplY3QgaGFzIHRvIGJlIHBhc3NlZCBpbiBvcHRpb25zLlxuICpcbiAqIFBlciBkZWZhdWx0IHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgc2NoZW1hIGZvciB2YWxpZCBwcm9wZXJ0aWVzXG4gKiB0aGF0IGRvIG5vdCBoYXZlIGEgZGVmaW5lZCBzY2hlbWEuIFVzZSB0aGUgb3B0aW9uIGB3aXRoU2NoZW1hV2FybmluZzogdHJ1ZWAgdG9cbiAqIHJlY2VpdmUgYW4gZXJyb3Igd2l0aCBgY29kZTogc2NoZW1hLXdhcm5pbmdgIGNvbnRhaW5pbmcgdGhlIGxvY2F0aW9uIG9mIGl0c1xuICogbGFzdCBldmFsdWF0ZWQganNvbi1zY2hlbWEuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogZHJhZnQuc2V0U2NoZW1hKHsgdHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczogeyB0aXRsZTogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSB9KTtcbiAqIGNvbnN0IHJlc3VsdCA9IGRyYWZ0LmdldFNjaGVtYSh7ICBwb2ludGVyOiBcIiMvdGl0bGVcIiB9LCBkYXRhOiB7IHRpdGxlOiBcIm15IGhlYWRlclwiIH0pO1xuICogY29uc3Qgc2NoZW1hID0gaXNTY2hlbWFOb2RlKHJlc3VsdCkgPyByZXN1bHQuc2NoZW1hIDogdW5kZWZpbmVkO1xuICogLy8gc2NoZW1hID0geyB0eXBlOiBcInN0cmluZ1wiIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkcmFmdFxuICogQHBhcmFtIFtvcHRpb25zLnBvaW50ZXJdIC0ganNvbiBwb2ludGVyIGluIGRhdGEgdG8gZ2V0IHRoZSBqc29uIHNjaGVtYSBmb3JcbiAqIEBwYXJhbSBbb3B0aW9ucy5kYXRhXSAtIHRoZSBkYXRhIG9iamVjdCwgd2hpY2ggaW5jbHVkZXMgdGhlIGpzb24gcG9pbnRlcnMgdmFsdWUuIFRoaXMgaXMgb3B0aW9uYWwsIGFzXG4gKiAgICBsb25nIGFzIG5vIG9uZU9mLCBhbnlPZiwgZXRjIHN0YXRlbWVudCBpcyBwYXJ0IG9mIHRoZSBwb2ludGVycyBzY2hlbWFcbiAqIEBwYXJhbSBbb3B0aW9ucy5zY2hlbWFdIC0gdGhlIGpzb24gc2NoZW1hIHRvIGl0ZXJhdGUuIERlZmF1bHRzIHRvIGRyYWZ0LnJvb3RTY2hlbWFcbiAqIEBwYXJhbSBbb3B0aW9ucy53aXRoU2NoZW1hV2FybmluZ10gLSBpZiB0cnVlIHJldHVybnMgYW4gZXJyb3IgaW5zdGVhZCBvZiBgdW5kZWZpbmVkYCBmb3IgdmFsaWQgcHJvcGVydGllcyBtaXNzaW5nIGEgc2NoZW1hIGRlZmluaXRpb25cbiAqIEByZXR1cm4ganNvbi1lcnJvciBvciBub2RlIGNvbnRhaW5pbmcgc2NoZW1hIG9mIHJlcXVlc3RlZCBqc29uLXBvaW50ZXIgbG9jYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2NoZW1hKGRyYWZ0LCBvcHRpb25zID0gZW1wdHlPYmplY3QpIHtcbiAgICBjb25zdCB7IHBvaW50ZXIgPSBcIiNcIiwgZGF0YSwgc2NoZW1hID0gZHJhZnQucm9vdFNjaGVtYSwgd2l0aFNjaGVtYVdhcm5pbmcgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwYXRoID0gZ3Auc3BsaXQocG9pbnRlcik7XG4gICAgY29uc3Qgbm9kZSA9IGRyYWZ0LmNyZWF0ZU5vZGUoc2NoZW1hKS5yZXNvbHZlUmVmKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gX2dldFNjaGVtYShub2RlLCBwYXRoLCBkYXRhKTtcbiAgICBpZiAoIXdpdGhTY2hlbWFXYXJuaW5nICYmIGlzSnNvbkVycm9yKHJlc3VsdCkgJiYgcmVzdWx0LmNvZGUgPT09IFwic2NoZW1hLXdhcm5pbmdcIikge1xuICAgICAgICByZXR1cm4gZHJhZnQuY3JlYXRlTm9kZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2dldFNjaGVtYShub2RlLCBwYXRoLCBkYXRhID0gZW1wdHlPYmplY3QpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVzb2x2ZVJlZigpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBwYXRoLnNoaWZ0KCk7IC8vIHN0ZXAga2V5XG4gICAgY29uc3QgbmV4dE5vZGUgPSBub2RlLmRyYWZ0LnN0ZXAobm9kZSwga2V5LCBkYXRhKTsgLy8gc3RlcCBzY2hlbWFcbiAgICBpZiAoaXNKc29uRXJyb3IobmV4dE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBkYXRhXG4gICAgZGF0YSA9IGRhdGFba2V5XTsgLy8gc3RlcCBkYXRhXG4gICAgcmV0dXJuIF9nZXRTY2hlbWEobmV4dE5vZGUsIHBhdGgsIGRhdGEpO1xufVxuIiwiaW1wb3J0IGRlZXBtZXJnZSBmcm9tIFwiZGVlcG1lcmdlXCI7XG5jb25zdCBvdmVyd3JpdGVNZXJnZSA9IChkZXN0aW5hdGlvbkFycmF5LCBzb3VyY2VBcnJheSkgPT4gc291cmNlQXJyYXk7XG4vKipcbiAqIHJldHVybnMgYSBuZXcganNvbi1zY2hlbWEsIHdoZXJlIHByb3BlcnRpZXMgYXJlIGNvbWJpbmVkIGFuZCBhcnJheXMgYXJlIHJlcGxhY2VkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChhLCBiKSA9PiBkZWVwbWVyZ2UoYSwgYiwgeyBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSB9KTtcbi8vIHZhciBkID0gYy5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gYy5pbmRleE9mKGl0ZW0pID09PSBwb3MpXG5jb25zdCBtZXJnZVVuaXF1ZUl0ZW1zID0gKGRlc3RpbmF0aW9uQXJyYXksIHNvdXJjZUFycmF5KSA9PiB7XG4gICAgY29uc3QgYWxsID0gZGVzdGluYXRpb25BcnJheS5jb25jYXQoc291cmNlQXJyYXkpO1xuICAgIHJldHVybiBhbGwuZmlsdGVyKChpdGVtLCBwb3MpID0+IGFsbC5pbmRleE9mKGl0ZW0pID09PSBwb3MpO1xufTtcbi8qKlxuICogcmV0dXJucyBhIG5ldyBqc29uLXNjaGVtYSwgd2hlcmUgcHJvcGVydGllcyBhcmUgY29tYmluZWQgYW5kIGFycmF5cyBhcmUgcmVwbGFjZWRcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlQXJyYXlzVW5pcXVlID0gKGEsIGIpID0+IGRlZXBtZXJnZShhLCBiLCB7IGFycmF5TWVyZ2U6IG1lcmdlVW5pcXVlSXRlbXMgfSk7XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuLi9nZXRUeXBlT2ZcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHYpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZU9mKHYpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0ZXN0ZWQgYXMgYXJyYXkgLSBjb3VsZCB1c2UgdHMgdHlwZSBndWFyZFxuICAgICAgICAgICAgcmV0dXJuICh2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHYubGVuZ3RoKSA9PT0gMDtcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2KS5sZW5ndGggPT09IDA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwiLyogZXNsaW50IHF1b3RlLXByb3BzOiAwLCBtYXgtc3RhdGVtZW50cy1wZXItbGluZTogW1wiZXJyb3JcIiwgeyBcIm1heFwiOiAyIH1dICovXG5pbXBvcnQgeyByZXNvbHZlT25lT2ZGdXp6eSB9IGZyb20gXCIuL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IG1lcmdlIGZyb20gXCIuL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgY29weSBmcm9tIFwiLi91dGlscy9jb3B5XCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4vY29uZmlnL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpc1NjaGVtYU5vZGUgfSBmcm9tIFwiLi9zY2hlbWFOb2RlXCI7XG5pbXBvcnQgeyBpc0VtcHR5IH0gZnJvbSBcIi4vdXRpbHMvaXNFbXB0eVwiO1xuaW1wb3J0IHsgcmVzb2x2ZUlmU2NoZW1hIH0gZnJvbSBcIi4vZmVhdHVyZXMvaWZcIjtcbmltcG9ydCB7IG1lcmdlQWxsT2ZTY2hlbWEsIHJlc29sdmVTY2hlbWEgfSBmcm9tIFwiLi9mZWF0dXJlcy9hbGxPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZURlcGVuZGVuY2llcyB9IGZyb20gXCIuL2ZlYXR1cmVzL2RlcGVuZGVuY2llc1wiO1xuaW1wb3J0IHsgbWVyZ2VTY2hlbWEgfSBmcm9tIFwiLi9tZXJnZVNjaGVtYVwiO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBzZXR0aW5ncy50ZW1wbGF0ZURlZmF1bHRPcHRpb25zO1xubGV0IGNhY2hlO1xuZnVuY3Rpb24gc2hvdWxkUmVzb2x2ZVJlZihzY2hlbWEsIHBvaW50ZXIpIHtcbiAgICBjb25zdCB7ICRyZWYgfSA9IHNjaGVtYTtcbiAgICBpZiAoJHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGNhY2hlW3BvaW50ZXJdID09IG51bGwgfHwgY2FjaGVbcG9pbnRlcl1bJHJlZl0gPT0gbnVsbCA/IDAgOiBjYWNoZVtwb2ludGVyXVskcmVmXTtcbiAgICByZXR1cm4gdmFsdWUgPCBzZXR0aW5ncy5HRVRfVEVNUExBVEVfUkVDVVJTSU9OX0xJTUlUO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlZihkcmFmdCwgc2NoZW1hLCBwb2ludGVyKSB7XG4gICAgY29uc3QgeyAkcmVmIH0gPSBzY2hlbWE7XG4gICAgaWYgKCRyZWYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvLyBAdG9kbyBwb2ludGVyICsgcmVmIGlzIHJlZHVuZGFudD9cbiAgICBjYWNoZVtwb2ludGVyXSA9IGNhY2hlW3BvaW50ZXJdIHx8IHt9O1xuICAgIGNhY2hlW3BvaW50ZXJdWyRyZWZdID0gY2FjaGVbcG9pbnRlcl1bJHJlZl0gfHwgMDtcbiAgICBjYWNoZVtwb2ludGVyXVskcmVmXSArPSAxO1xuICAgIHJldHVybiBkcmFmdC5jcmVhdGVOb2RlKHNjaGVtYSwgcG9pbnRlcikucmVzb2x2ZVJlZigpLnNjaGVtYTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXNvbHZlcyAkcmVmLCBhbGxPZiBhbmQgYW55T2Ygc2NoZW1hLW9wdGlvbnMsIHJldHVybmluZyBhIGNvbWJpbmVkIGpzb24tc2NoZW1hLlxuICogQWxzbyByZXR1cm5zIGEgcG9pbnRlci1wcm9wZXJ0eSBvbiBzY2hlbWEsIHRoYXQgbXVzdCBiZSB1c2VkIGFzIGN1cnJlbnQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gZHJhZnRcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gcG9pbnRlclxuICogQHJldHVybiByZXNvbHZlZCBqc29uLXNjaGVtYSBvciBpbnB1dC1zY2hlbWFcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVTY2hlbWEoZHJhZnQsIHNjaGVtYSwgZGF0YSwgcG9pbnRlciwgb3B0cykge1xuICAgIC8vIGludmFsaWQgc2NoZW1hXG4gICAgaWYgKGdldFR5cGVPZihzY2hlbWEpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgcG9pbnRlciB9LCBzY2hlbWEpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gaWYgcmVhY2hlZCByZWN1cnNpb24gbGltaXRcbiAgICBpZiAoc2hvdWxkUmVzb2x2ZVJlZihzY2hlbWEsIHBvaW50ZXIpID09PSBmYWxzZSAmJiBkYXRhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyByZXNvbHZlICRyZWYgYW5kIGNvcHkgc2NoZW1hXG4gICAgbGV0IHRlbXBsYXRlU2NoZW1hID0gY29weShyZXNvbHZlUmVmKGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIpKTtcbiAgICAvLyBAZmVhdHVyZSBhbnlPZlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikgJiYgc2NoZW1hLmFueU9mLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gdGVzdCBpZiB3ZSBtYXkgcmVzb2x2ZVxuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZVJlZihzY2hlbWEuYW55T2ZbMF0sIGAke3BvaW50ZXJ9L2FueU9mLzBgKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBbnlPZiA9IHJlc29sdmVSZWYoZHJhZnQsIHNjaGVtYS5hbnlPZlswXSwgYCR7cG9pbnRlcn0vYW55T2YvMGApO1xuICAgICAgICAgICAgdGVtcGxhdGVTY2hlbWEgPSBtZXJnZSh0ZW1wbGF0ZVNjaGVtYSwgcmVzb2x2ZWRBbnlPZik7XG4gICAgICAgICAgICAvLyBhZGQgcG9pbnRlciByZXR1cm4tdmFsdWUsIGlmIGFueVxuICAgICAgICAgICAgdGVtcGxhdGVTY2hlbWEucG9pbnRlciA9IHNjaGVtYS5hbnlPZlswXS4kcmVmIHx8IHRlbXBsYXRlU2NoZW1hLnBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRlbXBsYXRlU2NoZW1hLmFueU9mO1xuICAgIH1cbiAgICAvLyBAZmVhdHVyZSBhbGxPZlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgY29uc3QgbWF5UmVzb2x2ZSA9IHNjaGVtYS5hbGxPZlxuICAgICAgICAgICAgLm1hcCgoYWxsT2YsIGluZGV4KSA9PiBzaG91bGRSZXNvbHZlUmVmKGFsbE9mLCBgJHtwb2ludGVyfS9hbGxPZi8ke2luZGV4fWApKVxuICAgICAgICAgICAgLnJlZHVjZVJpZ2h0KChuZXh0LCBiZWZvcmUpID0+IG5leHQgJiYgYmVmb3JlLCB0cnVlKTtcbiAgICAgICAgaWYgKG1heVJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIGJlZm9yZSBtZXJnaW5nIGFsbC1vZiwgd2UgbmVlZCB0byByZXNvbHZlIGFsbCBpZi10aGVuLWVsc2Ugc3RhdGVzbWVudHNcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdWRwYXRlIGRhdGEgb24gdGhlIHdheSB0byB0cmlnZ2VyIGlmLXRoZW4tZWxzZSBzY2hlbWFzIHNlcXVlbnRpYWxseS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgbWFrZSBpZi10aGVuLWVsc2Ugb3JkZXItZGVwZW5kZW50XG4gICAgICAgICAgICBjb25zdCBhbGxPZiA9IFtdO1xuICAgICAgICAgICAgbGV0IGV4dGVuZGVkRGF0YSA9IGNvcHkoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbE5vZGUgPSBkcmFmdC5jcmVhdGVOb2RlKHNjaGVtYS5hbGxPZltpXSwgcG9pbnRlcik7XG4gICAgICAgICAgICAgICAgYWxsT2YucHVzaChyZXNvbHZlU2NoZW1hKGFsbE5vZGUsIGV4dGVuZGVkRGF0YSkuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBleHRlbmRlZERhdGEgPSBnZXRUZW1wbGF0ZShkcmFmdCwgZXh0ZW5kZWREYXRhLCB7IHR5cGU6IHNjaGVtYS50eXBlLCAuLi5hbGxPZltpXSB9LCBgJHtwb2ludGVyfS9hbGxPZi8ke2l9YCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IG1lcmdlQWxsT2ZTY2hlbWEoZHJhZnQsIHsgYWxsT2YgfSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVNjaGVtYSA9IG1lcmdlU2NoZW1hKHRlbXBsYXRlU2NoZW1hLCByZXNvbHZlZFNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGVtcGxhdGVTY2hlbWEucG9pbnRlciA9IHRlbXBsYXRlU2NoZW1hLnBvaW50ZXIgfHwgc2NoZW1hLiRyZWYgfHwgcG9pbnRlcjtcbiAgICByZXR1cm4gdGVtcGxhdGVTY2hlbWE7XG59XG5jb25zdCBpc0pzb25TY2hlbWEgPSAodGVtcGxhdGUpID0+IHRlbXBsYXRlICYmIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJvYmplY3RcIjtcbi8qKlxuICogQ3JlYXRlIGRhdGEgb2JqZWN0IG1hdGNoaW5nIHRoZSBnaXZlbiBzY2hlbWFcbiAqXG4gKiBAcGFyYW0gZHJhZnQgLSBqc29uIHNjaGVtYSBkcmFmdFxuICogQHBhcmFtIFtkYXRhXSAtIG9wdGlvbmFsIHRlbXBsYXRlIGRhdGFcbiAqIEBwYXJhbSBbc2NoZW1hXSAtIGpzb24gc2NoZW1hLCBkZWZhdWx0cyB0byByb290U2NoZW1hXG4gKiBAcmV0dXJuIGNyZWF0ZWQgdGVtcGxhdGUgZGF0YVxuICovXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZShkcmFmdCwgZGF0YSwgX3NjaGVtYSwgcG9pbnRlciwgb3B0cykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3NjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0VGVtcGxhdGU6IG1pc3Npbmcgc2NoZW1hIGZvciBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgIH1cbiAgICBpZiAocG9pbnRlciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcG9pbnRlclwiKTtcbiAgICB9XG4gICAgLy8gcmVzb2x2ZSAkcmVmIHJlZmVyZW5jZXMsIGFsbE9mIGFuZCBmaXJzdCBhbnlPZiBkZWZpbml0aW9uc1xuICAgIGxldCBzY2hlbWEgPSBjcmVhdGVUZW1wbGF0ZVNjaGVtYShkcmFmdCwgX3NjaGVtYSwgZGF0YSwgcG9pbnRlciwgb3B0cyk7XG4gICAgaWYgKCFpc0pzb25TY2hlbWEoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwb2ludGVyID0gc2NoZW1hLnBvaW50ZXI7XG4gICAgaWYgKHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS5jb25zdCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNvbnN0O1xuICAgIH1cbiAgICAvLyBAZmVhdHVyZSBvbmVPZlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcbiAgICAgICAgaWYgKGlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEub25lT2ZbMF0udHlwZSB8fCBzY2hlbWEudHlwZSB8fCAoc2NoZW1hLmNvbnN0ICYmIHR5cGVvZiBzY2hlbWEuY29uc3QpIHx8IGdldFR5cGVPZihkYXRhKTtcbiAgICAgICAgICAgIHNjaGVtYSA9IHsgLi4uc2NoZW1hLm9uZU9mWzBdLCB0eXBlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmaW5kIGNvcnJlY3Qgc2NoZW1hIGZvciBkYXRhXG4gICAgICAgICAgICBjb25zdCBvbmVOb2RlID0gZHJhZnQuY3JlYXRlTm9kZShzY2hlbWEsIHBvaW50ZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gcmVzb2x2ZU9uZU9mRnV6enkob25lTm9kZSwgZGF0YSk7XG4gICAgICAgICAgICBpZiAoaXNKc29uRXJyb3IocmVzb2x2ZWROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9IG51bGwgJiYgb3B0cy5yZW1vdmVJbnZhbGlkRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEub25lT2ZbMF07XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gcmVzb2x2ZWROb2RlLnNjaGVtYTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFNjaGVtYS50eXBlID0gKF9hID0gcmVzb2x2ZWRTY2hlbWEudHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQHRvZG8gQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSlcbiAgICAvLyAtPiBoYXNEZWZhdWx0PyByZXR1cm5cbiAgICAvLyBpZiBub3QgLT4gcGljayBmaXJzdCB0eXBlc1xuICAgIGlmICghaXNKc29uU2NoZW1hKHNjaGVtYSkgfHwgc2NoZW1hLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBAYXR0ZW50aW9uIC0gdmVyeSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBmaWxlIGluc3RhbmNlc1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpID8gc2VsZWN0VHlwZShzY2hlbWEudHlwZSwgZGF0YSwgc2NoZW1hLmRlZmF1bHQpIDogc2NoZW1hLnR5cGU7XG4gICAgLy8gcmVzZXQgaW52YWxpZCB0eXBlXG4gICAgY29uc3QgamF2YXNjcmlwdFR5cGVPZkRhdGEgPSBnZXRUeXBlT2YoZGF0YSk7XG4gICAgaWYgKGRhdGEgIT0gbnVsbCAmJiBqYXZhc2NyaXB0VHlwZU9mRGF0YSAhPT0gdHlwZSAmJiAhKGphdmFzY3JpcHRUeXBlT2ZEYXRhID09PSBcIm51bWJlclwiICYmIHR5cGUgPT09IFwiaW50ZWdlclwiKSkge1xuICAgICAgICBkYXRhID0gY29udmVydFZhbHVlKHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgICBpZiAoVFlQRVt0eXBlXSA9PSBudWxsKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugd2UgY291bGQgbm90IHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gKHNjaGVtYS10eXBlIGNvdWxkIG5vdCBiZSByZXNvbHZlZCBhbmQgcmV0dXJuZWQgYW4gZXJyb3IpXG4gICAgICAgIGlmIChvcHRzLnJlbW92ZUludmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wbGF0ZURhdGEgPSBUWVBFW3R5cGVdKGRyYWZ0LCBzY2hlbWEsIGRhdGEsIHBvaW50ZXIsIG9wdHMpO1xuICAgIHJldHVybiB0ZW1wbGF0ZURhdGE7XG59XG5mdW5jdGlvbiBzZWxlY3RUeXBlKHR5cGVzLCBkYXRhLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZGF0YSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGdldFR5cGVPZihkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKGRlZmF1bHRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZXNbMF07XG4gICAgfVxuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2V0VHlwZU9mKGRhdGEpO1xuICAgIGlmICh0eXBlcy5pbmNsdWRlcyhkYXRhVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXNbMF07XG59XG5jb25zdCBUWVBFID0ge1xuICAgIG51bGw6IChkcmFmdCwgc2NoZW1hLCBkYXRhKSA9PiBnZXREZWZhdWx0KHNjaGVtYSwgZGF0YSwgbnVsbCksXG4gICAgc3RyaW5nOiAoZHJhZnQsIHNjaGVtYSwgZGF0YSkgPT4gZ2V0RGVmYXVsdChzY2hlbWEsIGRhdGEsIFwiXCIpLFxuICAgIG51bWJlcjogKGRyYWZ0LCBzY2hlbWEsIGRhdGEpID0+IGdldERlZmF1bHQoc2NoZW1hLCBkYXRhLCAwKSxcbiAgICBpbnRlZ2VyOiAoZHJhZnQsIHNjaGVtYSwgZGF0YSkgPT4gZ2V0RGVmYXVsdChzY2hlbWEsIGRhdGEsIDApLFxuICAgIGJvb2xlYW46IChkcmFmdCwgc2NoZW1hLCBkYXRhKSA9PiBnZXREZWZhdWx0KHNjaGVtYSwgZGF0YSwgZmFsc2UpLFxuICAgIG9iamVjdDogKGRyYWZ0LCBzY2hlbWEsIGRhdGEsIHBvaW50ZXIsIG9wdHMpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHNjaGVtYS5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyB7fSA6IHNjaGVtYS5kZWZhdWx0O1xuICAgICAgICBjb25zdCBkID0ge307IC8vIGRvIG5vdCBhc3NpZ24gZGF0YSBoZXJlLCB0byBrZWVwIG9yZGVyaW5nIGZyb20ganNvbi1zY2hlbWFcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBvcHRzLmV4dGVuZERlZmF1bHRzID09PSBmYWxzZSAmJiBzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkID8gW10gOiAoKF9hID0gc2NoZW1hLnJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YSA9PSBudWxsIHx8IGRhdGFba2V5XSA9PSBudWxsID8gdGVtcGxhdGVba2V5XSA6IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlcXVpcmVkID0gcmVxdWlyZWQuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBPbWl0IGFkZGluZyBhIHByb3BlcnR5IGlmIGl0IGlzIG5vdCByZXF1aXJlZCBvciBvcHRpb25hbCBwcm9wcyBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCB8fCBpc1JlcXVpcmVkIHx8IG9wdHMuYWRkT3B0aW9uYWxQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBkW2tleV0gPSBnZXRUZW1wbGF0ZShkcmFmdCwgdmFsdWUsIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0sIGAke3BvaW50ZXJ9L3Byb3BlcnRpZXMvJHtrZXl9YCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQGZlYXR1cmUgZGVwZW5kZW5jaWVzXG4gICAgICAgIC8vIGhhcyB0byBiZSBkb25lIGFmdGVyIHJlc29sdmluZyBwcm9wZXJ0aWVzIHNvIGRlcGVuZGVuY3kgbWF5IHRyaWdnZXJcbiAgICAgICAgY29uc3QgZE5vZGUgPSBkcmFmdC5jcmVhdGVOb2RlKHNjaGVtYSwgcG9pbnRlcik7XG4gICAgICAgIGxldCBkZXBlbmRlbmNpZXNTY2hlbWEgPSByZXNvbHZlRGVwZW5kZW5jaWVzKGROb2RlLCBkKTtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llc1NjaGVtYSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzU2NoZW1hID0gbWVyZ2VTY2hlbWEoc2NoZW1hLCBkZXBlbmRlbmNpZXNTY2hlbWEpO1xuICAgICAgICAgICAgZGVsZXRlIGRlcGVuZGVuY2llc1NjaGVtYS5kZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5RGF0YSA9IGdldFRlbXBsYXRlKGRyYWZ0LCBkYXRhLCBkZXBlbmRlbmNpZXNTY2hlbWEsIGAke3BvaW50ZXJ9L2RlcGVuZGVuY2llc2AsIG9wdHMpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkLCBkZXBlbmRlbmN5RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUludmFsaWREYXRhID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UgfHwgZ2V0VHlwZU9mKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFR5cGVPZihzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgdmFsaWQgbWlzc2luZyBkYXRhIChhZGRpdGlvbmFscykgdG8gcmVzdWx0aW5nIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFmdC5pc1ZhbGlkKGRhdGFba2V5XSwgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhbnkgbWlzc2luZyBkYXRhIChhZGRpdGlvbmFscykgdG8gcmVzdWx0aW5nIG9iamVjdFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goKGtleSkgPT4gZFtrZXldID09IG51bGwgJiYgKGRba2V5XSA9IGRhdGFba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBmZWF0dXJlIGlmLXRoZW4tZWxzZVxuICAgICAgICBjb25zdCBub2RlID0gZHJhZnQuY3JlYXRlTm9kZShzY2hlbWEsIHBvaW50ZXIpO1xuICAgICAgICBjb25zdCBpZlNjaGVtYSA9IHJlc29sdmVJZlNjaGVtYShub2RlLCBkKTtcbiAgICAgICAgaWYgKGlzU2NoZW1hTm9kZShpZlNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxEYXRhID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGQsIHsgdHlwZTogXCJvYmplY3RcIiwgLi4uaWZTY2hlbWEuc2NoZW1hIH0sIHBvaW50ZXIsIG9wdHMpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkLCBhZGRpdGlvbmFsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJucyBvYmplY3QsIHdoaWNoIGlzIG9yZGVyZWQgYnkganNvbi1zY2hlbWFcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfSxcbiAgICAvLyBidWlsZCBhcnJheSB0eXBlIG9mIGl0ZW1zLCBpZ25vcmVzIGFkZGl0aW9uYWxJdGVtc1xuICAgIGFycmF5OiAoZHJhZnQsIHNjaGVtYSwgZGF0YSwgcG9pbnRlciwgb3B0cykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBzY2hlbWEuZGVmYXVsdCA9PT0gdW5kZWZpbmVkID8gW10gOiBzY2hlbWEuZGVmYXVsdDtcbiAgICAgICAgY29uc3QgZCA9IGRhdGEgfHwgdGVtcGxhdGU7XG4gICAgICAgIGNvbnN0IG1pbkl0ZW1zID0gb3B0cy5leHRlbmREZWZhdWx0cyA9PT0gZmFsc2UgJiYgc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCA/IDAgOiAoKF9hID0gc2NoZW1hLm1pbkl0ZW1zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIGl0ZW1zLWFycmF5IHdhcyBwcm9jZXNzZWQgJiB0aGlzIGlzIG5vdCBhbiBpdGVtcy1zY2hlbWFcbiAgICAgICAgICAgICAgICAvLyA9PiBhbGwgaXRlbXMgYXJlIGFkZGl0aW9uYWxJdGVtc1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Db3VudCA9IE1hdGgubWF4KG1pbkl0ZW1zLCBkLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkW2ldID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGRbaV0sIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMsIGAke3BvaW50ZXJ9L2FkZGl0aW9uYWxJdGVtc2AsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhIHx8IFtdOyAvLyBpdGVtcyBhcmUgdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVpbGQgZGVmaW5lZCBzZXQgb2YgaXRlbXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgobWluSXRlbXMgIT09IG51bGwgJiYgbWluSXRlbXMgIT09IHZvaWQgMCA/IG1pbkl0ZW1zIDogMCwgKF9jID0gKF9iID0gc2NoZW1hLml0ZW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLml0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRbaV0gPSBnZXRUZW1wbGF0ZShkcmFmdCwgZFtpXSA9PSBudWxsID8gdGVtcGxhdGVbaV0gOiBkW2ldLCBzY2hlbWEuaXRlbXNbaV0sIGAke3BvaW50ZXJ9L2l0ZW1zLyR7aX1gLCBvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBkW2ldID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGRbaV0gPT0gbnVsbCA/IHRlbXBsYXRlW2ldIDogZFtpXSwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywgYCR7cG9pbnRlcn0vYWRkaXRpb25hbEl0ZW1zYCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gaXRlbXMtc2NoZW1hIC0gcmV0dXJuXG4gICAgICAgIGlmIChnZXRUeXBlT2Yoc2NoZW1hLml0ZW1zKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGxPZiBhbmQgZmlyc3QgYW55T2YgZGVmaW5pdGlvblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZVNjaGVtYSA9IGNyZWF0ZVRlbXBsYXRlU2NoZW1hKGRyYWZ0LCBzY2hlbWEuaXRlbXMsIGRhdGEsIHBvaW50ZXIsIG9wdHMpO1xuICAgICAgICBpZiAodGVtcGxhdGVTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICBwb2ludGVyID0gdGVtcGxhdGVTY2hlbWEucG9pbnRlciB8fCBwb2ludGVyO1xuICAgICAgICAvLyBidWlsZCBkYXRhIGZvciBmaXJzdCBvbmVPZi1zY2hlbWFcbiAgICAgICAgaWYgKHRlbXBsYXRlU2NoZW1hLm9uZU9mICYmIGQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVPZlNjaGVtYSA9IHRlbXBsYXRlU2NoZW1hLm9uZU9mWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5JdGVtczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZFtpXSA9IGdldFRlbXBsYXRlKGRyYWZ0LCBkW2ldID09IG51bGwgPyB0ZW1wbGF0ZVtpXSA6IGRbaV0sIG9uZU9mU2NoZW1hLCBgJHtwb2ludGVyfS9vbmVPZi8wYCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wbGV0ZSBkYXRhIHNlbGVjdGluZyBjb3JyZWN0IG9uZU9mLXNjaGVtYVxuICAgICAgICBpZiAodGVtcGxhdGVTY2hlbWEub25lT2YgJiYgZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQ291bnQgPSBNYXRoLm1heChtaW5JdGVtcywgZC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRbaV0gPT0gbnVsbCA/IHRlbXBsYXRlW2ldIDogZFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmVOb2RlID0gZHJhZnQuY3JlYXRlTm9kZSh0ZW1wbGF0ZVNjaGVtYSwgcG9pbnRlcik7XG4gICAgICAgICAgICAgICAgbGV0IG9uZSA9IHJlc29sdmVPbmVPZkZ1enp5KG9uZU5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAob25lID09IG51bGwgfHwgaXNKc29uRXJyb3Iob25lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWEgY291bGQgbm90IGJlIHJlc29sdmVkIG9yIGRhdGEgaXMgaW52YWxpZFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvcHRzLnJlbW92ZUludmFsaWREYXRhICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGludmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgaW52YWxpZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmUgPSB0ZW1wbGF0ZVNjaGVtYS5vbmVPZlswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRbaV0gPSBnZXRUZW1wbGF0ZShkcmFmdCwgdmFsdWUsIG9uZSwgYCR7cG9pbnRlcn0vb25lT2YvJHtpfWAsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWEgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgZFtpXSA9IGdldFRlbXBsYXRlKGRyYWZ0LCB2YWx1ZSwgb25lLnNjaGVtYSwgYCR7cG9pbnRlcn0vb25lT2YvJHtpfWAsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIGRhdGEgZnJvbSBpdGVtcy1kZWZpbml0aW9uXG4gICAgICAgIGlmICh0ZW1wbGF0ZVNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KG1pbkl0ZW1zLCBkLmxlbmd0aCk7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBkW2ldID0gZ2V0VGVtcGxhdGUoZHJhZnQsIGRbaV0gPT0gbnVsbCA/IHRlbXBsYXRlW2ldIDogZFtpXSwgdGVtcGxhdGVTY2hlbWEsIGAke3BvaW50ZXJ9L2l0ZW1zYCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEsIHRlbXBsYXRlVmFsdWUsIGluaXRWYWx1ZSkge1xuICAgIGlmICh0ZW1wbGF0ZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYS5jb25zdCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNvbnN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEuZGVmYXVsdCA9PT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZW51bVswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5pdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLmRlZmF1bHQ7XG59XG5leHBvcnQgZGVmYXVsdCAoZHJhZnQsIGRhdGEsIHNjaGVtYSA9IGRyYWZ0LnJvb3RTY2hlbWEsIG9wdHMpID0+IHtcbiAgICBjYWNoZSA9IHt9O1xuICAgIGlmIChvcHRzKSB7XG4gICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZShkcmFmdCwgZGF0YSwgc2NoZW1hLCBcIiNcIiwgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFRlbXBsYXRlKGRyYWZ0LCBkYXRhLCBzY2hlbWEsIFwiI1wiLCBkZWZhdWx0T3B0aW9ucyk7XG59O1xuIiwiLyoqXG4gKiBUZXN0IGlmIHRoZSBkYXRhIGlzIHZhbGlkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gc2NoZW1hXG4gKlxuICogQHBhcmFtIGRyYWZ0IC0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIFtzY2hlbWFdIC0ganNvbiBzY2hlbWFcbiAqIEBwYXJhbSBbcG9pbnRlcl0gLSBqc29uIHBvaW50ZXIgcG9pbnRpbmcgdG8gdmFsdWVcbiAqIEByZXR1cm4gaWYgc2NoZW1hIGRvZXMgbWF0Y2ggZ2l2ZW4gdmFsdWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNWYWxpZChkcmFmdCwgdmFsdWUsIHNjaGVtYSA9IGRyYWZ0LnJvb3RTY2hlbWEsIHBvaW50ZXIgPSBcIiNcIikge1xuICAgIGNvbnN0IG5vZGUgPSBkcmFmdC5jcmVhdGVOb2RlKHNjaGVtYSwgcG9pbnRlcik7XG4gICAgcmV0dXJuIGRyYWZ0LnZhbGlkYXRlKG5vZGUsIHZhbHVlKS5sZW5ndGggPT09IDA7XG59XG4iLCIvKiBlc2xpbnQgbm8tYml0d2lzZTogMCAqL1xuLyoqXG4gKiB0YWtlbiBmcm9tIHB1bnljb2RlQDIuMS4wXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweGZjMDApID09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIC8vIExvdyBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M2ZmKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNmZikgKyAweDEwMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyoqXG4gKiByZXR1cm5zIHRoZSBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gb2YgYSBkZWNpbWFsIG51bWJlciBvciAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVjaXNpb24odmFsdWUpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBgJHt2YWx1ZX1gO1xuICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoXCJlLVwiKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoLy4qZS0vLCBcIlwiKSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gc3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyAwIDogc3RyaW5nLmxlbmd0aCAtIChpbmRleCArIDEpO1xufVxuIiwiaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi4vZ2V0VHlwZU9mXCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4uL2NvbmZpZy9zZXR0aW5nc1wiO1xuaW1wb3J0IHVjczJkZWNvZGUgZnJvbSBcIi4uL3V0aWxzL3B1bnljb2RlLnVjczJkZWNvZGVcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4uL3V0aWxzL2lzT2JqZWN0XCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVBbGxPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbGxPZlwiO1xuaW1wb3J0IHsgdmFsaWRhdGVBbnlPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgdmFsaWRhdGVEZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi4vZmVhdHVyZXMvZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZU9uZU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgeyBnZXRQcmVjaXNpb24gfSBmcm9tIFwiLi4vdXRpbHMvZ2V0UHJlY2lzaW9uXCI7XG5pbXBvcnQgZGVlcEVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIjtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc1Byb3BlcnR5ID0gKHZhbHVlLCBwcm9wZXJ0eSkgPT4gISh2YWx1ZVtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcHJvcGVydHkpKTtcbi8vIGxpc3Qgb2YgdmFsaWRhdGlvbiBrZXl3b3JkczogaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjVcbmNvbnN0IEtleXdvcmRWYWxpZGF0aW9uID0ge1xuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB0cnVlIHx8IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRUeXBlT2Yoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBhcnJhbmdlbWVudCB3aXRoIHBhdHRlcm5Qcm9wZXJ0aWVzLiBwYXR0ZXJuUHJvcGVydGllcyB2YWxpZGF0ZSBiZWZvcmUgYWRkaXRpb25hbFByb3BlcnRpZXM6XG4gICAgICAgICAgICAvLyBodHRwczovL3NwYWNldGVsZXNjb3BlLmdpdGh1Yi5pby91bmRlcnN0YW5kaW5nLWpzb24tc2NoZW1hL3JlZmVyZW5jZS9vYmplY3QuaHRtbCNpbmRleC01XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBsZXQgcmVjZWl2ZWRQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcigocHJvcCkgPT4gc2V0dGluZ3MucHJvcGVydHlCbGFja2xpc3QuaW5jbHVkZXMocHJvcCkgPT09IGZhbHNlKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMgfHwge30pO1xuICAgICAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciByZWNlaXZlZCBwcm9wZXJ0aWVzIGJ5IG1hdGNoaW5nIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJucyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykubWFwKChwYXR0ZXJuKSA9PiBuZXcgUmVnRXhwKHBhdHRlcm4pKTtcbiAgICAgICAgICAgIHJlY2VpdmVkUHJvcGVydGllcyA9IHJlY2VpdmVkUHJvcGVydGllcy5maWx0ZXIoKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuc1tpXS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkcyBhbiBlcnJvciBmb3IgZWFjaCBhbiB1bmV4cGVjdGVkIHByb3BlcnR5XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcmVjZWl2ZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSByZWNlaXZlZFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxJc09iamVjdCA9IGlzT2JqZWN0KHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgeyBvbmVPZjogW10gfVxuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsSXNPYmplY3QgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMub25lT2YpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRyYWZ0LnJlc29sdmVPbmVPZihub2RlLm5leHQoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSwgdmFsdWVbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSnNvbkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy5hZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiByZWNlaXZlZFByb3BlcnRpZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZXhwZWN0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgYWxsIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiByZXN1bHQuZGF0YS5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChyZXN1bHQsIHByb3BlcnR5KSwgdmFsdWVbcHJvcGVydHldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWRkaXRpb25hbElzT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIHByb3BlcnR5KSwgdmFsdWVbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy5ub0FkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHJlY2VpdmVkUHJvcGVydGllc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGV4cGVjdGVkUHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSxcbiAgICBhbGxPZjogdmFsaWRhdGVBbGxPZixcbiAgICBhbnlPZjogdmFsaWRhdGVBbnlPZixcbiAgICBkZXBlbmRlbmNpZXM6IHZhbGlkYXRlRGVwZW5kZW5jaWVzLFxuICAgIGVudW06IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlT2YodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlU3RyID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuZW51bS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShzY2hlbWEuZW51bVtpXSkgPT09IHZhbHVlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5lbnVtLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmVudW1FcnJvcih7IHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUsIHZhbHVlczogc2NoZW1hLmVudW0gfSk7XG4gICAgfSxcbiAgICBmb3JtYXQ6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEgfSA9IG5vZGU7XG4gICAgICAgIGlmIChkcmFmdC52YWxpZGF0ZUZvcm1hdFtzY2hlbWEuZm9ybWF0XSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZHJhZnQudmFsaWRhdGVGb3JtYXRbc2NoZW1hLmZvcm1hdF0obm9kZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWlsIHNpbGVudGx5IGlmIGdpdmVuIGZvcm1hdCBpcyBub3QgZGVmaW5lZFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgaXRlbXM6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIC8vIEBkcmFmdCA+PSA3IGJvb2wgc2NoZW1hXG4gICAgICAgIGlmIChzY2hlbWEuaXRlbXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuaW52YWxpZERhdGFFcnJvcih7IHBvaW50ZXIsIHZhbHVlLCBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhID0gdmFsdWVbaV07XG4gICAgICAgICAgICAvLyBAdG9kbyByZWV2YWx1YXRlOiBpbmNvbXBsZXRlIHNjaGVtYSBpcyBjcmVhdGVkIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gZHJhZnQuc3RlcChub2RlLm5leHQoc2NoZW1hKSwgaSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzSnNvbkVycm9yKGl0ZW1Ob2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbaXRlbU5vZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbUVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKGl0ZW1Ob2RlLCBpdGVtRGF0YSk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5pdGVtRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgbWF4aW11bTogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5tYXhpbXVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm1heGltdW0gJiYgc2NoZW1hLm1heGltdW0gPCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhpbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5tYXhpbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWF4aW11bSAmJiBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gdHJ1ZSAmJiBzY2hlbWEubWF4aW11bSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWF4aW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBzY2hlbWEubWF4aW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWF4SXRlbXM6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWF4SXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWF4SXRlbXMgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWF4SXRlbXNFcnJvcih7XG4gICAgICAgICAgICAgICAgbWF4aW11bTogc2NoZW1hLm1heEl0ZW1zLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwb2ludGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWF4TGVuZ3RoOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLm1heExlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoT2ZTdHJpbmcgPSB1Y3MyZGVjb2RlKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChzY2hlbWEubWF4TGVuZ3RoIDwgbGVuZ3RoT2ZTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWF4TGVuZ3RoRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heExlbmd0aDogc2NoZW1hLm1heExlbmd0aCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aE9mU3RyaW5nLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWF4UHJvcGVydGllczogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlDb3VudCA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWF4UHJvcGVydGllcykgPT09IGZhbHNlICYmIHNjaGVtYS5tYXhQcm9wZXJ0aWVzIDwgcHJvcGVydHlDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhQcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heFByb3BlcnRpZXM6IHNjaGVtYS5tYXhQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogcHJvcGVydHlDb3VudCxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1pbkxlbmd0aDogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5taW5MZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aE9mU3RyaW5nID0gdWNzMmRlY29kZSh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICBpZiAoc2NoZW1hLm1pbkxlbmd0aCA+IGxlbmd0aE9mU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLm1pbkxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluTGVuZ3RoT25lRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IHNjaGVtYS5taW5MZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoT2ZTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluTGVuZ3RoRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1pbkxlbmd0aDogc2NoZW1hLm1pbkxlbmd0aCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aE9mU3RyaW5nLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWluaW11bTogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5taW5pbXVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm1pbmltdW0gPiB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taW5pbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1pbmltdW06IHNjaGVtYS5taW5pbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSA9PT0gdHJ1ZSAmJiBzY2hlbWEubWluaW11bSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluaW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBzY2hlbWEubWluaW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWluSXRlbXM6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWluSXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWluSXRlbXMgPiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEubWluSXRlbXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1pbkl0ZW1zT25lRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtaW5JdGVtczogc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taW5JdGVtc0Vycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5JdGVtczogc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbWluUHJvcGVydGllczogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKGlzTmFOKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0eUNvdW50ID0gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVtYS5taW5Qcm9wZXJ0aWVzID4gcHJvcGVydHlDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taW5Qcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1pblByb3BlcnRpZXM6IHNjaGVtYS5taW5Qcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogcHJvcGVydHlDb3VudCxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG11bHRpcGxlT2Y6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubXVsdGlwbGVPZikgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlUHJlY2lzaW9uID0gZ2V0UHJlY2lzaW9uKHZhbHVlKTtcbiAgICAgICAgY29uc3QgbXVsdGlwbGVQcmVjaXNpb24gPSBnZXRQcmVjaXNpb24oc2NoZW1hLm11bHRpcGxlT2YpO1xuICAgICAgICBpZiAodmFsdWVQcmVjaXNpb24gPiBtdWx0aXBsZVByZWNpc2lvbikge1xuICAgICAgICAgICAgLy8gdmFsdWUgd2l0aCBoaWdoZXIgcHJlY2lzaW9uIHRoZW4gbXVsdGlwbGVPZi1wcmVjaXNpb24gY2FuIG5ldmVyIGJlIG11bHRpcGxlXG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm11bHRpcGxlT2ZFcnJvcih7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogc2NoZW1hLm11bHRpcGxlT2YsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBtdWx0aXBsZVByZWNpc2lvbik7XG4gICAgICAgIGNvbnN0IHZhbCA9IE1hdGgucm91bmQodmFsdWUgKiBwcmVjaXNpb24pO1xuICAgICAgICBjb25zdCBtdWx0aXBsZSA9IE1hdGgucm91bmQoc2NoZW1hLm11bHRpcGxlT2YgKiBwcmVjaXNpb24pO1xuICAgICAgICBpZiAoKHZhbCAlIG11bHRpcGxlKSAvIHByZWNpc2lvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tdWx0aXBsZU9mRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IHNjaGVtYS5tdWx0aXBsZU9mLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXliZSBhbHNvIGNoZWNrIG92ZXJmbG93XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTUzNjcvY2F0Y2gtYW5kLWNvbXB1dGUtb3ZlcmZsb3ctZHVyaW5nLW11bHRpcGxpY2F0aW9uLW9mLXR3by1sYXJnZS1pbnRlZ2Vyc1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbm90OiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgaWYgKGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChzY2hlbWEubm90KSwgdmFsdWUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLm5vdEVycm9yKHsgdmFsdWUsIG5vdDogc2NoZW1hLm5vdCwgcG9pbnRlciwgc2NoZW1hIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgb25lT2Y6IHZhbGlkYXRlT25lT2YsXG4gICAgcGF0dGVybjogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoc2NoZW1hLnBhdHRlcm4sIFwidVwiKTtcbiAgICAgICAgaWYgKHBhdHRlcm4udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLnBhdHRlcm5FcnJvcih7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogc2NoZW1hLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYS5wYXR0ZXJuRXhhbXBsZSB8fCBzY2hlbWEucGF0dGVybixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogdmFsdWUsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBwYXR0ZXJuUHJvcGVydGllczogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICBjb25zdCBwcCA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcztcbiAgICAgICAgaWYgKGdldFR5cGVPZihwcCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gT2JqZWN0LmtleXMocHApLm1hcCgoZXhwcikgPT4gKHtcbiAgICAgICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKGV4cHIpLFxuICAgICAgICAgICAgcGF0dGVyblNjaGVtYTogcHBbZXhwcl1cbiAgICAgICAgfSkpO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybnNbaV0ucmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbEVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChwYXR0ZXJuc1tpXS5wYXR0ZXJuU2NoZW1hLCBrZXkpLCB2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbEVycm9ycyAmJiB2YWxFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0dGVybkZvdW5kID09PSBmYWxzZSAmJiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBhcnJhbmdlbWVudCB3aXRoIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLnBhdHRlcm5Qcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5zOiBPYmplY3Qua2V5cyhwcCkuam9pbihcIixcIilcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgcHJvcGVydGllczogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyB8fCB7fSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wZXJ0eSh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gZHJhZnQuc3RlcChub2RlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNKc29uRXJyb3IoaXRlbU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGl0ZW1Ob2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKGl0ZW1Ob2RlLCB2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ua2V5RXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9LFxuICAgIC8vIEB0b2RvIG1vdmUgdG8gc2VwYXJhdGUgZmlsZTogdGhpcyBpcyBjdXN0b20ga2V5d29yZCB2YWxpZGF0aW9uIGZvciBKc29uRWRpdG9yLnByb3BlcnRpZXMga2V5d29yZFxuICAgIHByb3BlcnRpZXNSZXF1aXJlZDogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyB8fCB7fSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkcmFmdC5lcnJvcnMucmVxdWlyZWRQcm9wZXJ0eUVycm9yKHsga2V5LCBwb2ludGVyLCBzY2hlbWEsIHZhbHVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gZHJhZnQuc3RlcChub2RlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlFcnJvcnMgPSBkcmFmdC52YWxpZGF0ZShpdGVtTm9kZSwgdmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ua2V5RXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgcmVxdWlyZWQ6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEucmVxdWlyZWQubWFwKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wZXJ0eSh2YWx1ZSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5yZXF1aXJlZFByb3BlcnR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIEB0b2RvIG1vdmUgdG8gc2VwYXJhdGUgZmlsZTogdGhpcyBpcyBjdXN0b20ga2V5d29yZCB2YWxpZGF0aW9uIGZvciBKc29uRWRpdG9yLnJlcXVpcmVkIGtleXdvcmRcbiAgICByZXF1aXJlZE5vdEVtcHR5OiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IG5vZGU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEucmVxdWlyZWQubWFwKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICAgICAgaWYgKHZhbHVlW3Byb3BlcnR5XSA9PSBudWxsIHx8IHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMudmFsdWVOb3RFbXB0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXI6IGAke3BvaW50ZXJ9LyR7cHJvcGVydHl9YCxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmlxdWVJdGVtczogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBzY2hlbWEudW5pcXVlSXRlbXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkdXBsaWNhdGVzID0gW107XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZXBFcXVhbChpdGVtLCB2YWx1ZVtpXSkgJiYgIWR1cGxpY2F0ZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLnVuaXF1ZUl0ZW1zRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcjogYCR7cG9pbnRlcn0vJHtpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVQb2ludGVyOiBgJHtwb2ludGVyfS8ke2luZGV4fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVBvaW50ZXI6IHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgS2V5d29yZFZhbGlkYXRpb247XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IGNyZWF0ZVNjaGVtYU9mIGZyb20gXCIuL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgeyBpc0pzb25FcnJvciB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyByZWR1Y2VTY2hlbWEgfSBmcm9tIFwiLi9yZWR1Y2VTY2hlbWFcIjtcbmNvbnN0IHN0ZXBUeXBlID0ge1xuICAgIGFycmF5OiAobm9kZSwga2V5LCBkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgaXRlbVZhbHVlID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhW2tleV07XG4gICAgICAgIGNvbnN0IGl0ZW1zVHlwZSA9IGdldFR5cGVPZihzY2hlbWEuaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXNUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBAc3BlYzogaWdub3JlIGFkZGl0aW9uYWxJdGVtcywgd2hlbiBpdGVtcyBpcyBzY2hlbWEtb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlU2NoZW1hKG5vZGUubmV4dChzY2hlbWEuaXRlbXMsIGtleSksIGl0ZW1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1zVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAvLyBAZHJhZnQgPj0gNyBib29sIHNjaGVtYSwgaXRlbXM6W3RydWUsIGZhbHNlXVxuICAgICAgICAgICAgaWYgKHNjaGVtYS5pdGVtc1trZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubmV4dChjcmVhdGVTY2hlbWFPZihpdGVtVmFsdWUpLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQGRyYWZ0ID49IDcgYm9vbCBzY2hlbWEsIGl0ZW1zOlt0cnVlLCBmYWxzZV1cbiAgICAgICAgICAgIGlmIChzY2hlbWEuaXRlbXNba2V5XSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLmludmFsaWREYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS5pdGVtc1trZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LnJlc29sdmVSZWYobm9kZS5uZXh0KHNjaGVtYS5pdGVtc1trZXldLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuYWRkaXRpb25hbEl0ZW1zRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHRydWUgfHwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubmV4dChjcmVhdGVTY2hlbWFPZihpdGVtVmFsdWUpLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFR5cGVPZihzY2hlbWEuYWRkaXRpb25hbEl0ZW1zKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5leHQoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWEgJHtKU09OLnN0cmluZ2lmeShzY2hlbWEsIG51bGwsIDIpfSBmb3IgJHtKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyAhPT0gZmFsc2UgJiYgaXRlbVZhbHVlKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyByZWV2YWx1YXRlOiBpbmNvbXBsZXRlIHNjaGVtYSBpcyBjcmVhdGVkIGhlcmVcbiAgICAgICAgICAgIC8vIEB0b2RvIHN1cHBvcnQgYWRkaXRpb25hbEl0ZW1zOiB7c2NoZW1hfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUubmV4dChjcmVhdGVTY2hlbWFPZihpdGVtVmFsdWUpLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgc2NoZW1hIGZvciAke2tleX0gYXQgJHtwb2ludGVyfWApO1xuICAgIH0sXG4gICAgb2JqZWN0OiAobm9kZSwga2V5LCBkYXRhKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHJlZHVjdGlvbiA9IHJlZHVjZVNjaGVtYShub2RlLCBkYXRhKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKChfYSA9IHJlZHVjdGlvbi5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlZHVjdGlvbik7XG4gICAgICAgIC8vIEBmZWF0dXJlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSAoX2IgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEucHJvcGVydGllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2tleV07XG4gICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyBwYXR0ZXJuUHJvcGVydGllcyBhbHNvIHZhbGlkYXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIEBmZWF0dXJlIGJvb2xlYW4gc2NoZW1hXG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5mb3JiaWRkZW5Qcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0KGNyZWF0ZVNjaGVtYU9mKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YVtrZXldKSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRQcm9wZXJ0eU5vZGUgPSBkcmFmdC5yZXNvbHZlUmVmKG5vZGUubmV4dChwcm9wZXJ0eSwga2V5KSk7XG4gICAgICAgICAgICBpZiAoaXNKc29uRXJyb3IobmV4dFByb3BlcnR5Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFByb3BlcnR5Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgb25lT2Ygc2VsZWN0aW9uLCB3aGljaCBtdXN0IGJlIHJlc29sdmVkXG4gICAgICAgICAgICBpZiAobmV4dFByb3BlcnR5Tm9kZSAmJiBBcnJheS5pc0FycmF5KG5leHRQcm9wZXJ0eU5vZGUuc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICAgICAgICAgIC8vIEBzcGVjaWFsIGNhc2U6IHRoaXMgaXMgYSBtaXggb2YgYSBzY2hlbWEgYW5kIG9wdGlvbmFsIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2UgcmVzb2x2ZSB0aGUgc2NoZW1hIGhlcmUgYW5kIGFkZCB0aGUgb3JpZ2luYWwgc2NoZW1hIHRvIGBvbmVPZlNjaGVtYWBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUubmV4dChuZXh0UHJvcGVydHlOb2RlLnNjaGVtYSwga2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkcmFmdC5yZXNvbHZlT25lT2YobmV4dE5vZGUsIGRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSnNvbkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlLm1lcmdlKHJlc3VsdC5zY2hlbWEsIFwib25lT2ZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFByb3BlcnR5Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UHJvcGVydHlOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBmZWF0dXJlIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHsgcGF0dGVyblByb3BlcnRpZXMgfSA9IHNjaGVtYTtcbiAgICAgICAgaWYgKGdldFR5cGVPZihwYXR0ZXJuUHJvcGVydGllcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgcHJvcGVydHkga2V5XG4gICAgICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJucyA9IE9iamVjdC5rZXlzKHBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm5zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5leHQocGF0dGVyblByb3BlcnRpZXNbcGF0dGVybnNbaV1dLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAZmVhdHVyZSBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgICAgICBjb25zdCB7IGFkZGl0aW9uYWxQcm9wZXJ0aWVzIH0gPSBzY2hlbWE7XG4gICAgICAgIGlmIChnZXRUeXBlT2YoYWRkaXRpb25hbFByb3BlcnRpZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0KHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAmJiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCB8fCBhZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFNjaGVtYSA9IGNyZWF0ZVNjaGVtYU9mKGRhdGFba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkU2NoZW1hID8gbm9kZS5uZXh0KGdlbmVyYXRlZFNjaGVtYSwga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLnVua25vd25Qcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgIHBvaW50ZXI6IGAke3BvaW50ZXJ9YCxcbiAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBqc29uLXNjaGVtYSBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHByb3BlcnR5IG9yIGFycmF5IGl0ZW0uXG4gKiBlLmcuIGl0IHN0ZXBzIGJ5IG9uZSBrZXkgaW50byB0aGUgZGF0YVxuICpcbiAqICBUaGlzIGhlbHBlciBkZXRlcm1pbmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgcHJvcGVydHkgd2l0aGluIHRoZSBzY2hlbWEgKGFkZGl0aW9uYWwgcHJvcGVydGllcywgb25lT2YsIC4uLikgYW5kXG4gKiAgcmV0dXJucyB0aGUgY29ycmVjdCBzY2hlbWEuXG4gKlxuICogQHBhcmFtICBkcmFmdCAgICAgIC0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gIGtleSAgICAgICAtIHByb3BlcnR5LW5hbWUgb3IgYXJyYXktaW5kZXhcbiAqIEBwYXJhbSAgc2NoZW1hICAgIC0ganNvbiBzY2hlbWEgb2YgY3VycmVudCBkYXRhXG4gKiBAcGFyYW0gIGRhdGEgICAgICAtIHBhcmVudCBvZiBrZXlcbiAqIEBwYXJhbSAgW3BvaW50ZXJdIC0gcG9pbnRlciB0byBzY2hlbWEgYW5kIGRhdGEgKHBhcmVudCBvZiBrZXkpXG4gKiBAcmV0dXJuIFNjaGVtYSBvciBFcnJvciBpZiBmYWlsZWQgcmVzb2x2aW5nIGtleVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGVwKG5vZGUsIGtleSwgZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgY29uc3QgdHlwZU9mRGF0YSA9IGdldFR5cGVPZihkYXRhKTtcbiAgICBsZXQgc2NoZW1hVHlwZSA9IChfYSA9IHNjaGVtYS50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlT2ZEYXRhO1xuICAgIC8vIEBkcmFmdCA+PSA0ID9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSkge1xuICAgICAgICBpZiAoIXNjaGVtYVR5cGUuaW5jbHVkZXModHlwZU9mRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMudHlwZUVycm9yKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBzY2hlbWEudHlwZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogdHlwZU9mRGF0YSxcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYVR5cGUgPSB0eXBlT2ZEYXRhO1xuICAgIH1cbiAgICBjb25zdCBzdGVwRnVuY3Rpb24gPSBzdGVwVHlwZVtzY2hlbWFUeXBlXTtcbiAgICBpZiAoc3RlcEZ1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHN0ZXBGdW5jdGlvbihub2RlLCBgJHtrZXl9YCwgZGF0YSk7XG4gICAgICAgIGlmIChjaGlsZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5zY2hlbWFXYXJuaW5nKHsgcG9pbnRlciwgdmFsdWU6IGRhdGEsIHNjaGVtYSwga2V5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNjaGVtYSB0eXBlICR7c2NoZW1hLnR5cGV9IGZvciBrZXkgJHtrZXl9YCk7XG59XG4iLCIvKipcbiAqIEB0b2RvOiB0eXBlIGlzIGFsc28gYSBrZXl3b3JkLCBhcyBpcyBwcm9wZXJ0aWVzLCBpdGVtcywgZXRjXG4gKlxuICogQW4gaW5zdGFuY2UgaGFzIG9uZSBvZiBzaXggcHJpbWl0aXZlIHR5cGVzIChodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS1ub2RlLmRyYWZ0Lmh0bWwjcmZjLnNlY3Rpb24uNC4yKVxuICogb3Igc2V2ZW4gaW4gY2FzZSBvZiBhanYgaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Fqdi9ibG9iL21hc3Rlci9LRVlXT1JEUy5tZCN0eXBlXG4gKiAxIG51bGwsIDIgYm9vbGVhbiwgMyBvYmplY3QsIDQgYXJyYXksIDUgbnVtYmVyLCA2IHN0cmluZyAoNyBpbnRlZ2VyKVxuICovXG5jb25zdCB0eXBlVmFsaWRhdG9ycyA9IHtcbiAgICBhcnJheTogKG5vZGUsIHZhbHVlKSA9PiBub2RlLmRyYWZ0LnR5cGVLZXl3b3Jkcy5hcnJheVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IG5vZGUuc2NoZW1hICYmIG5vZGUuc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBub2RlLmRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKG5vZGUsIHZhbHVlKSksXG4gICAgb2JqZWN0OiAobm9kZSwgdmFsdWUpID0+IG5vZGUuZHJhZnQudHlwZUtleXdvcmRzLm9iamVjdFxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IG5vZGUuc2NoZW1hICYmIG5vZGUuc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBub2RlLmRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKG5vZGUsIHZhbHVlKSksXG4gICAgc3RyaW5nOiAobm9kZSwgdmFsdWUpID0+IG5vZGUuZHJhZnQudHlwZUtleXdvcmRzLnN0cmluZ1xuICAgICAgICAuZmlsdGVyKChrZXkpID0+IG5vZGUuc2NoZW1hICYmIG5vZGUuc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBub2RlLmRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKG5vZGUsIHZhbHVlKSksXG4gICAgaW50ZWdlcjogKG5vZGUsIHZhbHVlKSA9PiBub2RlLmRyYWZ0LnR5cGVLZXl3b3Jkcy5udW1iZXJcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBub2RlLnNjaGVtYSAmJiBub2RlLnNjaGVtYVtrZXldICE9IG51bGwpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gbm9kZS5kcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShub2RlLCB2YWx1ZSkpLFxuICAgIG51bWJlcjogKG5vZGUsIHZhbHVlKSA9PiBub2RlLmRyYWZ0LnR5cGVLZXl3b3Jkcy5udW1iZXJcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBub2RlLnNjaGVtYSAmJiBub2RlLnNjaGVtYVtrZXldICE9IG51bGwpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gbm9kZS5kcmFmdC52YWxpZGF0ZUtleXdvcmRba2V5XShub2RlLCB2YWx1ZSkpLFxuICAgIGJvb2xlYW46IChub2RlLCB2YWx1ZSkgPT4gbm9kZS5kcmFmdC50eXBlS2V5d29yZHMuYm9vbGVhblxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IG5vZGUuc2NoZW1hICYmIG5vZGUuc2NoZW1hW2tleV0gIT0gbnVsbClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBub2RlLmRyYWZ0LnZhbGlkYXRlS2V5d29yZFtrZXldKG5vZGUsIHZhbHVlKSksXG4gICAgbnVsbDogKG5vZGUsIHZhbHVlKSA9PiBub2RlLmRyYWZ0LnR5cGVLZXl3b3Jkcy5udWxsXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4gbm9kZS5zY2hlbWEgJiYgbm9kZS5zY2hlbWFba2V5XSAhPSBudWxsKVxuICAgICAgICAubWFwKChrZXkpID0+IG5vZGUuZHJhZnQudmFsaWRhdGVLZXl3b3JkW2tleV0obm9kZSwgdmFsdWUpKVxufTtcbmV4cG9ydCBkZWZhdWx0IHR5cGVWYWxpZGF0b3JzO1xuIiwiaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi9nZXRUeXBlT2ZcIjtcbmltcG9ydCB7IGVycm9yT3JQcm9taXNlIH0gZnJvbSBcIi4vdXRpbHMvZmlsdGVyXCI7XG5pbXBvcnQgZmxhdHRlbkFycmF5IGZyb20gXCIuL3V0aWxzL2ZsYXR0ZW5BcnJheVwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgaXNTY2hlbWFOb2RlIH0gZnJvbSBcIi4vc2NoZW1hTm9kZVwiO1xuaW1wb3J0IGVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIjtcbmZ1bmN0aW9uIGdldEpzb25TY2hlbWFUeXBlKHZhbHVlLCBleHBlY3RlZFR5cGUpIHtcbiAgICBjb25zdCBqc1R5cGUgPSBnZXRUeXBlT2YodmFsdWUpO1xuICAgIGlmIChqc1R5cGUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgKGV4cGVjdGVkVHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZSkgJiYgZXhwZWN0ZWRUeXBlLmluY2x1ZGVzKFwiaW50ZWdlclwiKSkpKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCBpc05hTih2YWx1ZSkgPyBcImludGVnZXJcIiA6IFwibnVtYmVyXCI7XG4gICAgfVxuICAgIHJldHVybiBqc1R5cGU7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBkYXRhIHdpdGgganNvbiBzY2hlbWFcbiAqXG4gKiBAcGFyYW0gZHJhZnQgLSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gW3NjaGVtYV0gLSBqc29uIHNjaGVtYSwgZGVmYXVsdHMgdG8gcm9vdFNjaGVtYVxuICogQHBhcmFtIFtwb2ludGVyXSAtIGpzb24gcG9pbnRlciBwb2ludGluZyB0byB2YWx1ZSAodXNlZCBmb3IgZXJyb3ItbWVzc2FnZXMgb25seSlcbiAqIEByZXR1cm4gbGlzdCBvZiBlcnJvcnMgb3IgZW1wdHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzU2NoZW1hTm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIGV4cGVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGRyYWZ0LCBwb2ludGVyIH0gPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLnJlc29sdmVSZWYoKTtcbiAgICBjb25zdCBzY2hlbWEgPSBub2RlLnNjaGVtYTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzY2hlbWFcIik7XG4gICAgfVxuICAgIC8vIEBkcmFmdCA+PSAwN1xuICAgIGlmIChnZXRUeXBlT2Yoc2NoZW1hKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZHJhZnQuZXJyb3JzLmludmFsaWREYXRhRXJyb3IoeyBwb2ludGVyLCBzY2hlbWEsIHZhbHVlIH0pXTtcbiAgICB9XG4gICAgaWYgKGlzSnNvbkVycm9yKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIFtzY2hlbWFdO1xuICAgIH1cbiAgICAvLyBAZHJhZnQgPj0gNiBjb25zdFxuICAgIGlmIChzY2hlbWEuY29uc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZXF1YWwoc2NoZW1hLmNvbnN0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2RyYWZ0LmVycm9ycy5jb25zdEVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCB2YWx1ZSwgZXhwZWN0ZWQ6IHNjaGVtYS5jb25zdCB9KV07XG4gICAgfVxuICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IGdldEpzb25TY2hlbWFUeXBlKHZhbHVlLCBzY2hlbWEudHlwZSk7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gc2NoZW1hLnR5cGUgfHwgcmVjZWl2ZWRUeXBlO1xuICAgIGlmIChyZWNlaXZlZFR5cGUgIT09IGV4cGVjdGVkVHlwZSAmJlxuICAgICAgICAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlKSB8fCAhZXhwZWN0ZWRUeXBlLmluY2x1ZGVzKHJlY2VpdmVkVHlwZSkpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkcmFmdC5lcnJvcnMudHlwZUVycm9yKHtcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogcmVjZWl2ZWRUeXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFR5cGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmIChkcmFmdC52YWxpZGF0ZVR5cGVbcmVjZWl2ZWRUeXBlXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbZHJhZnQuZXJyb3JzLmludmFsaWRUeXBlRXJyb3IoeyBwb2ludGVyLCBzY2hlbWEsIHZhbHVlLCByZWNlaXZlZFR5cGUgfSldO1xuICAgIH1cbiAgICAvLyBnZXQgdHlwZSB2YWxpZGF0aW9uIHJlc3VsdHNcbiAgICBjb25zdCBlcnJvcnMgPSBmbGF0dGVuQXJyYXkoZHJhZnQudmFsaWRhdGVUeXBlW3JlY2VpdmVkVHlwZV0obm9kZSwgdmFsdWUpKTtcbiAgICByZXR1cm4gZXJyb3JzLmZpbHRlcihlcnJvck9yUHJvbWlzZSk7IC8vIGlnbm9yZSBwcm9taXNlcyBoZXJlXG59XG4iLCJpbXBvcnQgZ2V0VHlwZU9mIGZyb20gXCIuL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgaXNTY2hlbWFOb2RlIH0gZnJvbSBcIi4vc2NoZW1hTm9kZVwiO1xuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGRhdGEsIHJldHJpZXZpbmcgaXRzIHNjaGVtYVxuICpcbiAqIEBwYXJhbSBkcmFmdCAtIHZhbGlkYXRvclxuICogQHBhcmFtIGRhdGEgLSB0aGUgZGF0YSB0byBpdGVyYXRlXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSB3aWxsIGJlIGNhbGxlZCB3aXRoIChzY2hlbWEsIGRhdGEsIHBvaW50ZXIpIG9uIGVhY2ggaXRlbVxuICogQHBhcmFtIFtzY2hlbWFdIC0gdGhlIHNjaGVtYSBtYXRjaGluZyB0aGUgZGF0YS4gRGVmYXVsdHMgdG8gcm9vdFNjaGVtYVxuICogQHBhcmFtIFtwb2ludGVyXSAtIHBvaW50ZXIgdG8gY3VycmVudCBkYXRhLiBEZWZhdWx0IHRvIHJvb3RQb2ludGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKHNjaGVtYU5vZGUsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgbm9kZSA9IHNjaGVtYU5vZGUucmVzb2x2ZVJlZigpO1xuICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICBjYWxsYmFjayhzY2hlbWEsIGRhdGEsIHBvaW50ZXIpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2V0VHlwZU9mKGRhdGEpO1xuICAgIGlmIChkYXRhVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gZHJhZnQuc3RlcChub2RlLCBrZXksIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGlzU2NoZW1hTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKG5leHROb2RlLCBkYXRhW2tleV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKChuZXh0LCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gZHJhZnQuc3RlcChub2RlLCBrZXksIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGlzU2NoZW1hTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKG5leHROb2RlLCBkYXRhW2tleV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IGFkZFJlbW90ZVNjaGVtYSBmcm9tIFwiLi9hZGRSZW1vdGVTY2hlbWFcIjtcbmltcG9ydCBjb21waWxlU2NoZW1hIGZyb20gXCIuLi9jb21waWxlXCI7XG5pbXBvcnQgY3JlYXRlU2NoZW1hT2YgZnJvbSBcIi4uL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgRVJST1JTIGZyb20gXCIuLi92YWxpZGF0aW9uL2Vycm9yc1wiO1xuaW1wb3J0IEZPUk1BVFMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vZm9ybWF0XCI7XG5pbXBvcnQgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24gZnJvbSBcIi4uL2dldENoaWxkU2NoZW1hU2VsZWN0aW9uXCI7XG5pbXBvcnQgZ2V0U2NoZW1hIGZyb20gXCIuLi9nZXRTY2hlbWFcIjtcbmltcG9ydCBnZXRUZW1wbGF0ZSBmcm9tIFwiLi4vZ2V0VGVtcGxhdGVcIjtcbmltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkXCI7XG5pbXBvcnQgS0VZV09SRFMgZnJvbSBcIi4uL3ZhbGlkYXRpb24va2V5d29yZFwiO1xuaW1wb3J0IG1lcmdlIGZyb20gXCIuLi91dGlscy9tZXJnZVwiO1xuaW1wb3J0IHJlc29sdmVSZWYgZnJvbSBcIi4uL3Jlc29sdmVSZWYuc3RyaWN0XCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4uL2NvbmZpZy9zZXR0aW5nc1wiO1xuaW1wb3J0IHN0ZXAgZnJvbSBcIi4uL3N0ZXBcIjtcbmltcG9ydCBUWVBFUyBmcm9tIFwiLi4vdmFsaWRhdGlvbi90eXBlXCI7XG5pbXBvcnQgdmFsaWRhdGUgZnJvbSBcIi4uL3ZhbGlkYXRlXCI7XG5pbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSBcIi4uL3NjaGVtYU5vZGVcIjtcbmltcG9ydCB7IERyYWZ0IH0gZnJvbSBcIi4uL2RyYWZ0XCI7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSBcIi4uL2VhY2hcIjtcbmltcG9ydCB7IGVhY2hTY2hlbWEgfSBmcm9tIFwiLi4vZWFjaFNjaGVtYVwiO1xuaW1wb3J0IHsgcmVzb2x2ZUFsbE9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL2FsbE9mXCI7XG5pbXBvcnQgeyByZXNvbHZlQW55T2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvYW55T2ZcIjtcbmltcG9ydCB7IHJlc29sdmVPbmVPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9vbmVPZlwiO1xuY29uc3QgZHJhZnQwNENvbmZpZyA9IHtcbiAgICB0eXBlS2V5d29yZHM6IHtcbiAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiLFxuICAgICAgICAgICAgXCJtYXhJdGVtc1wiLFxuICAgICAgICAgICAgXCJtaW5JdGVtc1wiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIixcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIlxuICAgICAgICBdLFxuICAgICAgICBib29sZWFuOiBbXCJlbnVtXCIsIFwibm90XCIsIFwiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcIm9uZU9mXCJdLFxuICAgICAgICBvYmplY3Q6IFtcbiAgICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgICAgICAgICBcImVudW1cIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiXG4gICAgICAgIF0sXG4gICAgICAgIHN0cmluZzogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJtYXhMZW5ndGhcIixcbiAgICAgICAgICAgIFwibWluTGVuZ3RoXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVtYmVyOiBbXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCIsXG4gICAgICAgICAgICBcImVudW1cIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICBcIm1heGltdW1cIixcbiAgICAgICAgICAgIFwibWluaW11bVwiLFxuICAgICAgICAgICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiXG4gICAgICAgIF0sXG4gICAgICAgIG51bGw6IFtcImFsbE9mXCIsIFwiYW55T2ZcIiwgXCJlbnVtXCIsIFwiZm9ybWF0XCIsIFwibm90XCIsIFwib25lT2ZcIl1cbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUsXG4gICAgdmFsaWRhdGVLZXl3b3JkOiBLRVlXT1JEUyxcbiAgICB2YWxpZGF0ZVR5cGU6IFRZUEVTLFxuICAgIHZhbGlkYXRlRm9ybWF0OiBGT1JNQVRTLFxuICAgIGVycm9yczogRVJST1JTLFxuICAgIGFkZFJlbW90ZVNjaGVtYSxcbiAgICBjb21waWxlU2NoZW1hLFxuICAgIGNyZWF0ZVNjaGVtYU9mLFxuICAgIGVhY2gsXG4gICAgZWFjaFNjaGVtYSxcbiAgICBnZXRDaGlsZFNjaGVtYVNlbGVjdGlvbixcbiAgICBnZXRTY2hlbWEsXG4gICAgZ2V0VGVtcGxhdGUsXG4gICAgaXNWYWxpZCxcbiAgICByZXNvbHZlQWxsT2YsXG4gICAgcmVzb2x2ZUFueU9mLFxuICAgIHJlc29sdmVPbmVPZixcbiAgICByZXNvbHZlUmVmLFxuICAgIHN0ZXAsXG4gICAgdmFsaWRhdGUsXG4gICAgdGVtcGxhdGVEZWZhdWx0T3B0aW9uczogc2V0dGluZ3MudGVtcGxhdGVEZWZhdWx0T3B0aW9uc1xufTtcbmNsYXNzIERyYWZ0MDQgZXh0ZW5kcyBEcmFmdCB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihtZXJnZShkcmFmdDA0Q29uZmlnLCBjb25maWcpLCBzY2hlbWEpO1xuICAgIH1cbn1cbmV4cG9ydCB7IERyYWZ0MDQsIGRyYWZ0MDRDb25maWcgfTtcbiIsIi8qKlxuICogcmVnaXN0ZXIgYSBqc29uLXNjaGVtYSB0byBiZSByZWZlcmVuY2VkIGZyb20gYW5vdGhlciBqc29uLXNjaGVtYVxuICogQHBhcmFtIHVybCAgICBiYXNlLXVybCBvZiBqc29uLXNjaGVtYSAoYWthIGlkKVxuICogQHBhcmFtIHNjaGVtYVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRSZW1vdGVTY2hlbWEoZHJhZnQsIHVybCwgc2NoZW1hKSB7XG4gICAgLy8gQGRyYWZ0ID49IDZcbiAgICBzY2hlbWEuJGlkID0gc2NoZW1hLiRpZCB8fCB1cmw7XG4gICAgZHJhZnQucmVtb3Rlc1t1cmxdID0gZHJhZnQuY29tcGlsZVNjaGVtYShzY2hlbWEpO1xufVxuIiwiaW1wb3J0IHsgZWFjaFNjaGVtYSB9IGZyb20gXCIuLi8uLi9lYWNoU2NoZW1hXCI7XG4vLyBpbXBvcnQgcmVtb3RlcyBmcm9tIFwiLi4vLi4vLi4vcmVtb3Rlc1wiO1xuaW1wb3J0IGpvaW5TY29wZSBmcm9tIFwiLi4vLi4vY29tcGlsZS9qb2luU2NvcGVcIjtcbmltcG9ydCBnZXRSZWYgZnJvbSBcIi4uLy4uL2NvbXBpbGUvZ2V0UmVmXCI7XG5pbXBvcnQgeyBnZXQgfSBmcm9tIFwiQHNhZ29sZC9qc29uLXBvaW50ZXJcIjtcbmNvbnN0IENPTVBJTEVEID0gXCJfX2NvbXBpbGVkXCI7XG5jb25zdCBDT01QSUxFRF9SRUYgPSBcIl9fcmVmXCI7XG5jb25zdCBHRVRfUkVGID0gXCJnZXRSZWZcIjtcbmNvbnN0IEdFVF9ST09UID0gXCJnZXRSb290XCI7XG5jb25zdCBHRVRfQ09OVEVYVCA9IFwiZ2V0Q29udGV4dFwiO1xuY29uc3Qgc3VmZml4ZXMgPSAvKCN8XFwvKSskL2c7XG4vKipcbiAqIEBkcmFmdCA2LCAyMDE5LTA5XG4gKiAtIHN0YXJ0aW5nIHdpdGggX2RyYWZ0IDIwMTktMDlfIHBsYWluIG5hbWUgZnJhZ21lbnRzIGFyZSBubyBsb25nZXIgZGVmaW5lZCB3aXRoICRpZCxcbiAqICBidXQgaW5zdGVhZCB3aXRoIHRoZSBuZXcga2V5d29yZCAkYW5jaG9yICh3aGljaCBoYXMgYSBkaWZmZXJlbnQgc3ludGF4KVxuICogIGh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMTktMDkvcmVsZWFzZS1ub3RlcyNpbmNvbXBhdGlibGUtY2hhbmdlc1xuICogLSBpbiBfZHJhZnQgMjAxOS0wOV8gb25seSAkcmVjdXJzaXZlQW5jaG9yIGFuZCAkcmVjdXJzaXZlUmVmIGhhdmUgYmVlbiBpbnRyb2R1Y2VkXG4gKiAtIHN0YXJ0aW5nIHdpdGggX2RyYWZ0IDZfIGlkIGlzIG5hbWVkICRpZFxuICpcbiAqIGNvbXBpbGVzIHRoZSBpbnB1dCByb290IHNjaGVtYSBmb3IgJHJlZiByZXNvbHV0aW9uIGFuZCByZXR1cm5zIGl0IGFnYWluXG4gKiBAYXR0ZW50aW9uIHRoaXMgbW9kaWZpZXMgaW5wdXQgc2NoZW1hIGJ1dCBtYWludGFpbnMgb2JqZWN0LXN0cnVjdHVyZVxuICpcbiAqIGZvciBhIGNvbXBpbGVkIGpzb24tc2NoZW1hIHlvdSBjYW4gY2FsbCBnZXRSZWYgb24gYW55IGNvbnRhaW5lZCBzY2hlbWEgKGxvY2F0aW9uIG9mIHR5cGUpLlxuICogdGhpcyByZXNvbHZlcyBhICRyZWYgdGFyZ2V0IHRvIGEgdmFsaWQgc2NoZW1hIChmb3IgYSB2YWxpZCAkcmVmKVxuICpcbiAqIEBwYXJhbSByb290U2NoZW1hIHJvb3QganNvbi1zY2hlbWEgKCRpZCwgZGVmcywgLi4uICkgdG8gY29tcGlsZVxuICogQHBhcmFtIFtmb3JjZV0gPSBmYWxzZSBmb3JjZSBjb21waWxlIGpzb24tc2NoZW1hXG4gKiBAcmV0dXJuIGNvbXBpbGVkIGpzb24tc2NoZW1hXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoZHJhZnQsIHNjaGVtYVRvQ29tcGlsZSwgcm9vdFNjaGVtYSA9IHNjaGVtYVRvQ29tcGlsZSwgZm9yY2UgPSBmYWxzZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaW5jb21wbGV0ZSBKc29uU2NoZW1hIHR5cGVcbiAgICBpZiAoc2NoZW1hVG9Db21waWxlID09PSB0cnVlIHx8IHNjaGVtYVRvQ29tcGlsZSA9PT0gZmFsc2UgfHwgc2NoZW1hVG9Db21waWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVRvQ29tcGlsZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVRvQ29tcGlsZVtDT01QSUxFRF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hVG9Db21waWxlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIC8vIGNvbnNvbGUubG9nKFwiY29tcGlsZSBzY2hlbWFcIiwgc2NoZW1hVG9Db21waWxlLiRpZCk7XG4gICAgY29uc3QgY29udGV4dCA9IHsgaWRzOiB7fSwgYW5jaG9yczoge30sIHJlbW90ZXM6IGRyYWZ0LnJlbW90ZXMgfTtcbiAgICBjb25zdCByb290U2NoZW1hQXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShzY2hlbWFUb0NvbXBpbGUpO1xuICAgIGNvbnN0IGNvbXBpbGVkU2NoZW1hID0gSlNPTi5wYXJzZShyb290U2NoZW1hQXNTdHJpbmcpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbXBpbGVkU2NoZW1hLCB7XG4gICAgICAgIFtDT01QSUxFRF06IHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiB0cnVlIH0sXG4gICAgICAgIFtHRVRfQ09OVEVYVF06IHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiAoKSA9PiBjb250ZXh0IH0sXG4gICAgICAgIFtHRVRfUkVGXToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0UmVmLmJpbmQobnVsbCwgY29udGV4dCwgY29tcGlsZWRTY2hlbWEpXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBiYWlsIGVhcmx5LCB3aGVuIG5vICRyZWZzIGFyZSBkZWZpbmVkXG4gICAgaWYgKGZvcmNlID09PSBmYWxzZSAmJiByb290U2NoZW1hQXNTdHJpbmcuaW5jbHVkZXMoXCIkcmVmXCIpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gY29tcGlsZWRTY2hlbWE7XG4gICAgfVxuICAgIC8vIGNvbXBpbGUgdGhpcyBzY2hlbWEgdW5kZXIgcm9vdFNjaGVtYSwgbWFraW5nIGRlZmluaXRpb25zIGF2YWlsYWJsZSB0byAkcmVmLXJlc29sdXRpb25cbiAgICBpZiAoY29tcGlsZWRTY2hlbWEgIT09IHJvb3RTY2hlbWEpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBpbGVkU2NoZW1hLCBcIiRkZWZzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgcm9vdFNjaGVtYS5kZWZpbml0aW9ucywgcm9vdFNjaGVtYS4kZGVmcywgY29tcGlsZWRTY2hlbWEuZGVmaW5pdGlvbnMsIGNvbXBpbGVkU2NoZW1hLiRkZWZzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0ge307XG4gICAgY29uc3QgZ2V0Um9vdCA9ICgpID0+IGNvbXBpbGVkU2NoZW1hO1xuICAgIGVhY2hTY2hlbWEoY29tcGlsZWRTY2hlbWEsIChzY2hlbWEsIHBvaW50ZXIpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc2NoZW1hLiRpZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHNjaGVtYSBiZWluZyBtZXJnZWQgb24gcm9vdCBvYmplY3QsIHdlIGNhbm5vdCBvdmVycmlkZVxuICAgICAgICAgICAgLy8gcGFyZW50cyBsb2NhdGlvbnMsIGJ1dCBtdXN0IHJldXNlIGl0XG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRpZC5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAvKGFsbE9mfGFueU9mfG9uZU9mfGlmKVxcL1xcZCskLy50ZXN0KHBvaW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UG9pbnRlciA9IHBvaW50ZXIucmVwbGFjZSgvXFwvKGFsbE9mfGFueU9mfG9uZU9mfGlmKVxcL1xcZCskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gZ2V0KGNvbXBpbGVkU2NoZW1hLCBwYXJlbnRQb2ludGVyKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJGlkID0gKF9hID0gcGFyZW50U2NoZW1hLiRpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2NoZW1hLiRpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuaWRzW3NjaGVtYS4kaWQucmVwbGFjZShzdWZmaXhlcywgXCJcIildID0gcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB1cCBzY29wZXMgYW5kIGFkZCB0aGVtIHRvICRyZWYtcmVzb2x1dGlvbiBtYXBcbiAgICAgICAgcG9pbnRlciA9IGAjJHtwb2ludGVyfWAucmVwbGFjZSgvIyMrLywgXCIjXCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1BvaW50ZXIgPSBwb2ludGVyLnJlcGxhY2UoL1xcL1teL10rJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBwYXJlbnRQb2ludGVyID0gcG9pbnRlci5yZXBsYWNlKC9cXC9bXi9dK1xcL1teL10rJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1Njb3BlID0gc2NvcGVzW3ByZXZpb3VzUG9pbnRlcl0gfHwgc2NvcGVzW3BhcmVudFBvaW50ZXJdO1xuICAgICAgICBjb25zdCBzY29wZSA9IGpvaW5TY29wZShwcmV2aW91c1Njb3BlLCBzY2hlbWEuJGlkKTtcbiAgICAgICAgLy8gLy8gQHRvZG8gc3BlY2lmeSBiZWhhdmlvdXIgLSB3ZSBkbyBub3Qgc2F2ZSBpZHMgd2l0aCB0cmFpbGluZyBzbGFzaGVzLi4uXG4gICAgICAgIHNjb3Blc1twb2ludGVyXSA9IHNjb3BlO1xuICAgICAgICBpZiAoY29udGV4dC5pZHNbc2NvcGVdID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaWRzW3Njb3BlXSA9IHBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS4kYW5jaG9yKSB7XG4gICAgICAgICAgICBjb250ZXh0LmFuY2hvcnNbYCR7c2NvcGV9IyR7c2NoZW1hLiRhbmNob3J9YF0gPSBwb2ludGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuJHJlZiAmJiAhc2NoZW1hW0NPTVBJTEVEX1JFRl0pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWEsIENPTVBJTEVEX1JFRiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBqb2luU2NvcGUoc2NvcGUsIHNjaGVtYS4kcmVmKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCBHRVRfUk9PVCwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IGdldFJvb3QgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBjb25zb2xlLmxvZyhcImlkc1wiLCBjb250ZXh0Lmlkcyk7XG4gICAgLy8gY29uc29sZS5sb2coXCJhbmNob3JzXCIsIGNvbnRleHQuYW5jaG9ycyk7XG4gICAgcmV0dXJuIGNvbXBpbGVkU2NoZW1hO1xufVxuIiwiaW1wb3J0IEtleXdvcmRzIGZyb20gXCIuLi8uLi92YWxpZGF0aW9uL2tleXdvcmRcIjtcbmltcG9ydCBnZXRUeXBlT2YgZnJvbSBcIi4uLy4uL2dldFR5cGVPZlwiO1xuaW1wb3J0IHsgdmFsaWRhdGVJZiB9IGZyb20gXCIuLi8uLi9mZWF0dXJlcy9pZlwiO1xuY29uc3QgS2V5d29yZFZhbGlkYXRpb24gPSB7XG4gICAgLi4uS2V5d29yZHMsXG4gICAgLy8gQGRyYWZ0ID49IDZcbiAgICBjb250YWluczogKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgaWYgKHNjaGVtYS5jb250YWlucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuY29udGFpbnNBcnJheUVycm9yKHsgcG9pbnRlciwgdmFsdWUsIHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmNvbnRhaW5zID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5jb250YWluc0FueUVycm9yKHsgcG9pbnRlciwgdmFsdWUsIHNjaGVtYSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFR5cGVPZihzY2hlbWEuY29udGFpbnMpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgaW52YWxpZCBzY2hlbWFcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChzY2hlbWEuY29udGFpbnMsIGkpLCB2YWx1ZVtpXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAZHJhZnQgPj0gMjAxOS0wOVxuICAgICAgICBjb25zdCBtYXggPSAoX2EgPSBzY2hlbWEubWF4Q29udGFpbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xuICAgICAgICBjb25zdCBtaW4gPSAoX2IgPSBzY2hlbWEubWluQ29udGFpbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XG4gICAgICAgIGlmIChtYXggPj0gY291bnQgJiYgbWluIDw9IGNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPCBjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5jb250YWluc01heEVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCBkZWx0YTogY291bnQgLSBtYXgsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPiBjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5jb250YWluc01pbkVycm9yKHsgcG9pbnRlciwgc2NoZW1hLCBkZWx0YTogbWluIC0gY291bnQsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMuY29udGFpbnNFcnJvcih7IHBvaW50ZXIsIHNjaGVtYSwgdmFsdWUgfSk7XG4gICAgfSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5tYXhpbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSA+PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5taW5pbXVtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1pbmltdW06IHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICAvLyBAZmVhdHVyZSBpZi10aGVuLWVsc2VcbiAgICBpZjogdmFsaWRhdGVJZixcbiAgICBtYXhpbXVtOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICBpZiAoaXNOYU4oc2NoZW1hLm1heGltdW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubWF4aW11bSAmJiBzY2hlbWEubWF4aW11bSA8IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZnQuZXJyb3JzLm1heGltdW1FcnJvcih7XG4gICAgICAgICAgICAgICAgbWF4aW11bTogc2NoZW1hLm1heGltdW0sXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1pbmltdW06IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGlmIChpc05hTihzY2hlbWEubWluaW11bSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5taW5pbXVtID4gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdC5lcnJvcnMubWluaW11bUVycm9yKHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBzY2hlbWEubWluaW11bSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgY29uc3QgcHAgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXM7XG4gICAgICAgIGlmIChnZXRUeXBlT2YocHApICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IE9iamVjdC5rZXlzKHBwKS5tYXAoKGV4cHIpID0+ICh7XG4gICAgICAgICAgICByZWdleDogbmV3IFJlZ0V4cChleHByKSxcbiAgICAgICAgICAgIHBhdHRlcm5TY2hlbWE6IHBwW2V4cHJdXG4gICAgICAgIH0pKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5zW2ldLnJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYSBib29sZWFuIHNjaGVtYSBgZmFsc2VgLCBhbHdheXMgaW52YWxpZGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVybnNbaV0ucGF0dGVyblNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy5wYXR0ZXJuUHJvcGVydGllc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuczogT2JqZWN0LmtleXMocHApLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbEVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChwYXR0ZXJuc1tpXS5wYXR0ZXJuU2NoZW1hLCBrZXkpLCB2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbEVycm9ycyAmJiB2YWxFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0dGVybkZvdW5kID09PSBmYWxzZSAmJiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBhcnJhbmdlbWVudCB3aXRoIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLnBhdHRlcm5Qcm9wZXJ0aWVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5zOiBPYmplY3Qua2V5cyhwcCkuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgLy8gQGRyYWZ0ID49IDZcbiAgICBwcm9wZXJ0eU5hbWVzOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcmFmdCwgc2NoZW1hLCBwb2ludGVyIH0gPSBub2RlO1xuICAgICAgICAvLyBib29sIHNjaGVtYVxuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnR5TmFtZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBvYmplY3RzIGFyZSB2YWxpZFxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy5pbnZhbGlkUHJvcGVydHlOYW1lRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBPYmplY3Qua2V5cyh2YWx1ZSksXG4gICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydHlOYW1lcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0VHlwZU9mKHNjaGVtYS5wcm9wZXJ0eU5hbWVzKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gaWdub3JlIGludmFsaWQgc2NoZW1hXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHsgLi4uc2NoZW1hLnByb3BlcnR5TmFtZXMsIHR5cGU6IFwic3RyaW5nXCIgfTtcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUubmV4dChwcm9wZXJ0eVNjaGVtYSwgcHJvcCk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gZHJhZnQudmFsaWRhdGUobmV4dE5vZGUsIHByb3ApO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy5pbnZhbGlkUHJvcGVydHlOYW1lRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yOiB2YWxpZGF0aW9uUmVzdWx0WzBdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbcHJvcF0sXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEtleXdvcmRWYWxpZGF0aW9uO1xuIiwiaW1wb3J0IGFkZFJlbW90ZVNjaGVtYSBmcm9tIFwiLi4vYWRkUmVtb3RlU2NoZW1hXCI7XG5pbXBvcnQgY29tcGlsZVNjaGVtYSBmcm9tIFwiLi4vZHJhZnQwNi9jb21waWxlXCI7XG5pbXBvcnQgY3JlYXRlU2NoZW1hT2YgZnJvbSBcIi4uL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgRVJST1JTIGZyb20gXCIuLi92YWxpZGF0aW9uL2Vycm9yc1wiO1xuaW1wb3J0IEZPUk1BVFMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vZm9ybWF0XCI7XG5pbXBvcnQgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24gZnJvbSBcIi4uL2dldENoaWxkU2NoZW1hU2VsZWN0aW9uXCI7XG5pbXBvcnQgZ2V0U2NoZW1hIGZyb20gXCIuLi9nZXRTY2hlbWFcIjtcbmltcG9ydCBnZXRUZW1wbGF0ZSBmcm9tIFwiLi4vZ2V0VGVtcGxhdGVcIjtcbmltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkXCI7XG5pbXBvcnQgS0VZV09SRFMgZnJvbSBcIi4uL2RyYWZ0MDYvdmFsaWRhdGlvbi9rZXl3b3JkXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4uL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZi5zdHJpY3RcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vY29uZmlnL3NldHRpbmdzXCI7XG5pbXBvcnQgc3RlcCBmcm9tIFwiLi4vc3RlcFwiO1xuaW1wb3J0IFRZUEVTIGZyb20gXCIuLi92YWxpZGF0aW9uL3R5cGVcIjtcbmltcG9ydCB2YWxpZGF0ZSBmcm9tIFwiLi4vdmFsaWRhdGVcIjtcbmltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tIFwiLi4vc2NoZW1hTm9kZVwiO1xuaW1wb3J0IHsgRHJhZnQgfSBmcm9tIFwiLi4vZHJhZnRcIjtcbmltcG9ydCB7IGVhY2ggfSBmcm9tIFwiLi4vZWFjaFwiO1xuaW1wb3J0IHsgZWFjaFNjaGVtYSB9IGZyb20gXCIuLi9lYWNoU2NoZW1hXCI7XG5pbXBvcnQgeyByZXNvbHZlQWxsT2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCB7IHJlc29sdmVBbnlPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZU9uZU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5jb25zdCBkcmFmdDA2Q29uZmlnID0ge1xuICAgIHR5cGVLZXl3b3Jkczoge1xuICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJjb250YWluc1wiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImlmXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCIsXG4gICAgICAgICAgICBcIm1heEl0ZW1zXCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiXG4gICAgICAgIF0sXG4gICAgICAgIGJvb2xlYW46IFtcImFsbE9mXCIsIFwiYW55T2ZcIiwgXCJlbnVtXCIsIFwibm90XCIsIFwib25lT2ZcIl0sXG4gICAgICAgIG9iamVjdDogW1xuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzdHJpbmc6IFtcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgICAgICAgICBcIm1pbkxlbmd0aFwiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIixcbiAgICAgICAgICAgIFwicGF0dGVyblwiXG4gICAgICAgIF0sXG4gICAgICAgIG51bWJlcjogW1xuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIixcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwibWF4aW11bVwiLFxuICAgICAgICAgICAgXCJtaW5pbXVtXCIsXG4gICAgICAgICAgICBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCIsXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCIsXG4gICAgICAgICAgICBcImlmXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVsbDogW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcImVudW1cIiwgXCJmb3JtYXRcIiwgXCJub3RcIiwgXCJvbmVPZlwiXVxuICAgIH0sXG4gICAgdmFsaWRhdGVLZXl3b3JkOiBLRVlXT1JEUyxcbiAgICB2YWxpZGF0ZVR5cGU6IFRZUEVTLFxuICAgIHZhbGlkYXRlRm9ybWF0OiBGT1JNQVRTLFxuICAgIGVycm9yczogRVJST1JTLFxuICAgIGNyZWF0ZU5vZGUsXG4gICAgYWRkUmVtb3RlU2NoZW1hLFxuICAgIGNvbXBpbGVTY2hlbWEsXG4gICAgY3JlYXRlU2NoZW1hT2YsXG4gICAgZWFjaCxcbiAgICBlYWNoU2NoZW1hLFxuICAgIGdldENoaWxkU2NoZW1hU2VsZWN0aW9uLFxuICAgIGdldFNjaGVtYSxcbiAgICBnZXRUZW1wbGF0ZSxcbiAgICBpc1ZhbGlkLFxuICAgIHJlc29sdmVBbGxPZixcbiAgICByZXNvbHZlQW55T2YsXG4gICAgcmVzb2x2ZU9uZU9mLFxuICAgIHJlc29sdmVSZWYsXG4gICAgc3RlcCxcbiAgICB2YWxpZGF0ZSxcbiAgICB0ZW1wbGF0ZURlZmF1bHRPcHRpb25zOiBzZXR0aW5ncy50ZW1wbGF0ZURlZmF1bHRPcHRpb25zXG59O1xuY2xhc3MgRHJhZnQwNiBleHRlbmRzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKGRyYWZ0MDZDb25maWcsIGNvbmZpZyksIHNjaGVtYSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRHJhZnQwNiwgZHJhZnQwNkNvbmZpZyB9O1xuIiwiaW1wb3J0IGFkZFJlbW90ZVNjaGVtYSBmcm9tIFwiLi4vYWRkUmVtb3RlU2NoZW1hXCI7XG5pbXBvcnQgY29tcGlsZVNjaGVtYSBmcm9tIFwiLi4vZHJhZnQwNi9jb21waWxlXCI7XG5pbXBvcnQgY3JlYXRlU2NoZW1hT2YgZnJvbSBcIi4uL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgRVJST1JTIGZyb20gXCIuLi92YWxpZGF0aW9uL2Vycm9yc1wiO1xuaW1wb3J0IEZPUk1BVFMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vZm9ybWF0XCI7XG5pbXBvcnQgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24gZnJvbSBcIi4uL2dldENoaWxkU2NoZW1hU2VsZWN0aW9uXCI7XG5pbXBvcnQgZ2V0U2NoZW1hIGZyb20gXCIuLi9nZXRTY2hlbWFcIjtcbmltcG9ydCBnZXRUZW1wbGF0ZSBmcm9tIFwiLi4vZ2V0VGVtcGxhdGVcIjtcbmltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkXCI7XG5pbXBvcnQgS0VZV09SRFMgZnJvbSBcIi4uL2RyYWZ0MDYvdmFsaWRhdGlvbi9rZXl3b3JkXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4uL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZi5zdHJpY3RcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vY29uZmlnL3NldHRpbmdzXCI7XG5pbXBvcnQgc3RlcCBmcm9tIFwiLi4vc3RlcFwiO1xuaW1wb3J0IFRZUEVTIGZyb20gXCIuLi92YWxpZGF0aW9uL3R5cGVcIjtcbmltcG9ydCB2YWxpZGF0ZSBmcm9tIFwiLi4vdmFsaWRhdGVcIjtcbmltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tIFwiLi4vc2NoZW1hTm9kZVwiO1xuaW1wb3J0IHsgRHJhZnQgfSBmcm9tIFwiLi4vZHJhZnRcIjtcbmltcG9ydCB7IGVhY2ggfSBmcm9tIFwiLi4vZWFjaFwiO1xuaW1wb3J0IHsgZWFjaFNjaGVtYSB9IGZyb20gXCIuLi9lYWNoU2NoZW1hXCI7XG5pbXBvcnQgeyByZXNvbHZlQWxsT2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCB7IHJlc29sdmVBbnlPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbnlPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZU9uZU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5jb25zdCBkcmFmdDA3Q29uZmlnID0ge1xuICAgIHR5cGVLZXl3b3Jkczoge1xuICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJjb250YWluc1wiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImlmXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCIsXG4gICAgICAgICAgICBcIm1heEl0ZW1zXCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiXG4gICAgICAgIF0sXG4gICAgICAgIGJvb2xlYW46IFtcImFsbE9mXCIsIFwiYW55T2ZcIiwgXCJlbnVtXCIsIFwibm90XCIsIFwib25lT2ZcIl0sXG4gICAgICAgIG9iamVjdDogW1xuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzdHJpbmc6IFtcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgICAgICAgICBcIm1pbkxlbmd0aFwiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIixcbiAgICAgICAgICAgIFwicGF0dGVyblwiXG4gICAgICAgIF0sXG4gICAgICAgIG51bWJlcjogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIixcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgIFwiaWZcIixcbiAgICAgICAgICAgIFwibWF4aW11bVwiLFxuICAgICAgICAgICAgXCJtaW5pbXVtXCIsXG4gICAgICAgICAgICBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVsbDogW1wiYWxsT2ZcIiwgXCJhbnlPZlwiLCBcImVudW1cIiwgXCJmb3JtYXRcIiwgXCJub3RcIiwgXCJvbmVPZlwiXVxuICAgIH0sXG4gICAgdmFsaWRhdGVLZXl3b3JkOiBLRVlXT1JEUyxcbiAgICB2YWxpZGF0ZVR5cGU6IFRZUEVTLFxuICAgIHZhbGlkYXRlRm9ybWF0OiBGT1JNQVRTLFxuICAgIGVycm9yczogRVJST1JTLFxuICAgIGNyZWF0ZU5vZGUsXG4gICAgYWRkUmVtb3RlU2NoZW1hLFxuICAgIGNvbXBpbGVTY2hlbWEsXG4gICAgY3JlYXRlU2NoZW1hT2YsXG4gICAgZWFjaCxcbiAgICBlYWNoU2NoZW1hLFxuICAgIGdldENoaWxkU2NoZW1hU2VsZWN0aW9uLFxuICAgIGdldFNjaGVtYSxcbiAgICBnZXRUZW1wbGF0ZSxcbiAgICBpc1ZhbGlkLFxuICAgIHJlc29sdmVBbGxPZixcbiAgICByZXNvbHZlQW55T2YsXG4gICAgcmVzb2x2ZU9uZU9mLFxuICAgIHJlc29sdmVSZWYsXG4gICAgc3RlcCxcbiAgICB2YWxpZGF0ZSxcbiAgICB0ZW1wbGF0ZURlZmF1bHRPcHRpb25zOiBzZXR0aW5ncy50ZW1wbGF0ZURlZmF1bHRPcHRpb25zXG59O1xuY2xhc3MgRHJhZnQwNyBleHRlbmRzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKGRyYWZ0MDdDb25maWcsIGNvbmZpZyksIHNjaGVtYSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRHJhZnQwNywgZHJhZnQwN0NvbmZpZyB9O1xuIiwiaW1wb3J0IEtleXdvcmRzIGZyb20gXCIuLi8uLi9kcmFmdDA2L3ZhbGlkYXRpb24va2V5d29yZFwiO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaXNPYmplY3RcIjtcbmltcG9ydCB7IHJlZHVjZVNjaGVtYSB9IGZyb20gXCIuLi8uLi9yZWR1Y2VTY2hlbWFcIjtcbmltcG9ydCB7IHZhbGlkYXRlRGVwZW5kZW50U2NoZW1hcywgdmFsaWRhdGVEZXBlbmRlbnRSZXF1aXJlZCB9IGZyb20gXCIuLi8uLi9mZWF0dXJlcy9kZXBlbmRlbmNpZXNcIjtcbi8qKlxuICogR2V0IGEgbGlzdCBvZiB0ZXN0cyB0byBzZWFyY2ggZm9yIGEgbWF0Y2hpbmcgcGF0dGVybiB0byBhIHByb3BlcnR5XG4gKi9cbmNvbnN0IGdldFBhdHRlcm5UZXN0cyA9IChwYXR0ZXJuUHJvcGVydGllcykgPT4gaXNPYmplY3QocGF0dGVyblByb3BlcnRpZXMpXG4gICAgPyBPYmplY3Qua2V5cyhwYXR0ZXJuUHJvcGVydGllcykubWFwKChwYXR0ZXJuKSA9PiBuZXcgUmVnRXhwKHBhdHRlcm4pKVxuICAgIDogW107XG4vKiogdGVzdHMgaWYgYSBwcm9wZXJ0eSBpcyBldmFsdWF0ZWQgYnkgdGhlIGdpdmVuIHNjaGVtYSAqL1xuZnVuY3Rpb24gaXNQcm9wZXJ0eUV2YWx1YXRlZChzY2hlbWFOb2RlLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBub2RlID0gc2NoZW1hTm9kZS5kcmFmdC5yZXNvbHZlUmVmKHNjaGVtYU5vZGUpO1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBub2RlO1xuICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFBST1BFUlRJRVNcbiAgICBpZiAoKF9hID0gc2NoZW1hLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtwcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgIGNvbnN0IG5leHRTY2hlbWEgPSAoX2IgPSBzY2hlbWEucHJvcGVydGllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIGlmIChub2RlLmRyYWZ0LmlzVmFsaWQodmFsdWUsIG5leHRTY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQQVRURVJOLVBST1BFUlRJRVNcbiAgICBjb25zdCBwYXR0ZXJucyA9IGdldFBhdHRlcm5UZXN0cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuICAgIGlmIChwYXR0ZXJucy5maW5kKChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QocHJvcGVydHlOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEFERElUSU9OQUwtUFJPUEVSVElFU1xuICAgIGlmIChpc09iamVjdChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpKSB7XG4gICAgICAgIGNvbnN0IG5leHRTY2hlbWEgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBub2RlLmRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChuZXh0U2NoZW1hKSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBLZXl3b3JkVmFsaWRhdGlvbiA9IHtcbiAgICAvLyAuLi5vbWl0KEtleXdvcmRzLCBcImRlcGVuZGVuY2llc1wiKSxcbiAgICAuLi5LZXl3b3JkcyxcbiAgICBkZXBlbmRlbmNpZXM6IHVuZGVmaW5lZCxcbiAgICBkZXBlbmRlbnRTY2hlbWFzOiB2YWxpZGF0ZURlcGVuZGVudFNjaGVtYXMsXG4gICAgZGVwZW5kZW50UmVxdWlyZWQ6IHZhbGlkYXRlRGVwZW5kZW50UmVxdWlyZWQsXG4gICAgLyoqXG4gICAgICogQGRyYWZ0ID49IDIwMTktMDlcbiAgICAgKiBTaW1pbGFyIHRvIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBidXQgY2FuIFwic2VlXCIgaW50byBzdWJzY2hlbWFzIGFuZCBhY3Jvc3MgcmVmZXJlbmNlc1xuICAgICAqIGh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMTktMDkvanNvbi1zY2hlbWEtY29yZSNyZmMuc2VjdGlvbi45LjMuMi40XG4gICAgICovXG4gICAgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiAobm9kZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGRyYWZ0LCBzY2hlbWEsIHBvaW50ZXIgfSA9IG5vZGU7XG4gICAgICAgIC8vIGlmIG5vdCBpbiBwcm9wZXJ0aWVzLCBldmFsdWF0ZWQgYnkgYWRkaXRpb25hbFByb3BlcnRpZXMgYW5kIG5vdCBtYXRjaGVzIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgICAgIC8vIEB0b2RvIHdlIG5lZWQgdG8ga25vdyBkeW5hbWljIHBhcmVudCBzdGF0ZW1lbnRzIC0gdGhleSBzaG91bGQgbm90IGJlIGNvdW50ZWQgYXMgZXZhbHVhdGVkLi4uXG4gICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5ldmFsdWF0ZWQgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGlmICh1bmV2YWx1YXRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgZHluYW1pYyBzY2hlbWFzXG4gICAgICAgIGNvbnN0IHJlZHVjdGlvbiA9IHJlZHVjZVNjaGVtYShub2RlLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gKChfYSA9IHJlZHVjdGlvbi5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlZHVjdGlvbik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzXCIsIEpTT04uc3RyaW5naWZ5KHJlc29sdmVkU2NoZW1hLCBudWxsLCAyKSwgdmFsdWUpO1xuICAgICAgICBpZiAocmVzb2x2ZWRTY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlc3RQYXR0ZXJucyA9IGdldFBhdHRlcm5UZXN0cyhyZXNvbHZlZFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIHVuZXZhbHVhdGVkID0gdW5ldmFsdWF0ZWQuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICgoX2EgPSByZXNvbHZlZFNjaGVtYS5wcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogYW4gZXZhbHVhdGlvbiBpbiBpZiBzdGF0ZW1lbnQgY291bnRzIHRvb1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbiB1bmV2YWx1YXRlZCBwcm9wIG9ubHkgaWYgdGhlIGlmLXNjaGVtYSBkb2VzIG5vdCBtYXRjaFxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNjaGVtYS5pZikgJiZcbiAgICAgICAgICAgICAgICBpc1Byb3BlcnR5RXZhbHVhdGVkKG5vZGUubmV4dCh7IHR5cGU6IFwib2JqZWN0XCIsIC4uLnNjaGVtYS5pZiB9KSwga2V5LCB2YWx1ZVtrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXN0UGF0dGVybnMuZmluZCgocGF0dGVybikgPT4gcGF0dGVybi50ZXN0KGtleSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRvZG8gaXMgdGhpcyBldmFsdWF0ZWQgYnkgYWRkaXRpb25hUHJvcGVydGllcyBwZXIgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVuZXZhbHVhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgaWYgKHJlc29sdmVkU2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVuZXZhbHVhdGVkLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGRyYWZ0LmVycm9ycy51bmV2YWx1YXRlZFByb3BlcnR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyOiBgJHtwb2ludGVyfS8ke2tleX1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkodmFsdWVba2V5XSksXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB1bmV2YWx1YXRlZC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChyZXNvbHZlZFNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZTogb25seSBrZXkgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUVycm9ycyA9IGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChyZXNvbHZlZFNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMsIGtleSksIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmtleUVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGRyYWZ0ID49IDIwMTktMDlcbiAgICAgKiBTaW1pbGFyIHRvIGFkZGl0aW9uYWxJdGVtcywgYnV0IGNhbiBcInNlZVwiIGludG8gc3Vic2NoZW1hcyBhbmQgYWNyb3NzIHJlZmVyZW5jZXNcbiAgICAgKiBodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L2pzb24tc2NoZW1hLWNvcmUjcmZjLnNlY3Rpb24uOS4zLjEuM1xuICAgICAqL1xuICAgIHVuZXZhbHVhdGVkSXRlbXM6IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZHJhZnQsIHNjaGVtYSwgcG9pbnRlciB9ID0gbm9kZTtcbiAgICAgICAgLy8gaWYgbm90IGluIGl0ZW1zLCBhbmQgbm90IG1hdGNoZXMgYWRkaXRpb25hbEl0ZW1zXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgc2NoZW1hLnVuZXZhbHVhdGVkSXRlbXMgPT0gbnVsbCB8fFxuICAgICAgICAgICAgc2NoZW1hLnVuZXZhbHVhdGVkSXRlbXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgZHluYW1pYyBzY2hlbWFzXG4gICAgICAgIGNvbnN0IHJlZHVjdGlvbiA9IHJlZHVjZVNjaGVtYShkcmFmdC5yZXNvbHZlUmVmKG5vZGUpLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gKChfYSA9IHJlZHVjdGlvbi5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlZHVjdGlvbik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidW5ldmFsdWF0ZWRJdGVtc1wiLCBKU09OLnN0cmluZ2lmeShyZXNvbHZlZFNjaGVtYSwgbnVsbCwgMiksIHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc29sdmVkU2NoZW1hLnVuZXZhbHVhdGVkSXRlbXMgPT09IHRydWUgfHwgcmVzb2x2ZWRTY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChzY2hlbWEuaWYpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0U2NoZW1hTm9kZSA9IHsgdHlwZTogXCJhcnJheVwiLCAuLi5zY2hlbWEuaWYgfTtcbiAgICAgICAgICAgIGlmIChkcmFmdC5pc1ZhbGlkKHZhbHVlLCBuZXh0U2NoZW1hTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0U2NoZW1hTm9kZS5pdGVtcykgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjaGVtYU5vZGUuaXRlbXMubGVuZ3RoID09PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHRlc3QgcmVtYWluaW5nIGl0ZW1zP1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChyZXNvbHZlZFNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTY2hlbWFOb2RlID0geyAuLi5yZXNvbHZlZFNjaGVtYSwgdW5ldmFsdWF0ZWRJdGVtczogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBkcmFmdC52YWxpZGF0ZShub2RlLm5leHQobmV4dFNjaGVtYU5vZGUpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLm1hcCgoZSkgPT4gZHJhZnQuZXJyb3JzLnVuZXZhbHVhdGVkSXRlbXNFcnJvcih7IC4uLmUuZGF0YSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZWRTY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJlc29sdmVkU2NoZW1hLml0ZW1zLmxlbmd0aDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCByZXNvbHZlZFNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWZ0LnZhbGlkYXRlKG5vZGUubmV4dChyZXNvbHZlZFNjaGVtYS5pdGVtc1tpXSwgaSksIHZhbHVlW2ldKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHsgaW5kZXg6IGksIHZhbHVlOiB2YWx1ZVtpXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7IGluZGV4OiBpLCB2YWx1ZTogdmFsdWVbaV0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4gZHJhZnQuZXJyb3JzLnVuZXZhbHVhdGVkSXRlbXNFcnJvcih7XG4gICAgICAgICAgICAgICAgcG9pbnRlcjogYCR7cG9pbnRlcn0vJHtpdGVtLmluZGV4fWAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGl0ZW0udmFsdWUpLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogcmVzb2x2ZWRTY2hlbWEudW5ldmFsdWF0ZWRJdGVtc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChyZXNvbHZlZFNjaGVtYS51bmV2YWx1YXRlZEl0ZW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRyYWZ0LmlzVmFsaWQoaXRlbSwgcmVzb2x2ZWRTY2hlbWEudW5ldmFsdWF0ZWRJdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYWZ0LmVycm9ycy51bmV2YWx1YXRlZEl0ZW1zRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcjogYCR7cG9pbnRlcn0vJHtpbmRleH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiByZXNvbHZlZFNjaGVtYS51bmV2YWx1YXRlZEl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZHJhZnQuZXJyb3JzLnVuZXZhbHVhdGVkSXRlbXNFcnJvcih7XG4gICAgICAgICAgICAgICAgcG9pbnRlcjogYCR7cG9pbnRlcn0vJHtpbmRleH1gLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShpdGVtKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEtleXdvcmRWYWxpZGF0aW9uO1xuIiwiaW1wb3J0IGFkZFJlbW90ZVNjaGVtYSBmcm9tIFwiLi4vYWRkUmVtb3RlU2NoZW1hXCI7XG5pbXBvcnQgY29tcGlsZVNjaGVtYSBmcm9tIFwiLi4vZHJhZnQwNi9jb21waWxlXCI7XG5pbXBvcnQgY3JlYXRlU2NoZW1hT2YgZnJvbSBcIi4uL2NyZWF0ZVNjaGVtYU9mXCI7XG5pbXBvcnQgRVJST1JTIGZyb20gXCIuLi92YWxpZGF0aW9uL2Vycm9yc1wiO1xuaW1wb3J0IEZPUk1BVFMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vZm9ybWF0XCI7XG5pbXBvcnQgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24gZnJvbSBcIi4uL2dldENoaWxkU2NoZW1hU2VsZWN0aW9uXCI7XG5pbXBvcnQgZ2V0U2NoZW1hIGZyb20gXCIuLi9nZXRTY2hlbWFcIjtcbmltcG9ydCBnZXRUZW1wbGF0ZSBmcm9tIFwiLi4vZ2V0VGVtcGxhdGVcIjtcbmltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkXCI7XG5pbXBvcnQgS0VZV09SRFMgZnJvbSBcIi4vdmFsaWRhdGlvbi9rZXl3b3JkXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4uL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZlwiO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gXCIuLi9jb25maWcvc2V0dGluZ3NcIjtcbmltcG9ydCBzdGVwIGZyb20gXCIuLi9zdGVwXCI7XG5pbXBvcnQgVFlQRVMgZnJvbSBcIi4uL3ZhbGlkYXRpb24vdHlwZVwiO1xuaW1wb3J0IHZhbGlkYXRlIGZyb20gXCIuLi92YWxpZGF0ZVwiO1xuaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gXCIuLi9zY2hlbWFOb2RlXCI7XG5pbXBvcnQgeyBEcmFmdCB9IGZyb20gXCIuLi9kcmFmdFwiO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gXCIuLi9lYWNoXCI7XG5pbXBvcnQgeyBlYWNoU2NoZW1hIH0gZnJvbSBcIi4uL2VhY2hTY2hlbWFcIjtcbmltcG9ydCB7IHJlc29sdmVBbGxPZiB9IGZyb20gXCIuLi9mZWF0dXJlcy9hbGxPZlwiO1xuaW1wb3J0IHsgcmVzb2x2ZUFueU9mIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL2FueU9mXCI7XG5pbXBvcnQgeyByZXNvbHZlT25lT2YgfSBmcm9tIFwiLi4vZmVhdHVyZXMvb25lT2ZcIjtcbmNvbnN0IGRyYWZ0MjAxOUNvbmZpZyA9IHtcbiAgICB0eXBlS2V5d29yZHM6IHtcbiAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgIFwiYWxsT2ZcIixcbiAgICAgICAgICAgIFwiYW55T2ZcIixcbiAgICAgICAgICAgIFwiY29udGFpbnNcIixcbiAgICAgICAgICAgIFwiZW51bVwiLFxuICAgICAgICAgICAgXCJpZlwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiLFxuICAgICAgICAgICAgXCJtYXhJdGVtc1wiLFxuICAgICAgICAgICAgXCJtaW5JdGVtc1wiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIixcbiAgICAgICAgICAgIFwidW5ldmFsdWF0ZWRJdGVtc1wiLFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiXG4gICAgICAgIF0sXG4gICAgICAgIGJvb2xlYW46IFtcImFsbE9mXCIsIFwiYW55T2ZcIiwgXCJlbnVtXCIsIFwibm90XCIsIFwib25lT2ZcIl0sXG4gICAgICAgIG9iamVjdDogW1xuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgLy8gXCJkZXBlbmRlbmNpZXNcIixcbiAgICAgICAgICAgIFwiZGVwZW5kZW50U2NoZW1hc1wiLFxuICAgICAgICAgICAgXCJkZXBlbmRlbnRSZXF1aXJlZFwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJpZlwiLFxuICAgICAgICAgICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwibm90XCIsXG4gICAgICAgICAgICBcIm9uZU9mXCIsXG4gICAgICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgIFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiLFxuICAgICAgICAgICAgXCJ1bmV2YWx1YXRlZFByb3BlcnRpZXNcIiAvLyAyMDE5LTA5XG4gICAgICAgIF0sXG4gICAgICAgIHN0cmluZzogW1xuICAgICAgICAgICAgXCJhbGxPZlwiLFxuICAgICAgICAgICAgXCJhbnlPZlwiLFxuICAgICAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJpZlwiLFxuICAgICAgICAgICAgXCJtYXhMZW5ndGhcIixcbiAgICAgICAgICAgIFwibWluTGVuZ3RoXCIsXG4gICAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgICAgXCJvbmVPZlwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuXCJcbiAgICAgICAgXSxcbiAgICAgICAgbnVtYmVyOiBbXG4gICAgICAgICAgICBcImFsbE9mXCIsXG4gICAgICAgICAgICBcImFueU9mXCIsXG4gICAgICAgICAgICBcImVudW1cIixcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiLFxuICAgICAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgXCJpZlwiLFxuICAgICAgICAgICAgXCJtYXhpbXVtXCIsXG4gICAgICAgICAgICBcIm1pbmltdW1cIixcbiAgICAgICAgICAgIFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgXCJub3RcIixcbiAgICAgICAgICAgIFwib25lT2ZcIlxuICAgICAgICBdLFxuICAgICAgICBudWxsOiBbXCJhbGxPZlwiLCBcImFueU9mXCIsIFwiZW51bVwiLCBcImZvcm1hdFwiLCBcIm5vdFwiLCBcIm9uZU9mXCJdXG4gICAgfSxcbiAgICB2YWxpZGF0ZUtleXdvcmQ6IEtFWVdPUkRTLFxuICAgIHZhbGlkYXRlVHlwZTogVFlQRVMsXG4gICAgdmFsaWRhdGVGb3JtYXQ6IEZPUk1BVFMsXG4gICAgZXJyb3JzOiBFUlJPUlMsXG4gICAgY3JlYXRlTm9kZSxcbiAgICBhZGRSZW1vdGVTY2hlbWEsXG4gICAgY29tcGlsZVNjaGVtYSxcbiAgICBjcmVhdGVTY2hlbWFPZixcbiAgICBlYWNoLFxuICAgIGVhY2hTY2hlbWEsXG4gICAgZ2V0Q2hpbGRTY2hlbWFTZWxlY3Rpb24sXG4gICAgZ2V0U2NoZW1hLFxuICAgIGdldFRlbXBsYXRlLFxuICAgIGlzVmFsaWQsXG4gICAgcmVzb2x2ZUFsbE9mLFxuICAgIHJlc29sdmVBbnlPZixcbiAgICByZXNvbHZlT25lT2YsXG4gICAgcmVzb2x2ZVJlZixcbiAgICBzdGVwLFxuICAgIHZhbGlkYXRlLFxuICAgIHRlbXBsYXRlRGVmYXVsdE9wdGlvbnM6IHNldHRpbmdzLnRlbXBsYXRlRGVmYXVsdE9wdGlvbnNcbn07XG5jbGFzcyBEcmFmdDIwMTkgZXh0ZW5kcyBEcmFmdCB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihtZXJnZShkcmFmdDIwMTlDb25maWcsIGNvbmZpZyksIHNjaGVtYSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRHJhZnQyMDE5LCBkcmFmdDIwMTlDb25maWcgfTtcbiIsImltcG9ydCBtZXJnZSBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VcIjtcbmltcG9ydCB7IHJlc29sdmVPbmVPZkZ1enp5IH0gZnJvbSBcIi4uL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgcmVzb2x2ZVJlZiBmcm9tIFwiLi4vcmVzb2x2ZVJlZlwiO1xuaW1wb3J0IHsgRHJhZnQgfSBmcm9tIFwiLi4vZHJhZnRcIjtcbmltcG9ydCB7IGRyYWZ0MDdDb25maWcgfSBmcm9tIFwiLi4vZHJhZnQwN1wiO1xuY29uc3QgZHJhZnRKc29uRWRpdG9yQ29uZmlnID0ge1xuICAgIC4uLmRyYWZ0MDdDb25maWcsXG4gICAgcmVzb2x2ZU9uZU9mOiByZXNvbHZlT25lT2ZGdXp6eSxcbiAgICByZXNvbHZlUmVmXG59O1xuY2xhc3MgSnNvbkVkaXRvciBleHRlbmRzIERyYWZ0IHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKGRyYWZ0SnNvbkVkaXRvckNvbmZpZywgY29uZmlnKSwgc2NoZW1hKTtcbiAgICB9XG59XG5leHBvcnQgeyBKc29uRWRpdG9yLCBkcmFmdEpzb25FZGl0b3JDb25maWcgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUVycm9yLCBjcmVhdGVDdXN0b21FcnJvciB9IGZyb20gXCIuL2xpYi91dGlscy9jcmVhdGVDdXN0b21FcnJvclwiO1xuaW1wb3J0IGdldFR5cGVPZiBmcm9tIFwiLi9saWIvZ2V0VHlwZU9mXCI7XG5pbXBvcnQgeyByZXNvbHZlT25lT2YsIHJlc29sdmVPbmVPZkZ1enp5IH0gZnJvbSBcIi4vbGliL2ZlYXR1cmVzL29uZU9mXCI7XG5pbXBvcnQgeyByZXNvbHZlQWxsT2YgfSBmcm9tIFwiLi9saWIvZmVhdHVyZXMvYWxsT2ZcIjtcbmltcG9ydCByZXNvbHZlUmVmU3RyaWN0IGZyb20gXCIuL2xpYi9yZXNvbHZlUmVmLnN0cmljdFwiO1xuaW1wb3J0IHJlc29sdmVSZWYgZnJvbSBcIi4vbGliL3Jlc29sdmVSZWZcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi9saWIvY29uZmlnL3NldHRpbmdzXCI7XG5pbXBvcnQgc3RyaW5ncyBmcm9tIFwiLi9saWIvY29uZmlnL3N0cmluZ3NcIjtcbmltcG9ydCB2YWxpZGF0ZUFzeW5jIGZyb20gXCIuL2xpYi92YWxpZGF0ZUFzeW5jXCI7XG5pbXBvcnQgeyByZWR1Y2VTY2hlbWEgfSBmcm9tIFwiLi9saWIvcmVkdWNlU2NoZW1hXCI7XG5pbXBvcnQgeyByZXNvbHZlRHluYW1pY1NjaGVtYSwgaXNEeW5hbWljU2NoZW1hIH0gZnJvbSBcIi4vbGliL3Jlc29sdmVEeW5hbWljU2NoZW1hXCI7XG5pbXBvcnQgeyBtZXJnZVNjaGVtYSB9IGZyb20gXCIuL2xpYi9tZXJnZVNjaGVtYVwiO1xuaW1wb3J0IHJlbmRlciBmcm9tIFwiLi9saWIvdXRpbHMvcmVuZGVyXCI7XG5pbXBvcnQgeyBEcmFmdCB9IGZyb20gXCIuL2xpYi9kcmFmdFwiO1xuaW1wb3J0IHsgRHJhZnQwNCwgZHJhZnQwNENvbmZpZyB9IGZyb20gXCIuL2xpYi9kcmFmdDA0XCI7XG5pbXBvcnQgeyBEcmFmdDA2LCBkcmFmdDA2Q29uZmlnIH0gZnJvbSBcIi4vbGliL2RyYWZ0MDZcIjtcbmltcG9ydCB7IERyYWZ0MDcsIGRyYWZ0MDdDb25maWcgfSBmcm9tIFwiLi9saWIvZHJhZnQwN1wiO1xuaW1wb3J0IHsgRHJhZnQyMDE5LCBkcmFmdDIwMTlDb25maWcgfSBmcm9tIFwiLi9saWIvZHJhZnQyMDE5XCI7XG5pbXBvcnQgeyBKc29uRWRpdG9yLCBkcmFmdEpzb25FZGl0b3JDb25maWcgfSBmcm9tIFwiLi9saWIvanNvbmVkaXRvclwiO1xuaW1wb3J0IHsgaXNKc29uRXJyb3IgfSBmcm9tIFwiLi9saWIvdHlwZXNcIjtcbmltcG9ydCB7IGlzU2NoZW1hTm9kZSwgY3JlYXRlTm9kZSB9IGZyb20gXCIuL2xpYi9zY2hlbWFOb2RlXCI7XG5jb25zdCBjb25maWcgPSB7IHN0cmluZ3MgfTtcbmV4cG9ydCB7IGNvbmZpZywgY3JlYXRlQ3VzdG9tRXJyb3IsIGNyZWF0ZUVycm9yLCBjcmVhdGVOb2RlLCAvLyB2MTBcbkRyYWZ0LCBEcmFmdDA0LCAvLyBjb3JlIGltcGxlbWVudGluZyBkcmFmdDA0IHNwZWNzXG5kcmFmdDA0Q29uZmlnLCAvLyBjb25maWcgaW1wbGVtZW50aW5nIGRyYWZ0MDQgc3BlY3NcbkRyYWZ0MDYsIC8vIGNvcmUgaW1wbGVtZW50aW5nIGRyYWZ0MDYgc3BlY3NcbmRyYWZ0MDZDb25maWcsIC8vIGNvbmZpZyBpbXBsZW1lbnRpbmcgZHJhZnQwNiBzcGVjc1xuRHJhZnQwNywgLy8gY29yZSBpbXBsZW1lbnRpbmcgZHJhZnQwNyBzcGVjc1xuZHJhZnQwN0NvbmZpZywgLy8gY29uZmlnIGltcGxlbWVudGluZyBkcmFmdDA3IHNwZWNzXG5EcmFmdDIwMTksIC8vIGNvcmUgaW1wbGVtZW50aW5nIGRyYWZ0MjAxOS0wOSBzcGVjc1xuZHJhZnQyMDE5Q29uZmlnLCAvLyBjb25maWcgaW1wbGVtZW50aW5nIGRyYWZ0MjAxOS0wOSBzcGVjc1xuZHJhZnRKc29uRWRpdG9yQ29uZmlnLCAvLyBhZGp1c3RlZCBjb25maWcgb2YgZHJhZnQwNCB0byBiZXR0ZXIgc3VwcG9ydCB0aGUganNvbi1lZGl0b3JcbmdldFR5cGVPZiwgLy8gcmV0dXJucyB0aGUgamF2YXNjcmlwdCBkYXRhdHlwZVxuaXNEeW5hbWljU2NoZW1hLCAvLyB2OFxuaXNKc29uRXJyb3IsIGlzU2NoZW1hTm9kZSwgLy8gdjEwXG5Kc29uRWRpdG9yLCAvLyBhZGp1c3RlZCBjb3JlIG9mIGRyYWZ0MDcgdG8gYmV0dGVyIHN1cHBvcnQgdGhlIGpzb24tZWRpdG9yXG5tZXJnZVNjaGVtYSwgLy8gdjhcbnJlZHVjZVNjaGVtYSwgLy8gdjhcbnJlbmRlciwgcmVzb2x2ZUFsbE9mLCByZXNvbHZlRHluYW1pY1NjaGVtYSwgLy8gdjhcbnJlc29sdmVPbmVPZiwgcmVzb2x2ZU9uZU9mRnV6enksIHJlc29sdmVSZWZTdHJpY3QsIHJlc29sdmVSZWYsIHNldHRpbmdzLCB2YWxpZGF0ZUFzeW5jIC8vIGFzeW5jIHZhbGlkYXRpb24gb2YgZGF0YSBieSBhIHNjaGVtYVxuIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1399\n')},2017:module=>{"use strict";eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2017\n")},2084:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// Generated automatically by nearley, version 2.20.1\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d) { return d[0]; }\nconst deepFlatten = (arr) => [].concat(...arr.map((v) => (Array.isArray(v) ? deepFlatten(v) : v)));\nfunction flat_string(d) {\n    if (d) {\n        if (Array.isArray(d))\n            return deepFlatten(d).join("");\n        return d;\n    }\n    return "";\n}\n;\n;\n;\n;\nconst grammar = {\n    Lexer: undefined,\n    ParserRules: [\n        { "name": "Reverse_path", "symbols": ["Path"] },\n        { "name": "Reverse_path$string$1", "symbols": [{ "literal": "<" }, { "literal": ">" }], "postprocess": (d) => d.join(\'\') },\n        { "name": "Reverse_path", "symbols": ["Reverse_path$string$1"] },\n        { "name": "Forward_path$subexpression$1$subexpression$1", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": "@" }], "postprocess": function (d) { return d.join(""); } },\n        { "name": "Forward_path$subexpression$1", "symbols": ["Forward_path$subexpression$1$subexpression$1", "Domain", { "literal": ">" }] },\n        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$1"] },\n        { "name": "Forward_path$subexpression$2", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": ">" }], "postprocess": function (d) { return d.join(""); } },\n        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$2"] },\n        { "name": "Forward_path", "symbols": ["Path"] },\n        { "name": "Path$ebnf$1$subexpression$1", "symbols": ["A_d_l", { "literal": ":" }] },\n        { "name": "Path$ebnf$1", "symbols": ["Path$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "Path$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "Path", "symbols": [{ "literal": "<" }, "Path$ebnf$1", "Mailbox", { "literal": ">" }] },\n        { "name": "A_d_l$ebnf$1", "symbols": [] },\n        { "name": "A_d_l$ebnf$1$subexpression$1", "symbols": [{ "literal": "," }, "At_domain"] },\n        { "name": "A_d_l$ebnf$1", "symbols": ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "A_d_l", "symbols": ["At_domain", "A_d_l$ebnf$1"] },\n        { "name": "At_domain", "symbols": [{ "literal": "@" }, "Domain"] },\n        { "name": "Domain$ebnf$1", "symbols": [] },\n        { "name": "Domain$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "sub_domain"] },\n        { "name": "Domain$ebnf$1", "symbols": ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Domain", "symbols": ["sub_domain", "Domain$ebnf$1"] },\n        { "name": "sub_domain", "symbols": ["U_label"] },\n        { "name": "Let_dig", "symbols": ["ALPHA_DIGIT"], "postprocess": id },\n        { "name": "Ldh_str$ebnf$1", "symbols": [] },\n        { "name": "Ldh_str$ebnf$1", "symbols": ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Ldh_str", "symbols": ["Ldh_str$ebnf$1", "Let_dig"] },\n        { "name": "U_Let_dig", "symbols": ["ALPHA_DIGIT_U"], "postprocess": id },\n        { "name": "U_Ldh_str$ebnf$1", "symbols": [] },\n        { "name": "U_Ldh_str$ebnf$1", "symbols": ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "U_Ldh_str", "symbols": ["U_Ldh_str$ebnf$1", "U_Let_dig"] },\n        { "name": "U_label$ebnf$1$subexpression$1", "symbols": ["U_Ldh_str"] },\n        { "name": "U_label$ebnf$1", "symbols": ["U_label$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "U_label$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "U_label", "symbols": ["U_Let_dig", "U_label$ebnf$1"] },\n        { "name": "address_literal$subexpression$1", "symbols": ["IPv4_address_literal"] },\n        { "name": "address_literal$subexpression$1", "symbols": ["IPv6_address_literal"] },\n        { "name": "address_literal$subexpression$1", "symbols": ["General_address_literal"] },\n        { "name": "address_literal", "symbols": [{ "literal": "[" }, "address_literal$subexpression$1", { "literal": "]" }] },\n        { "name": "non_local_part", "symbols": ["Domain"], "postprocess": function (d) {\n                return { DomainName: flat_string(d[0]) };\n            }\n        },\n        { "name": "non_local_part", "symbols": ["address_literal"], "postprocess": function (d) {\n                return { AddressLiteral: flat_string(d[0]) };\n            }\n        },\n        { "name": "Mailbox", "symbols": ["Local_part", { "literal": "@" }, "non_local_part"], "postprocess": function (d) {\n                return { localPart: flat_string(d[0]), domainPart: flat_string(d[2]) };\n            }\n        },\n        { "name": "Local_part", "symbols": ["Dot_string"], "postprocess": function (d) {\n                return { DotString: flat_string(d[0]) };\n            }\n        },\n        { "name": "Local_part", "symbols": ["Quoted_string"], "postprocess": function (d) {\n                return { QuotedString: flat_string(d[0]) };\n            }\n        },\n        { "name": "Dot_string$ebnf$1", "symbols": [] },\n        { "name": "Dot_string$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "Atom"] },\n        { "name": "Dot_string$ebnf$1", "symbols": ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Dot_string", "symbols": ["Atom", "Dot_string$ebnf$1"] },\n        { "name": "Atom$ebnf$1", "symbols": [/[0-9A-Za-z!#$%&\'*+\\-/=?^_`{|}~\\u0080-\\uFFFF/]/] },\n        { "name": "Atom$ebnf$1", "symbols": ["Atom$ebnf$1", /[0-9A-Za-z!#$%&\'*+\\-/=?^_`{|}~\\u0080-\\uFFFF/]/], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Atom", "symbols": ["Atom$ebnf$1"] },\n        { "name": "Quoted_string$ebnf$1", "symbols": [] },\n        { "name": "Quoted_string$ebnf$1", "symbols": ["Quoted_string$ebnf$1", "QcontentSMTP"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "Quoted_string", "symbols": ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },\n        { "name": "QcontentSMTP", "symbols": ["qtextSMTP"] },\n        { "name": "QcontentSMTP", "symbols": ["quoted_pairSMTP"] },\n        { "name": "quoted_pairSMTP", "symbols": [{ "literal": "\\\\" }, /[\\x20-\\x7e]/] },\n        { "name": "qtextSMTP", "symbols": [/[\\x20-\\x21\\x23-\\x5b\\x5d-\\x7e\\u0080-\\uFFFF]/], "postprocess": id },\n        { "name": "IPv4_address_literal$macrocall$2", "symbols": [{ "literal": "." }, "Snum"] },\n        { "name": "IPv4_address_literal$macrocall$1", "symbols": ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },\n        { "name": "IPv4_address_literal", "symbols": ["Snum", "IPv4_address_literal$macrocall$1"] },\n        { "name": "IPv6_address_literal$subexpression$1", "symbols": [/[iI]/, /[pP]/, /[vV]/, { "literal": "6" }, { "literal": ":" }], "postprocess": function (d) { return d.join(""); } },\n        { "name": "IPv6_address_literal", "symbols": ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },\n        { "name": "General_address_literal$ebnf$1", "symbols": ["dcontent"] },\n        { "name": "General_address_literal$ebnf$1", "symbols": ["General_address_literal$ebnf$1", "dcontent"], "postprocess": (d) => d[0].concat([d[1]]) },\n        { "name": "General_address_literal", "symbols": ["Standardized_tag", { "literal": ":" }, "General_address_literal$ebnf$1"] },\n        { "name": "Standardized_tag", "symbols": ["Ldh_str"] },\n        { "name": "dcontent", "symbols": [/[\\x21-\\x5a\\x5e-\\x7e]/], "postprocess": id },\n        { "name": "Snum", "symbols": ["DIGIT"] },\n        { "name": "Snum$subexpression$1", "symbols": [/[1-9]/, "DIGIT"] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$1"] },\n        { "name": "Snum$subexpression$2", "symbols": [{ "literal": "1" }, "DIGIT", "DIGIT"] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$2"] },\n        { "name": "Snum$subexpression$3", "symbols": [{ "literal": "2" }, /[0-4]/, "DIGIT"] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$3"] },\n        { "name": "Snum$subexpression$4", "symbols": [{ "literal": "2" }, { "literal": "5" }, /[0-5]/] },\n        { "name": "Snum", "symbols": ["Snum$subexpression$4"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6_full"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6_comp"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6v4_full"] },\n        { "name": "IPv6_addr", "symbols": ["IPv6v4_comp"] },\n        { "name": "IPv6_hex", "symbols": ["HEXDIG"] },\n        { "name": "IPv6_hex$subexpression$1", "symbols": ["HEXDIG", "HEXDIG"] },\n        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$1"] },\n        { "name": "IPv6_hex$subexpression$2", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG"] },\n        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$2"] },\n        { "name": "IPv6_hex$subexpression$3", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },\n        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$3"] },\n        { "name": "IPv6_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6_full$macrocall$1", "symbols": ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },\n        { "name": "IPv6_full", "symbols": ["IPv6_hex", "IPv6_full$macrocall$1"] },\n        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },\n        { "name": "IPv6_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },\n        { "name": "IPv6_comp$ebnf$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "IPv6_comp$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join(\'\') },\n        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },\n        { "name": "IPv6_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },\n        { "name": "IPv6_comp$ebnf$2", "symbols": ["IPv6_comp$ebnf$2$subexpression$1"], "postprocess": id },\n        { "name": "IPv6_comp$ebnf$2", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6_comp", "symbols": ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },\n        { "name": "IPv6v4_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6v4_full$macrocall$1", "symbols": ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },\n        { "name": "IPv6v4_full", "symbols": ["IPv6_hex", "IPv6v4_full$macrocall$1", { "literal": ":" }, "IPv4_address_literal"] },\n        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },\n        { "name": "IPv6v4_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },\n        { "name": "IPv6v4_comp$ebnf$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1"], "postprocess": id },\n        { "name": "IPv6v4_comp$ebnf$1", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6v4_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join(\'\') },\n        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },\n        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },\n        { "name": "IPv6v4_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { "literal": ":" }] },\n        { "name": "IPv6v4_comp$ebnf$2", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1"], "postprocess": id },\n        { "name": "IPv6v4_comp$ebnf$2", "symbols": [], "postprocess": () => null },\n        { "name": "IPv6v4_comp", "symbols": ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },\n        { "name": "DIGIT", "symbols": [/[0-9]/], "postprocess": id },\n        { "name": "ALPHA_DIGIT_U", "symbols": [/[0-9A-Za-z\\u0080-\\uFFFF]/], "postprocess": id },\n        { "name": "ALPHA_DIGIT", "symbols": [/[0-9A-Za-z]/], "postprocess": id },\n        { "name": "ALPHA_DIG_DASH", "symbols": [/[-0-9A-Za-z]/], "postprocess": id },\n        { "name": "ALPHA_DIG_DASH_U", "symbols": [/[-0-9A-Za-z\\u0080-\\uFFFF]/], "postprocess": id },\n        { "name": "HEXDIG", "symbols": [/[0-9A-Fa-f]/], "postprocess": id },\n        { "name": "DQUOTE", "symbols": [{ "literal": "\\"" }], "postprocess": id }\n    ],\n    ParserStart: "Reverse_path",\n};\nexports["default"] = grammar;\n//# sourceMappingURL=grammar.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ2pILFVBQVUsNk5BQTZOO0FBQ3ZPLFVBQVUseUhBQXlIO0FBQ25JLFVBQVUsb0dBQW9HO0FBQzlHLFVBQVUsd0VBQXdFO0FBQ2xGLFVBQVUsOENBQThDLGdCQUFnQixJQUFJLGdCQUFnQixxQ0FBcUM7QUFDakksVUFBVSx3RUFBd0UsZ0JBQWdCLGVBQWU7QUFDakgsVUFBVSw2TkFBNk47QUFDdk8sVUFBVSwwSEFBMEgsZ0JBQWdCLEdBQUc7QUFDdkosVUFBVSxvR0FBb0c7QUFDOUcsVUFBVSx3RUFBd0U7QUFDbEYsVUFBVSxnSUFBZ0k7QUFDMUksVUFBVSwwREFBMEQ7QUFDcEUsVUFBVSxxRkFBcUY7QUFDL0YsVUFBVSxzRUFBc0U7QUFDaEYsVUFBVSwwRUFBMEU7QUFDcEYsVUFBVSx5RkFBeUY7QUFDbkcsVUFBVSxpRUFBaUU7QUFDM0UsVUFBVSxnQ0FBZ0MsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2FwL2Nzbi1pbnRlcm9wLXJlbmRlcmVyLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvc210cC1hZGRyZXNzLXBhcnNlci9kaXN0L2xpYi9ncmFtbWFyLmpzP2Y5NzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBuZWFybGV5LCB2ZXJzaW9uIDIuMjAuMVxuLy8gaHR0cDovL2dpdGh1Yi5jb20vSGFyZG1hdGgxMjMvbmVhcmxleVxuLy8gQnlwYXNzZXMgVFM2MTMzLiBBbGxvdyBkZWNsYXJlZCBidXQgdW51c2VkIGZ1bmN0aW9ucy5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGlkKGQpIHsgcmV0dXJuIGRbMF07IH1cbmNvbnN0IGRlZXBGbGF0dGVuID0gKGFycikgPT4gW10uY29uY2F0KC4uLmFyci5tYXAoKHYpID0+IChBcnJheS5pc0FycmF5KHYpID8gZGVlcEZsYXR0ZW4odikgOiB2KSkpO1xuZnVuY3Rpb24gZmxhdF9zdHJpbmcoZCkge1xuICAgIGlmIChkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlZXBGbGF0dGVuKGQpLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbjtcbjtcbjtcbjtcbmNvbnN0IGdyYW1tYXIgPSB7XG4gICAgTGV4ZXI6IHVuZGVmaW5lZCxcbiAgICBQYXJzZXJSdWxlczogW1xuICAgICAgICB7IFwibmFtZVwiOiBcIlJldmVyc2VfcGF0aFwiLCBcInN5bWJvbHNcIjogW1wiUGF0aFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlJldmVyc2VfcGF0aCRzdHJpbmckMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiPFwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiPlwiIH1dLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkLmpvaW4oJycpIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUmV2ZXJzZV9wYXRoXCIsIFwic3ltYm9sc1wiOiBbXCJSZXZlcnNlX3BhdGgkc3RyaW5nJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJGb3J3YXJkX3BhdGgkc3ViZXhwcmVzc2lvbiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiPFwiIH0sIC9bcFBdLywgL1tvT10vLCAvW3NTXS8sIC9bdFRdLywgL1ttTV0vLCAvW2FBXS8sIC9bc1NdLywgL1t0VF0vLCAvW2VFXS8sIC9bclJdLywgeyBcImxpdGVyYWxcIjogXCJAXCIgfV0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuam9pbihcIlwiKTsgfSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkZvcndhcmRfcGF0aCRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkZvcndhcmRfcGF0aCRzdWJleHByZXNzaW9uJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwiRG9tYWluXCIsIHsgXCJsaXRlcmFsXCI6IFwiPlwiIH1dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiRm9yd2FyZF9wYXRoXCIsIFwic3ltYm9sc1wiOiBbXCJGb3J3YXJkX3BhdGgkc3ViZXhwcmVzc2lvbiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiRm9yd2FyZF9wYXRoJHN1YmV4cHJlc3Npb24kMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiPFwiIH0sIC9bcFBdLywgL1tvT10vLCAvW3NTXS8sIC9bdFRdLywgL1ttTV0vLCAvW2FBXS8sIC9bc1NdLywgL1t0VF0vLCAvW2VFXS8sIC9bclJdLywgeyBcImxpdGVyYWxcIjogXCI+XCIgfV0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuam9pbihcIlwiKTsgfSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkZvcndhcmRfcGF0aFwiLCBcInN5bWJvbHNcIjogW1wiRm9yd2FyZF9wYXRoJHN1YmV4cHJlc3Npb24kMlwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkZvcndhcmRfcGF0aFwiLCBcInN5bWJvbHNcIjogW1wiUGF0aFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlBhdGgkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wiQV9kX2xcIiwgeyBcImxpdGVyYWxcIjogXCI6XCIgfV0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJQYXRoJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiUGF0aCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUGF0aCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJQYXRoXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI8XCIgfSwgXCJQYXRoJGVibmYkMVwiLCBcIk1haWxib3hcIiwgeyBcImxpdGVyYWxcIjogXCI+XCIgfV0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBX2RfbCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQV9kX2wkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiLFwiIH0sIFwiQXRfZG9tYWluXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQV9kX2wkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJBX2RfbCRlYm5mJDFcIiwgXCJBX2RfbCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkWzBdLmNvbmNhdChbZFsxXV0pIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQV9kX2xcIiwgXCJzeW1ib2xzXCI6IFtcIkF0X2RvbWFpblwiLCBcIkFfZF9sJGVibmYkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkF0X2RvbWFpblwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiQFwiIH0sIFwiRG9tYWluXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiRG9tYWluJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJEb21haW4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiLlwiIH0sIFwic3ViX2RvbWFpblwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvbWFpbiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkRvbWFpbiRlYm5mJDFcIiwgXCJEb21haW4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvbWFpblwiLCBcInN5bWJvbHNcIjogW1wic3ViX2RvbWFpblwiLCBcIkRvbWFpbiRlYm5mJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJzdWJfZG9tYWluXCIsIFwic3ltYm9sc1wiOiBbXCJVX2xhYmVsXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiTGV0X2RpZ1wiLCBcInN5bWJvbHNcIjogW1wiQUxQSEFfRElHSVRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJMZGhfc3RyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJMZGhfc3RyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiTGRoX3N0ciRlYm5mJDFcIiwgXCJBTFBIQV9ESUdfREFTSFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkxkaF9zdHJcIiwgXCJzeW1ib2xzXCI6IFtcIkxkaF9zdHIkZWJuZiQxXCIsIFwiTGV0X2RpZ1wiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfTGV0X2RpZ1wiLCBcInN5bWJvbHNcIjogW1wiQUxQSEFfRElHSVRfVVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfTGRoX3N0ciRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiVV9MZGhfc3RyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiVV9MZGhfc3RyJGVibmYkMVwiLCBcIkFMUEhBX0RJR19EQVNIX1VcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSkgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJVX0xkaF9zdHJcIiwgXCJzeW1ib2xzXCI6IFtcIlVfTGRoX3N0ciRlYm5mJDFcIiwgXCJVX0xldF9kaWdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJVX2xhYmVsJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIlVfTGRoX3N0clwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfbGFiZWwkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJVX2xhYmVsJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJVX2xhYmVsJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gbnVsbCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlVfbGFiZWxcIiwgXCJzeW1ib2xzXCI6IFtcIlVfTGV0X2RpZ1wiLCBcIlVfbGFiZWwkZWJuZiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiYWRkcmVzc19saXRlcmFsJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wiSVB2NF9hZGRyZXNzX2xpdGVyYWxcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJhZGRyZXNzX2xpdGVyYWwkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2FkZHJlc3NfbGl0ZXJhbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcImFkZHJlc3NfbGl0ZXJhbCRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkdlbmVyYWxfYWRkcmVzc19saXRlcmFsXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiYWRkcmVzc19saXRlcmFsXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCJbXCIgfSwgXCJhZGRyZXNzX2xpdGVyYWwkc3ViZXhwcmVzc2lvbiQxXCIsIHsgXCJsaXRlcmFsXCI6IFwiXVwiIH1dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwibm9uX2xvY2FsX3BhcnRcIiwgXCJzeW1ib2xzXCI6IFtcIkRvbWFpblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IERvbWFpbk5hbWU6IGZsYXRfc3RyaW5nKGRbMF0pIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwibm9uX2xvY2FsX3BhcnRcIiwgXCJzeW1ib2xzXCI6IFtcImFkZHJlc3NfbGl0ZXJhbFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IEFkZHJlc3NMaXRlcmFsOiBmbGF0X3N0cmluZyhkWzBdKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIk1haWxib3hcIiwgXCJzeW1ib2xzXCI6IFtcIkxvY2FsX3BhcnRcIiwgeyBcImxpdGVyYWxcIjogXCJAXCIgfSwgXCJub25fbG9jYWxfcGFydFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGxvY2FsUGFydDogZmxhdF9zdHJpbmcoZFswXSksIGRvbWFpblBhcnQ6IGZsYXRfc3RyaW5nKGRbMl0pIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiTG9jYWxfcGFydFwiLCBcInN5bWJvbHNcIjogW1wiRG90X3N0cmluZ1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IERvdFN0cmluZzogZmxhdF9zdHJpbmcoZFswXSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJMb2NhbF9wYXJ0XCIsIFwic3ltYm9sc1wiOiBbXCJRdW90ZWRfc3RyaW5nXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgUXVvdGVkU3RyaW5nOiBmbGF0X3N0cmluZyhkWzBdKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmckZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmckZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiLlwiIH0sIFwiQXRvbVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmckZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJEb3Rfc3RyaW5nJGVibmYkMVwiLCBcIkRvdF9zdHJpbmckZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRvdF9zdHJpbmdcIiwgXCJzeW1ib2xzXCI6IFtcIkF0b21cIiwgXCJEb3Rfc3RyaW5nJGVibmYkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkF0b20kZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbL1swLTlBLVphLXohIyQlJicqK1xcLS89P15fYHt8fX5cXHUwMDgwLVxcdUZGRkYvXS9dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQXRvbSRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIkF0b20kZWJuZiQxXCIsIC9bMC05QS1aYS16ISMkJSYnKitcXC0vPT9eX2B7fH1+XFx1MDA4MC1cXHVGRkZGL10vXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkF0b21cIiwgXCJzeW1ib2xzXCI6IFtcIkF0b20kZWJuZiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUXVvdGVkX3N0cmluZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUXVvdGVkX3N0cmluZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIlF1b3RlZF9zdHJpbmckZWJuZiQxXCIsIFwiUWNvbnRlbnRTTVRQXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkWzBdLmNvbmNhdChbZFsxXV0pIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiUXVvdGVkX3N0cmluZ1wiLCBcInN5bWJvbHNcIjogW1wiRFFVT1RFXCIsIFwiUXVvdGVkX3N0cmluZyRlYm5mJDFcIiwgXCJEUVVPVEVcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJRY29udGVudFNNVFBcIiwgXCJzeW1ib2xzXCI6IFtcInF0ZXh0U01UUFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlFjb250ZW50U01UUFwiLCBcInN5bWJvbHNcIjogW1wicXVvdGVkX3BhaXJTTVRQXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwicXVvdGVkX3BhaXJTTVRQXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCJcXFxcXCIgfSwgL1tcXHgyMC1cXHg3ZV0vXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcInF0ZXh0U01UUFwiLCBcInN5bWJvbHNcIjogWy9bXFx4MjAtXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXFx1MDA4MC1cXHVGRkZGXS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NF9hZGRyZXNzX2xpdGVyYWwkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIi5cIiB9LCBcIlNudW1cIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiSVB2NF9hZGRyZXNzX2xpdGVyYWwkbWFjcm9jYWxsJDJcIiwgXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbCRtYWNyb2NhbGwkMlwiLCBcIklQdjRfYWRkcmVzc19saXRlcmFsJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NF9hZGRyZXNzX2xpdGVyYWxcIiwgXCJzeW1ib2xzXCI6IFtcIlNudW1cIiwgXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbCRtYWNyb2NhbGwkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfYWRkcmVzc19saXRlcmFsJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogWy9baUldLywgL1twUF0vLCAvW3ZWXS8sIHsgXCJsaXRlcmFsXCI6IFwiNlwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiOlwiIH1dLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmpvaW4oXCJcIik7IH0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2FkZHJlc3NfbGl0ZXJhbFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9hZGRyZXNzX2xpdGVyYWwkc3ViZXhwcmVzc2lvbiQxXCIsIFwiSVB2Nl9hZGRyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiR2VuZXJhbF9hZGRyZXNzX2xpdGVyYWwkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJkY29udGVudFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkdlbmVyYWxfYWRkcmVzc19saXRlcmFsJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiR2VuZXJhbF9hZGRyZXNzX2xpdGVyYWwkZWJuZiQxXCIsIFwiZGNvbnRlbnRcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSkgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJHZW5lcmFsX2FkZHJlc3NfbGl0ZXJhbFwiLCBcInN5bWJvbHNcIjogW1wiU3RhbmRhcmRpemVkX3RhZ1wiLCB7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCBcIkdlbmVyYWxfYWRkcmVzc19saXRlcmFsJGVibmYkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlN0YW5kYXJkaXplZF90YWdcIiwgXCJzeW1ib2xzXCI6IFtcIkxkaF9zdHJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJkY29udGVudFwiLCBcInN5bWJvbHNcIjogWy9bXFx4MjEtXFx4NWFcXHg1ZS1cXHg3ZV0vXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlNudW1cIiwgXCJzeW1ib2xzXCI6IFtcIkRJR0lUXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFsvWzEtOV0vLCBcIkRJR0lUXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bVwiLCBcInN5bWJvbHNcIjogW1wiU251bSRzdWJleHByZXNzaW9uJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJTbnVtJHN1YmV4cHJlc3Npb24kMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiMVwiIH0sIFwiRElHSVRcIiwgXCJESUdJVFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIlNudW1cIiwgXCJzeW1ib2xzXCI6IFtcIlNudW0kc3ViZXhwcmVzc2lvbiQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bSRzdWJleHByZXNzaW9uJDNcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIjJcIiB9LCAvWzAtNF0vLCBcIkRJR0lUXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bVwiLCBcInN5bWJvbHNcIjogW1wiU251bSRzdWJleHByZXNzaW9uJDNcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJTbnVtJHN1YmV4cHJlc3Npb24kNFwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiMlwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiNVwiIH0sIC9bMC01XS9dIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiU251bVwiLCBcInN5bWJvbHNcIjogW1wiU251bSRzdWJleHByZXNzaW9uJDRcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2FkZHJcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfZnVsbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfYWRkclwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9jb21wXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9hZGRyXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2djRfZnVsbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfYWRkclwiLCBcInN5bWJvbHNcIjogW1wiSVB2NnY0X2NvbXBcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSEVYRElHXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJIRVhESUdcIiwgXCJIRVhESUdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQxXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQyXCIsIFwic3ltYm9sc1wiOiBbXCJIRVhESUdcIiwgXCJIRVhESUdcIiwgXCJIRVhESUdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQzXCIsIFwic3ltYm9sc1wiOiBbXCJIRVhESUdcIiwgXCJIRVhESUdcIiwgXCJIRVhESUdcIiwgXCJIRVhESUdcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2hleFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXgkc3ViZXhwcmVzc2lvbiQzXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI6XCIgfSwgXCJJUHY2X2hleFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfZnVsbCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9mdWxsJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9mdWxsXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2hleFwiLCBcIklQdjZfZnVsbCRtYWNyb2NhbGwkMVwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI6XCIgfSwgXCJJUHY2X2hleFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJJUHY2X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfaGV4XCIsIFwiSVB2Nl9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXAkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXAkc3RyaW5nJDFcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCB7IFwibGl0ZXJhbFwiOiBcIjpcIiB9XSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZC5qb2luKCcnKSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbeyBcImxpdGVyYWxcIjogXCI6XCIgfSwgXCJJUHY2X2hleFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2Nl9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJJUHY2X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2Nl9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfaGV4XCIsIFwiSVB2Nl9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXAkZWJuZiQyXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIklQdjZfY29tcCRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2X2NvbXBcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZfY29tcCRlYm5mJDFcIiwgXCJJUHY2X2NvbXAkc3RyaW5nJDFcIiwgXCJJUHY2X2NvbXAkZWJuZiQyXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCBcIklQdjZfaGV4XCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZ2NF9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDJcIiwgXCJJUHY2djRfZnVsbCRtYWNyb2NhbGwkMlwiLCBcIklQdjZ2NF9mdWxsJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2Z1bGwkbWFjcm9jYWxsJDJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfZnVsbFwiLCBcInN5bWJvbHNcIjogW1wiSVB2Nl9oZXhcIiwgXCJJUHY2djRfZnVsbCRtYWNyb2NhbGwkMVwiLCB7IFwibGl0ZXJhbFwiOiBcIjpcIiB9LCBcIklQdjRfYWRkcmVzc19saXRlcmFsXCJdIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiOlwiIH0sIFwiSVB2Nl9oZXhcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2djRfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2NvbXAkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZ2NF9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2hleFwiLCBcIklQdjZ2NF9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZ2NF9jb21wJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRzdHJpbmckMVwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiOlwiIH0sIHsgXCJsaXRlcmFsXCI6IFwiOlwiIH1dLCBcInBvc3Rwcm9jZXNzXCI6IChkKSA9PiBkLmpvaW4oJycpIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSVB2NnY0X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3sgXCJsaXRlcmFsXCI6IFwiOlwiIH0sIFwiSVB2Nl9oZXhcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2djRfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiSVB2NnY0X2NvbXAkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIklQdjZ2NF9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJJUHY2X2hleFwiLCBcIklQdjZ2NF9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgeyBcImxpdGVyYWxcIjogXCI6XCIgfV0gfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtcIklQdjZ2NF9jb21wJGVibmYkMiRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcCRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGwgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJJUHY2djRfY29tcFwiLCBcInN5bWJvbHNcIjogW1wiSVB2NnY0X2NvbXAkZWJuZiQxXCIsIFwiSVB2NnY0X2NvbXAkc3RyaW5nJDFcIiwgXCJJUHY2djRfY29tcCRlYm5mJDJcIiwgXCJJUHY0X2FkZHJlc3NfbGl0ZXJhbFwiXSB9LFxuICAgICAgICB7IFwibmFtZVwiOiBcIkRJR0lUXCIsIFwic3ltYm9sc1wiOiBbL1swLTldL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9ESUdJVF9VXCIsIFwic3ltYm9sc1wiOiBbL1swLTlBLVphLXpcXHUwMDgwLVxcdUZGRkZdL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9ESUdJVFwiLCBcInN5bWJvbHNcIjogWy9bMC05QS1aYS16XS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiQUxQSEFfRElHX0RBU0hcIiwgXCJzeW1ib2xzXCI6IFsvWy0wLTlBLVphLXpdL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9ESUdfREFTSF9VXCIsIFwic3ltYm9sc1wiOiBbL1stMC05QS1aYS16XFx1MDA4MC1cXHVGRkZGXS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkIH0sXG4gICAgICAgIHsgXCJuYW1lXCI6IFwiSEVYRElHXCIsIFwic3ltYm9sc1wiOiBbL1swLTlBLUZhLWZdL10sIFwicG9zdHByb2Nlc3NcIjogaWQgfSxcbiAgICAgICAgeyBcIm5hbWVcIjogXCJEUVVPVEVcIiwgXCJzeW1ib2xzXCI6IFt7IFwibGl0ZXJhbFwiOiBcIlxcXCJcIiB9XSwgXCJwb3N0cHJvY2Vzc1wiOiBpZCB9XG4gICAgXSxcbiAgICBQYXJzZXJTdGFydDogXCJSZXZlcnNlX3BhdGhcIixcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBncmFtbWFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhbW1hci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2084\n')},2546:function(module){eval('!function(t,e){ true?module.exports=e():0}("undefined"!=typeof self?self:this,(()=>(()=>{"use strict";var t={d:(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function n(t){return"#"===t||""===t||Array.isArray(t)&&0===t.length||!1}t.r(e),t.d(e,{default:()=>_,get:()=>s,isRoot:()=>n,join:()=>P,remove:()=>m,removeUndefinedItems:()=>v,set:()=>g,split:()=>f,splitLast:()=>O});const o=/~1/g,r=/~0/g,i=/(^#?\\/?)/g;function l(t){return t.replace(o,"/").replace(r,"~")}function u(t){return l(decodeURIComponent(t))}function f(t){if(null==t||"string"!=typeof t||n(t))return Array.isArray(t)?t:[];const e=t.indexOf("#")>=0?u:l,o=(t=t.replace(i,"")).split("/");for(let t=0,n=o.length;t<n;t+=1)o[t]=e(o[t]);return o}function s(t,e,o=void 0){if(null==e||null==t)return o;if(n(e))return t;const r=c(t,f(e));return void 0===r?o:r}function c(t,e){const n=e.shift();if(void 0!==t)return void 0!==n?c(t[n],e):t}const p=/^\\[.*\\]$/,d=/^\\[(.+)\\]$/;function a(t,e){return"__proto__"===t||"constructor"==t&&e.length>0&&"prototype"==e[0]}function g(t,e,n){if(null==e)return t;const o=f(e);if(0===o.length)return t;null==t&&(t=p.test(o[0])?[]:{});let r,i,l=t;for(;o.length>1;)r=o.shift(),i=p.test(o[0]),a(r,o)||(l=h(l,r,i));return r=o.pop(),y(l,r,n),t}function y(t,e,n){let o;const r=e.match(d);"[]"===e&&Array.isArray(t)?t.push(n):r?(o=r.pop(),t[o]=n):t[e]=n}function h(t,e,n){var o,r;const i=null!==(r=null===(o=e.match(d))||void 0===o?void 0:o.pop())&&void 0!==r?r:e;if(null!=t[i])return t[i];const l=n?[]:{};return y(t,e,l),l}function v(t){let e=0,n=0;for(;e+n<t.length;)void 0===t[e+n]&&(n+=1),t[e]=t[e+n],e+=1;return t.length=t.length-n,t}function m(t,e,n){const o=f(e),r=o.pop(),i=s(t,o);return i&&delete i[r],Array.isArray(i)&&!0!==n&&v(i),t}const j=/~/g,b=/\\//g;function A(t,e){if(0===t.length)return e?"#":"";for(let n=0,o=t.length;n<o;n+=1)t[n]=t[n].replace(j,"~0").replace(b,"~1"),e&&(t[n]=encodeURIComponent(t[n]));return(e?"#/":"/")+t.join("/")}function P(t,...e){const n=[];if(Array.isArray(t))return A(t,!0===arguments[1]);const o=arguments[arguments.length-1],r="boolean"==typeof o?o:t&&"#"===t[0];for(let t=0,e=arguments.length;t<e;t+=1)n.push.apply(n,f(arguments[t]));const i=[];for(let t=0,e=n.length;t<e;t+=1)if(".."===n[t]){if(0===i.length)return r?"#":"";i.pop()}else i.push(n[t]);return A(i,r)}function O(t){const e=f(t);if(0===e.length)return"string"==typeof t&&"#"===t[0]?["#",e[0]]:["",void 0];if(1===e.length)return"#"===t[0]?["#",e[0]]:["",e[0]];const n=e.pop();return[P(e,"#"===t[0]),n]}const _={get:s,set:g,remove:m,join:P,split:f,splitLast:O,isRoot:n,removeUndefinedItems:v};return e})()));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU0Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUFtSSxDQUFDLCtDQUErQyxhQUFhLE9BQU8sVUFBVSwrREFBK0QsdUJBQXVCLEVBQUUsMERBQTBELDRGQUE0RixlQUFlLHdDQUF3QyxTQUFTLEdBQUcsTUFBTSxjQUFjLDBEQUEwRCxjQUFjLDhIQUE4SCxFQUFFLG9DQUFvQyxjQUFjLHVDQUF1QyxjQUFjLGdDQUFnQyxjQUFjLGtFQUFrRSwrREFBK0QsdUJBQXVCLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLDZCQUE2QixpQkFBaUIsa0JBQWtCLHNCQUFzQixnQkFBZ0Isa0JBQWtCLDRDQUE0QyxrQ0FBa0MsZ0JBQWdCLHVFQUF1RSxrQkFBa0Isb0JBQW9CLGFBQWEseUJBQXlCLDhCQUE4QixFQUFFLFlBQVksS0FBSyxXQUFXLGlEQUFpRCw0QkFBNEIsa0JBQWtCLE1BQU0sbUJBQW1CLGlFQUFpRSxrQkFBa0IsUUFBUSxvRkFBb0YsMEJBQTBCLGdCQUFnQixrQkFBa0IsY0FBYyxZQUFZLEtBQUssYUFBYSwwQ0FBMEMsNkJBQTZCLGtCQUFrQixnQ0FBZ0MsdURBQXVELHFCQUFxQixnQkFBZ0IsZ0NBQWdDLHVCQUF1QixJQUFJLGtGQUFrRiwrQkFBK0IsbUJBQW1CLFdBQVcsa0RBQWtELDRFQUE0RSwrQkFBK0IsSUFBSSxxQ0FBcUMsV0FBVyx1QkFBdUIsSUFBSSxxQkFBcUIsZ0NBQWdDLFFBQVEsa0JBQWtCLGNBQWMsY0FBYyxhQUFhLDRFQUE0RSxzREFBc0QsZ0JBQWdCLDBCQUEwQixTQUFTLGlGQUFpRixTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzYWdvbGQvanNvbi1wb2ludGVyL2Rpc3QvanNvblBvaW50ZXIuanM/MzZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImpzb25Qb2ludGVyXCIsW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5qc29uUG9pbnRlcj1lKCk6dC5qc29uUG9pbnRlcj1lKCl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcywoKCk9PigoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXtkOihlLG4pPT57Zm9yKHZhciBvIGluIG4pdC5vKG4sbykmJiF0Lm8oZSxvKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbyx7ZW51bWVyYWJsZTohMCxnZXQ6bltvXX0pfSxvOih0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxyOnQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sZT17fTtmdW5jdGlvbiBuKHQpe3JldHVyblwiI1wiPT09dHx8XCJcIj09PXR8fEFycmF5LmlzQXJyYXkodCkmJjA9PT10Lmxlbmd0aHx8ITF9dC5yKGUpLHQuZChlLHtkZWZhdWx0OigpPT5fLGdldDooKT0+cyxpc1Jvb3Q6KCk9Pm4sam9pbjooKT0+UCxyZW1vdmU6KCk9Pm0scmVtb3ZlVW5kZWZpbmVkSXRlbXM6KCk9PnYsc2V0OigpPT5nLHNwbGl0OigpPT5mLHNwbGl0TGFzdDooKT0+T30pO2NvbnN0IG89L34xL2cscj0vfjAvZyxpPS8oXiM/XFwvPykvZztmdW5jdGlvbiBsKHQpe3JldHVybiB0LnJlcGxhY2UobyxcIi9cIikucmVwbGFjZShyLFwiflwiKX1mdW5jdGlvbiB1KHQpe3JldHVybiBsKGRlY29kZVVSSUNvbXBvbmVudCh0KSl9ZnVuY3Rpb24gZih0KXtpZihudWxsPT10fHxcInN0cmluZ1wiIT10eXBlb2YgdHx8bih0KSlyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90OltdO2NvbnN0IGU9dC5pbmRleE9mKFwiI1wiKT49MD91Omwsbz0odD10LnJlcGxhY2UoaSxcIlwiKSkuc3BsaXQoXCIvXCIpO2ZvcihsZXQgdD0wLG49by5sZW5ndGg7dDxuO3QrPTEpb1t0XT1lKG9bdF0pO3JldHVybiBvfWZ1bmN0aW9uIHModCxlLG89dm9pZCAwKXtpZihudWxsPT1lfHxudWxsPT10KXJldHVybiBvO2lmKG4oZSkpcmV0dXJuIHQ7Y29uc3Qgcj1jKHQsZihlKSk7cmV0dXJuIHZvaWQgMD09PXI/bzpyfWZ1bmN0aW9uIGModCxlKXtjb25zdCBuPWUuc2hpZnQoKTtpZih2b2lkIDAhPT10KXJldHVybiB2b2lkIDAhPT1uP2ModFtuXSxlKTp0fWNvbnN0IHA9L15cXFsuKlxcXSQvLGQ9L15cXFsoLispXFxdJC87ZnVuY3Rpb24gYSh0LGUpe3JldHVyblwiX19wcm90b19fXCI9PT10fHxcImNvbnN0cnVjdG9yXCI9PXQmJmUubGVuZ3RoPjAmJlwicHJvdG90eXBlXCI9PWVbMF19ZnVuY3Rpb24gZyh0LGUsbil7aWYobnVsbD09ZSlyZXR1cm4gdDtjb25zdCBvPWYoZSk7aWYoMD09PW8ubGVuZ3RoKXJldHVybiB0O251bGw9PXQmJih0PXAudGVzdChvWzBdKT9bXTp7fSk7bGV0IHIsaSxsPXQ7Zm9yKDtvLmxlbmd0aD4xOylyPW8uc2hpZnQoKSxpPXAudGVzdChvWzBdKSxhKHIsbyl8fChsPWgobCxyLGkpKTtyZXR1cm4gcj1vLnBvcCgpLHkobCxyLG4pLHR9ZnVuY3Rpb24geSh0LGUsbil7bGV0IG87Y29uc3Qgcj1lLm1hdGNoKGQpO1wiW11cIj09PWUmJkFycmF5LmlzQXJyYXkodCk/dC5wdXNoKG4pOnI/KG89ci5wb3AoKSx0W29dPW4pOnRbZV09bn1mdW5jdGlvbiBoKHQsZSxuKXt2YXIgbyxyO2NvbnN0IGk9bnVsbCE9PShyPW51bGw9PT0obz1lLm1hdGNoKGQpKXx8dm9pZCAwPT09bz92b2lkIDA6by5wb3AoKSkmJnZvaWQgMCE9PXI/cjplO2lmKG51bGwhPXRbaV0pcmV0dXJuIHRbaV07Y29uc3QgbD1uP1tdOnt9O3JldHVybiB5KHQsZSxsKSxsfWZ1bmN0aW9uIHYodCl7bGV0IGU9MCxuPTA7Zm9yKDtlK248dC5sZW5ndGg7KXZvaWQgMD09PXRbZStuXSYmKG4rPTEpLHRbZV09dFtlK25dLGUrPTE7cmV0dXJuIHQubGVuZ3RoPXQubGVuZ3RoLW4sdH1mdW5jdGlvbiBtKHQsZSxuKXtjb25zdCBvPWYoZSkscj1vLnBvcCgpLGk9cyh0LG8pO3JldHVybiBpJiZkZWxldGUgaVtyXSxBcnJheS5pc0FycmF5KGkpJiYhMCE9PW4mJnYoaSksdH1jb25zdCBqPS9+L2csYj0vXFwvL2c7ZnVuY3Rpb24gQSh0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZT9cIiNcIjpcIlwiO2ZvcihsZXQgbj0wLG89dC5sZW5ndGg7bjxvO24rPTEpdFtuXT10W25dLnJlcGxhY2UoaixcIn4wXCIpLnJlcGxhY2UoYixcIn4xXCIpLGUmJih0W25dPWVuY29kZVVSSUNvbXBvbmVudCh0W25dKSk7cmV0dXJuKGU/XCIjL1wiOlwiL1wiKSt0LmpvaW4oXCIvXCIpfWZ1bmN0aW9uIFAodCwuLi5lKXtjb25zdCBuPVtdO2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIEEodCwhMD09PWFyZ3VtZW50c1sxXSk7Y29uc3Qgbz1hcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSxyPVwiYm9vbGVhblwiPT10eXBlb2Ygbz9vOnQmJlwiI1wiPT09dFswXTtmb3IobGV0IHQ9MCxlPWFyZ3VtZW50cy5sZW5ndGg7dDxlO3QrPTEpbi5wdXNoLmFwcGx5KG4sZihhcmd1bWVudHNbdF0pKTtjb25zdCBpPVtdO2ZvcihsZXQgdD0wLGU9bi5sZW5ndGg7dDxlO3QrPTEpaWYoXCIuLlwiPT09blt0XSl7aWYoMD09PWkubGVuZ3RoKXJldHVybiByP1wiI1wiOlwiXCI7aS5wb3AoKX1lbHNlIGkucHVzaChuW3RdKTtyZXR1cm4gQShpLHIpfWZ1bmN0aW9uIE8odCl7Y29uc3QgZT1mKHQpO2lmKDA9PT1lLmxlbmd0aClyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmXCIjXCI9PT10WzBdP1tcIiNcIixlWzBdXTpbXCJcIix2b2lkIDBdO2lmKDE9PT1lLmxlbmd0aClyZXR1cm5cIiNcIj09PXRbMF0/W1wiI1wiLGVbMF1dOltcIlwiLGVbMF1dO2NvbnN0IG49ZS5wb3AoKTtyZXR1cm5bUChlLFwiI1wiPT09dFswXSksbl19Y29uc3QgXz17Z2V0OnMsc2V0OmcscmVtb3ZlOm0sam9pbjpQLHNwbGl0OmYsc3BsaXRMYXN0Ok8saXNSb290Om4scmVtb3ZlVW5kZWZpbmVkSXRlbXM6dn07cmV0dXJuIGV9KSgpKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2546\n')},4744:module=>{"use strict";eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc0NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanM/Njg2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4744\n")},6125:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.canonicalize = exports.canonicalize_quoted_string = exports.normalize = exports.normalize_dot_string = exports.parse = void 0;\n// const punycode = require(\'punycode\');\nconst nearley = __webpack_require__(8515);\nconst grammar_1 = __importDefault(__webpack_require__(2084));\ngrammar_1.default.ParserStart = "Mailbox";\nconst grammar = nearley.Grammar.fromCompiled(grammar_1.default);\n// <https://tools.ietf.org/html/rfc5321#section-4.1.2>\nfunction parse(address) {\n    const parser = new nearley.Parser(grammar);\n    parser.feed(address);\n    if (parser.results.length !== 1) {\n        throw new Error("address parsing failed: ambiguous grammar");\n    }\n    return parser.results[0];\n}\nexports.parse = parse;\n/** Strip +something, strip \'.\'s, and map to lower case.\n */\nfunction normalize_dot_string(dot_string) {\n    const tagless = (function () {\n        const plus_loc = dot_string.indexOf("+");\n        if (plus_loc === -1) {\n            return dot_string;\n        }\n        return dot_string.substr(0, plus_loc);\n    })();\n    const dotless = tagless.replace(/\\./g, "");\n    return dotless.toLowerCase();\n}\nexports.normalize_dot_string = normalize_dot_string;\n/** The G style address normalization.\n */\nfunction normalize(address) {\n    var _a, _b;\n    const a = parse(address);\n    const domain = (_a = a.domainPart.AddressLiteral) !== null && _a !== void 0 ? _a : a.domainPart.DomainName.toLowerCase();\n    const local = (_b = a.localPart.QuotedString) !== null && _b !== void 0 ? _b : normalize_dot_string(a.localPart.DotString);\n    return `${local}@${domain}`;\n}\nexports.normalize = normalize;\nfunction canonicalize_quoted_string(quoted_string) {\n    const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);\n    const unescaped = unquoted.replace(/(?:\\\\(.))/g, "$1");\n    const reescaped = unescaped.replace(/(?:(["\\\\]))/g, "\\\\$1");\n    return `"${reescaped}"`; // re-quote\n}\nexports.canonicalize_quoted_string = canonicalize_quoted_string;\n/**\n * Apply a canonicalization consistent with standards to support\n * comparison as a string.\n */\nfunction canonicalize(address) {\n    var _a;\n    const a = parse(address);\n    const domain = (_a = a.domainPart.AddressLiteral) !== null && _a !== void 0 ? _a : a.domainPart.DomainName.toLowerCase();\n    const local = a.localPart.QuotedString\n        ? canonicalize_quoted_string(a.localPart.QuotedString)\n        : a.localPart.DotString;\n    return `${local}@${domain}`;\n}\nexports.canonicalize = canonicalize;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEyNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtDQUFrQyxHQUFHLGlCQUFpQixHQUFHLDRCQUE0QixHQUFHLGFBQWE7QUFDNUg7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFTO0FBQ2pDLGtDQUFrQyxtQkFBTyxDQUFDLElBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNLEdBQUcsT0FBTztBQUM5QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVSxJQUFJO0FBQzdCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU0sR0FBRyxPQUFPO0FBQzlCO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNhcC9jc24taW50ZXJvcC1yZW5kZXJlci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3NtdHAtYWRkcmVzcy1wYXJzZXIvZGlzdC9saWIvaW5kZXguanM/ZTZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2Fub25pY2FsaXplID0gZXhwb3J0cy5jYW5vbmljYWxpemVfcXVvdGVkX3N0cmluZyA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5ub3JtYWxpemVfZG90X3N0cmluZyA9IGV4cG9ydHMucGFyc2UgPSB2b2lkIDA7XG4vLyBjb25zdCBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5jb25zdCBuZWFybGV5ID0gcmVxdWlyZShcIm5lYXJsZXlcIik7XG5jb25zdCBncmFtbWFyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZ3JhbW1hclwiKSk7XG5ncmFtbWFyXzEuZGVmYXVsdC5QYXJzZXJTdGFydCA9IFwiTWFpbGJveFwiO1xuY29uc3QgZ3JhbW1hciA9IG5lYXJsZXkuR3JhbW1hci5mcm9tQ29tcGlsZWQoZ3JhbW1hcl8xLmRlZmF1bHQpO1xuLy8gPGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC4xLjI+XG5mdW5jdGlvbiBwYXJzZShhZGRyZXNzKSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IG5lYXJsZXkuUGFyc2VyKGdyYW1tYXIpO1xuICAgIHBhcnNlci5mZWVkKGFkZHJlc3MpO1xuICAgIGlmIChwYXJzZXIucmVzdWx0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcyBwYXJzaW5nIGZhaWxlZDogYW1iaWd1b3VzIGdyYW1tYXJcIik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIucmVzdWx0c1swXTtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKiBTdHJpcCArc29tZXRoaW5nLCBzdHJpcCAnLidzLCBhbmQgbWFwIHRvIGxvd2VyIGNhc2UuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9kb3Rfc3RyaW5nKGRvdF9zdHJpbmcpIHtcbiAgICBjb25zdCB0YWdsZXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcGx1c19sb2MgPSBkb3Rfc3RyaW5nLmluZGV4T2YoXCIrXCIpO1xuICAgICAgICBpZiAocGx1c19sb2MgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZG90X3N0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG90X3N0cmluZy5zdWJzdHIoMCwgcGx1c19sb2MpO1xuICAgIH0pKCk7XG4gICAgY29uc3QgZG90bGVzcyA9IHRhZ2xlc3MucmVwbGFjZSgvXFwuL2csIFwiXCIpO1xuICAgIHJldHVybiBkb3RsZXNzLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZV9kb3Rfc3RyaW5nID0gbm9ybWFsaXplX2RvdF9zdHJpbmc7XG4vKiogVGhlIEcgc3R5bGUgYWRkcmVzcyBub3JtYWxpemF0aW9uLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYWRkcmVzcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYSA9IHBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRvbWFpbiA9IChfYSA9IGEuZG9tYWluUGFydC5BZGRyZXNzTGl0ZXJhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYS5kb21haW5QYXJ0LkRvbWFpbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBsb2NhbCA9IChfYiA9IGEubG9jYWxQYXJ0LlF1b3RlZFN0cmluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbm9ybWFsaXplX2RvdF9zdHJpbmcoYS5sb2NhbFBhcnQuRG90U3RyaW5nKTtcbiAgICByZXR1cm4gYCR7bG9jYWx9QCR7ZG9tYWlufWA7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZV9xdW90ZWRfc3RyaW5nKHF1b3RlZF9zdHJpbmcpIHtcbiAgICBjb25zdCB1bnF1b3RlZCA9IHF1b3RlZF9zdHJpbmcuc3Vic3RyKDEpLnN1YnN0cigwLCBxdW90ZWRfc3RyaW5nLmxlbmd0aCAtIDIpO1xuICAgIGNvbnN0IHVuZXNjYXBlZCA9IHVucXVvdGVkLnJlcGxhY2UoLyg/OlxcXFwoLikpL2csIFwiJDFcIik7XG4gICAgY29uc3QgcmVlc2NhcGVkID0gdW5lc2NhcGVkLnJlcGxhY2UoLyg/OihbXCJcXFxcXSkpL2csIFwiXFxcXCQxXCIpO1xuICAgIHJldHVybiBgXCIke3JlZXNjYXBlZH1cImA7IC8vIHJlLXF1b3RlXG59XG5leHBvcnRzLmNhbm9uaWNhbGl6ZV9xdW90ZWRfc3RyaW5nID0gY2Fub25pY2FsaXplX3F1b3RlZF9zdHJpbmc7XG4vKipcbiAqIEFwcGx5IGEgY2Fub25pY2FsaXphdGlvbiBjb25zaXN0ZW50IHdpdGggc3RhbmRhcmRzIHRvIHN1cHBvcnRcbiAqIGNvbXBhcmlzb24gYXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShhZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGEgPSBwYXJzZShhZGRyZXNzKTtcbiAgICBjb25zdCBkb21haW4gPSAoX2EgPSBhLmRvbWFpblBhcnQuQWRkcmVzc0xpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGEuZG9tYWluUGFydC5Eb21haW5OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgbG9jYWwgPSBhLmxvY2FsUGFydC5RdW90ZWRTdHJpbmdcbiAgICAgICAgPyBjYW5vbmljYWxpemVfcXVvdGVkX3N0cmluZyhhLmxvY2FsUGFydC5RdW90ZWRTdHJpbmcpXG4gICAgICAgIDogYS5sb2NhbFBhcnQuRG90U3RyaW5nO1xuICAgIHJldHVybiBgJHtsb2NhbH1AJHtkb21haW59YDtcbn1cbmV4cG9ydHMuY2Fub25pY2FsaXplID0gY2Fub25pY2FsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6125\n')},7853:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1My5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy92YWxpZC11cmwvaW5kZXguanM/MWJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfdXJpID0gaXNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX2h0dHBfdXJpID0gaXNfaHR0cF9pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfaHR0cHNfdXJpID0gaXNfaHR0cHNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX3dlYl91cmkgPSBpc193ZWJfaXJpO1xuICAgIC8vIENyZWF0ZSBhbGlhc2VzXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNVcmkgPSBpc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNIdHRwVXJpID0gaXNfaHR0cF9pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNIdHRwc1VyaSA9IGlzX2h0dHBzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc1dlYlVyaSA9IGlzX3dlYl9pcmk7XG5cblxuICAgIC8vIHByaXZhdGUgZnVuY3Rpb25cbiAgICAvLyBpbnRlcm5hbCBVUkkgc3BpdHRlciBtZXRob2QgLSBkaXJlY3QgZnJvbSBSRkMgMzk4NlxuICAgIHZhciBzcGxpdFVyaSA9IGZ1bmN0aW9uKHVyaSkge1xuICAgICAgICB2YXIgc3BsaXR0ZWQgPSB1cmkubWF0Y2goLyg/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8vKTtcbiAgICAgICAgcmV0dXJuIHNwbGl0dGVkO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc19pcmkodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoL1teYS16MC05XFw6XFwvXFw/XFwjXFxbXFxdXFxAXFwhXFwkXFwmXFwnXFwoXFwpXFwqXFwrXFwsXFw7XFw9XFwuXFwtXFxfXFx+XFwlXS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGhleCBlc2NhcGVzIHRoYXQgYXJlbid0IGNvbXBsZXRlXG4gICAgICAgIGlmICgvJVteMC05YS1mXS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGlmICgvJVswLTlhLWZdKDo/W14wLTlhLWZdfCQpL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcblxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICcnO1xuICAgICAgICB2YXIgYXV0aG9yaXR5ID0gJyc7XG4gICAgICAgIHZhciBwYXRoID0gJyc7XG4gICAgICAgIHZhciBxdWVyeSA9ICcnO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuXG4gICAgICAgIC8vIGZyb20gUkZDIDM5ODZcbiAgICAgICAgc3BsaXR0ZWQgPSBzcGxpdFVyaSh2YWx1ZSk7XG4gICAgICAgIHNjaGVtZSA9IHNwbGl0dGVkWzFdOyBcbiAgICAgICAgYXV0aG9yaXR5ID0gc3BsaXR0ZWRbMl07XG4gICAgICAgIHBhdGggPSBzcGxpdHRlZFszXTtcbiAgICAgICAgcXVlcnkgPSBzcGxpdHRlZFs0XTtcbiAgICAgICAgZnJhZ21lbnQgPSBzcGxpdHRlZFs1XTtcblxuICAgICAgICAvLyBzY2hlbWUgYW5kIHBhdGggYXJlIHJlcXVpcmVkLCB0aG91Z2ggdGhlIHBhdGggY2FuIGJlIGVtcHR5XG4gICAgICAgIGlmICghKHNjaGVtZSAmJiBzY2hlbWUubGVuZ3RoICYmIHBhdGgubGVuZ3RoID49IDApKSByZXR1cm47XG5cbiAgICAgICAgLy8gaWYgYXV0aG9yaXR5IGlzIHByZXNlbnQsIHRoZSBwYXRoIG11c3QgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIC9cbiAgICAgICAgaWYgKGF1dGhvcml0eSAmJiBhdXRob3JpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRoLmxlbmd0aCA9PT0gMCB8fCAvXlxcLy8udGVzdChwYXRoKSkpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGF1dGhvcml0eSBpcyBub3QgcHJlc2VudCwgdGhlIHBhdGggbXVzdCBub3Qgc3RhcnQgd2l0aCAvL1xuICAgICAgICAgICAgaWYgKC9eXFwvXFwvLy50ZXN0KHBhdGgpKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2hlbWUgbXVzdCBiZWdpbiB3aXRoIGEgbGV0dGVyLCB0aGVuIGNvbnNpc3Qgb2YgbGV0dGVycywgZGlnaXRzLCArLCAuLCBvciAtXG4gICAgICAgIGlmICghL15bYS16XVthLXowLTlcXCtcXC1cXC5dKiQvLnRlc3Qoc2NoZW1lLnRvTG93ZXJDYXNlKCkpKSAgcmV0dXJuO1xuXG4gICAgICAgIC8vIHJlLWFzc2VtYmxlIHRoZSBVUkwgcGVyIHNlY3Rpb24gNS4zIGluIFJGQyAzOTg2XG4gICAgICAgIG91dCArPSBzY2hlbWUgKyAnOic7XG4gICAgICAgIGlmIChhdXRob3JpdHkgJiYgYXV0aG9yaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICcvLycgKyBhdXRob3JpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gcGF0aDtcblxuICAgICAgICBpZiAocXVlcnkgJiYgcXVlcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2h0dHBfaXJpKHZhbHVlLCBhbGxvd0h0dHBzKSB7XG4gICAgICAgIGlmICghaXNfaXJpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwbGl0dGVkID0gW107XG4gICAgICAgIHZhciBzY2hlbWUgPSAnJztcbiAgICAgICAgdmFyIGF1dGhvcml0eSA9ICcnO1xuICAgICAgICB2YXIgcGF0aCA9ICcnO1xuICAgICAgICB2YXIgcG9ydCA9ICcnO1xuICAgICAgICB2YXIgcXVlcnkgPSAnJztcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIHZhciBvdXQgPSAnJztcblxuICAgICAgICAvLyBmcm9tIFJGQyAzOTg2XG4gICAgICAgIHNwbGl0dGVkID0gc3BsaXRVcmkodmFsdWUpO1xuICAgICAgICBzY2hlbWUgPSBzcGxpdHRlZFsxXTsgXG4gICAgICAgIGF1dGhvcml0eSA9IHNwbGl0dGVkWzJdO1xuICAgICAgICBwYXRoID0gc3BsaXR0ZWRbM107XG4gICAgICAgIHF1ZXJ5ID0gc3BsaXR0ZWRbNF07XG4gICAgICAgIGZyYWdtZW50ID0gc3BsaXR0ZWRbNV07XG5cbiAgICAgICAgaWYgKCFzY2hlbWUpICByZXR1cm47XG5cbiAgICAgICAgaWYoYWxsb3dIdHRwcykge1xuICAgICAgICAgICAgaWYgKHNjaGVtZS50b0xvd2VyQ2FzZSgpICE9ICdodHRwcycpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPSAnaHR0cCcpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bGx5LXF1YWxpZmllZCBVUklzIG11c3QgaGF2ZSBhbiBhdXRob3JpdHkgc2VjdGlvbiB0aGF0IGlzXG4gICAgICAgIC8vIGEgdmFsaWQgaG9zdFxuICAgICAgICBpZiAoIWF1dGhvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5hYmxlIHBvcnQgY29tcG9uZW50XG4gICAgICAgIGlmICgvOihcXGQrKSQvLnRlc3QoYXV0aG9yaXR5KSkge1xuICAgICAgICAgICAgcG9ydCA9IGF1dGhvcml0eS5tYXRjaCgvOihcXGQrKSQvKVswXTtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IGF1dGhvcml0eS5yZXBsYWNlKC86XFxkKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gc2NoZW1lICsgJzonO1xuICAgICAgICBvdXQgKz0gJy8vJyArIGF1dGhvcml0eTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBvdXQgKz0gcG9ydDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgb3V0ICs9IHBhdGg7XG4gICAgICAgIFxuICAgICAgICBpZihxdWVyeSAmJiBxdWVyeS5sZW5ndGgpe1xuICAgICAgICAgICAgb3V0ICs9ICc/JyArIHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZnJhZ21lbnQgJiYgZnJhZ21lbnQubGVuZ3RoKXtcbiAgICAgICAgICAgIG91dCArPSAnIycgKyBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19odHRwc19pcmkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzX2h0dHBfaXJpKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc193ZWJfaXJpKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoaXNfaHR0cF9pcmkodmFsdWUpIHx8IGlzX2h0dHBzX2lyaSh2YWx1ZSkpO1xuICAgIH1cblxufSkobW9kdWxlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7853\n")},8515:function(module){eval('(function(root, factory) {\n    if ( true && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === "undefined")\n                             ? this.symbols.map(getSymbolShortDisplay).join(\' \')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(\' \')\n                                 + " \u25cf "\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(\' \')     );\n        return this.name + " \u2192 " + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== \'string\') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset("");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === \'\\n\') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === \'string\') {\n            var lines = buffer\n                .split("\\n")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf(\'\\n\', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += " at line " + this.line + " col " + col + ":\\n\\n";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;\n                }, this)\n                .join("\\n");\n            message += "\\n" + pad("", lastLineDigits + col) + "^\\n";\n            return message;\n        } else {\n            return message + " at index " + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(" ") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal\'s start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it\'s worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo\'s thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";\n            lexerMessage = this.lexer.formatError(token, "Syntax error");\n        } else {\n            tokenDisplay = "input (lexer error)";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, "Syntax error");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== "string";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push(\'Unexpected \' + tokenDisplay + \'. I did not expect any more input. Here is the state of my parse table:\\n\');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push(\'Unexpected \' + tokenDisplay + \'. Instead, I was expecting to see one of the following:\\n\');\n            // Display a "state stack" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push(\'A \' + symbolDisplay + \' based on:\');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push("");\n        return lines.join("\\n");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push(\'    ^ \' + sameDisplayCount + \' more lines identical to this\');\n                }\n                sameDisplayCount = 0;\n                lines.push(\'    \' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don\'t know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error(\'set option `keepHistory` to enable rewinding\')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === "string") {\n            return symbol;\n        } else if (type === "object") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return \'character matching \' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + \' token\';\n            } else if (symbol.test) {\n                return \'token matching \' + String(symbol.test);\n            } else {\n                throw new Error(\'Unknown symbol type: \' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === "string") {\n            return symbol;\n        } else if (type === "object") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return \'%\' + symbol.type;\n            } else if (symbol.test) {\n                return \'<\' + String(symbol.test) + \'>\';\n            } else {\n                throw new Error(\'Unknown symbol type: \' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUxNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFFBQVEsS0FBMEI7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFtQixPQUFPO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFzRDtBQUNuRztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyREFBMkQ7QUFDM0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtDQUErQyxnQkFBZ0I7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYXAvY3NuLWludGVyb3AtcmVuZGVyZXItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZWFybGV5L2xpYi9uZWFybGV5LmpzP2JmZWEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5uZWFybGV5ID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBSdWxlKG5hbWUsIHN5bWJvbHMsIHBvc3Rwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuaWQgPSArK1J1bGUuaGlnaGVzdElkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBzeW1ib2xzOyAgICAgICAgLy8gYSBsaXN0IG9mIGxpdGVyYWwgfCByZWdleCBjbGFzcyB8IG5vbnRlcm1pbmFsXG4gICAgICAgIHRoaXMucG9zdHByb2Nlc3MgPSBwb3N0cHJvY2VzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFJ1bGUuaGlnaGVzdElkID0gMDtcblxuICAgIFJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24od2l0aEN1cnNvckF0KSB7XG4gICAgICAgIHZhciBzeW1ib2xTZXF1ZW5jZSA9ICh0eXBlb2Ygd2l0aEN1cnNvckF0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc3ltYm9scy5tYXAoZ2V0U3ltYm9sU2hvcnREaXNwbGF5KS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoICAgdGhpcy5zeW1ib2xzLnNsaWNlKDAsIHdpdGhDdXJzb3JBdCkubWFwKGdldFN5bWJvbFNob3J0RGlzcGxheSkuam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIOKXjyBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB0aGlzLnN5bWJvbHMuc2xpY2Uod2l0aEN1cnNvckF0KS5tYXAoZ2V0U3ltYm9sU2hvcnREaXNwbGF5KS5qb2luKCcgJykgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIiDihpIgXCIgKyBzeW1ib2xTZXF1ZW5jZTtcbiAgICB9XG5cblxuICAgIC8vIGEgU3RhdGUgaXMgYSBydWxlIGF0IGEgcG9zaXRpb24gZnJvbSBhIGdpdmVuIHN0YXJ0aW5nIHBvaW50IGluIHRoZSBpbnB1dCBzdHJlYW0gKHJlZmVyZW5jZSlcbiAgICBmdW5jdGlvbiBTdGF0ZShydWxlLCBkb3QsIHJlZmVyZW5jZSwgd2FudGVkQnkpIHtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICAgICAgdGhpcy5kb3QgPSBkb3Q7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy53YW50ZWRCeSA9IHdhbnRlZEJ5O1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0aGlzLmRvdCA9PT0gcnVsZS5zeW1ib2xzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy5ydWxlLnRvU3RyaW5nKHRoaXMuZG90KSArIFwifSwgZnJvbTogXCIgKyAodGhpcy5yZWZlcmVuY2UgfHwgMCk7XG4gICAgfTtcblxuICAgIFN0YXRlLnByb3RvdHlwZS5uZXh0U3RhdGUgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUodGhpcy5ydWxlLCB0aGlzLmRvdCArIDEsIHRoaXMucmVmZXJlbmNlLCB0aGlzLndhbnRlZEJ5KTtcbiAgICAgICAgc3RhdGUubGVmdCA9IHRoaXM7XG4gICAgICAgIHN0YXRlLnJpZ2h0ID0gY2hpbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuYnVpbGQoKTtcbiAgICAgICAgICAgIC8vIEhhdmluZyByaWdodCBzZXQgaGVyZSB3aWxsIHByZXZlbnQgdGhlIHJpZ2h0IHN0YXRlIGFuZCBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIGZvcm0gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgIHN0YXRlLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuXG4gICAgU3RhdGUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZS5yaWdodC5kYXRhKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIH0gd2hpbGUgKG5vZGUubGVmdCk7XG4gICAgICAgIGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGUucG9zdHByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMucnVsZS5wb3N0cHJvY2Vzcyh0aGlzLmRhdGEsIHRoaXMucmVmZXJlbmNlLCBQYXJzZXIuZmFpbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBDb2x1bW4oZ3JhbW1hciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLndhbnRzID0ge307IC8vIHN0YXRlcyBpbmRleGVkIGJ5IHRoZSBub24tdGVybWluYWwgdGhleSBleHBlY3RcbiAgICAgICAgdGhpcy5zY2FubmFibGUgPSBbXTsgLy8gbGlzdCBvZiBzdGF0ZXMgdGhhdCBleHBlY3QgYSB0b2tlblxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHt9OyAvLyBzdGF0ZXMgdGhhdCBhcmUgbnVsbGFibGVcbiAgICB9XG5cblxuICAgIENvbHVtbi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKG5leHRDb2x1bW4pIHtcbiAgICAgICAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICAgICAgICB2YXIgd2FudHMgPSB0aGlzLndhbnRzO1xuICAgICAgICB2YXIgY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBzdGF0ZXMubGVuZ3RoOyB3KyspIHsgLy8gbmIuIHdlIHB1c2goKSBkdXJpbmcgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbd107XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRhdGEgIT09IFBhcnNlci5mYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YW50ZWRCeSA9IHN0YXRlLndhbnRlZEJ5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gd2FudGVkQnkubGVuZ3RoOyBpLS07ICkgeyAvLyB0aGlzIGxpbmUgaXMgaG90XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHdhbnRlZEJ5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShsZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgbnVsbGFibGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZWZlcmVuY2UgPT09IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBmdXR1cmUgcHJlZGljdG9ycyBvZiB0aGlzIHJ1bGUgZ2V0IGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHAgPSBzdGF0ZS5ydWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jb21wbGV0ZWRbZXhwXSA9IHRoaXMuY29tcGxldGVkW2V4cF0gfHwgW10pLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHNjYW5uYWJsZSBzdGF0ZXNcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5hYmxlLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwcmVkaWN0XG4gICAgICAgICAgICAgICAgaWYgKHdhbnRzW2V4cF0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FudHNbZXhwXS5wdXNoKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkLmhhc093blByb3BlcnR5KGV4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudWxscyA9IGNvbXBsZXRlZFtleHBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IG51bGxzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoc3RhdGUsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbnRzW2V4cF0gPSBbc3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZWRpY3QoZXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb2x1bW4ucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbihleHApIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ncmFtbWFyLmJ5TmFtZVtleHBdIHx8IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcnVsZXNbaV07XG4gICAgICAgICAgICB2YXIgd2FudGVkQnkgPSB0aGlzLndhbnRzW2V4cF07XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBTdGF0ZShyLCAwLCB0aGlzLmluZGV4LCB3YW50ZWRCeSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29sdW1uLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBjb3B5ID0gbGVmdC5uZXh0U3RhdGUocmlnaHQpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKGNvcHkpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gR3JhbW1hcihydWxlcywgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfHwgdGhpcy5ydWxlc1swXS5uYW1lO1xuICAgICAgICB2YXIgYnlOYW1lID0gdGhpcy5ieU5hbWUgPSB7fTtcbiAgICAgICAgdGhpcy5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIGlmICghYnlOYW1lLmhhc093blByb3BlcnR5KHJ1bGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBieU5hbWVbcnVsZS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnlOYW1lW3J1bGUubmFtZV0ucHVzaChydWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU28gd2UgY2FuIGFsbG93IHBhc3NpbmcgKHJ1bGVzLCBzdGFydCkgZGlyZWN0bHkgdG8gUGFyc2VyIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIEdyYW1tYXIuZnJvbUNvbXBpbGVkID0gZnVuY3Rpb24ocnVsZXMsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBsZXhlciA9IHJ1bGVzLkxleGVyO1xuICAgICAgICBpZiAocnVsZXMuUGFyc2VyU3RhcnQpIHtcbiAgICAgICAgICBzdGFydCA9IHJ1bGVzLlBhcnNlclN0YXJ0O1xuICAgICAgICAgIHJ1bGVzID0gcnVsZXMuUGFyc2VyUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gcnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiAobmV3IFJ1bGUoci5uYW1lLCByLnN5bWJvbHMsIHIucG9zdHByb2Nlc3MpKTsgfSk7XG4gICAgICAgIHZhciBnID0gbmV3IEdyYW1tYXIocnVsZXMsIHN0YXJ0KTtcbiAgICAgICAgZy5sZXhlciA9IGxleGVyOyAvLyBuYi4gc3RvcmluZyBsZXhlciBvbiBHcmFtbWFyIGlzIGlmZnksIGJ1dCB1bmF2b2lkYWJsZVxuICAgICAgICByZXR1cm4gZztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIFN0cmVhbUxleGVyKCkge1xuICAgICAgdGhpcy5yZXNldChcIlwiKTtcbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkYXRhLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGRhdGE7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGF0ZSA/IHN0YXRlLmxpbmUgOiAxO1xuICAgICAgICB0aGlzLmxhc3RMaW5lQnJlYWsgPSBzdGF0ZSA/IC1zdGF0ZS5jb2wgOiAwO1xuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgICB0aGlzLmxpbmUgKz0gMTtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUJyZWFrID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IGNofTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgIGNvbDogdGhpcy5pbmRleCAtIHRoaXMubGFzdExpbmVCcmVhayxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbih0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICAvLyBuYi4gdGhpcyBnZXRzIGNhbGxlZCBhZnRlciBjb25zdW1pbmcgdGhlIG9mZmVuZGluZyB0b2tlbixcbiAgICAgICAgLy8gc28gdGhlIGN1bHByaXQgaXMgaW5kZXgtMVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gYnVmZmVyXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCB0aGlzLmxpbmUgLSA1KSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBuZXh0TGluZUJyZWFrID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5leHRMaW5lQnJlYWsgPT09IC0xKSBuZXh0TGluZUJyZWFrID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzLmluZGV4IC0gdGhpcy5sYXN0TGluZUJyZWFrO1xuICAgICAgICAgICAgdmFyIGxhc3RMaW5lRGlnaXRzID0gU3RyaW5nKHRoaXMubGluZSkubGVuZ3RoO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBhdCBsaW5lIFwiICsgdGhpcy5saW5lICsgXCIgY29sIFwiICsgY29sICsgXCI6XFxuXFxuXCI7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGxpbmVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWQodGhpcy5saW5lIC0gbGluZXMubGVuZ3RoICsgaSArIDEsIGxhc3RMaW5lRGlnaXRzKSArIFwiIFwiICsgbGluZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIlxcblwiICsgcGFkKFwiXCIsIGxhc3RMaW5lRGlnaXRzICsgY29sKSArIFwiXlxcblwiO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZSArIFwiIGF0IGluZGV4IFwiICsgKHRoaXMuaW5kZXggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhZChuLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzID0gU3RyaW5nKG4pO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KGxlbmd0aCAtIHMubGVuZ3RoICsgMSkuam9pbihcIiBcIikgKyBzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUGFyc2VyKHJ1bGVzLCBzdGFydCwgb3B0aW9ucykge1xuICAgICAgICBpZiAocnVsZXMgaW5zdGFuY2VvZiBHcmFtbWFyKSB7XG4gICAgICAgICAgICB2YXIgZ3JhbW1hciA9IHJ1bGVzO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBncmFtbWFyID0gR3JhbW1hci5mcm9tQ29tcGlsZWQocnVsZXMsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuXG4gICAgICAgIC8vIFJlYWQgb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBrZWVwSGlzdG9yeTogZmFsc2UsXG4gICAgICAgICAgICBsZXhlcjogZ3JhbW1hci5sZXhlciB8fCBuZXcgU3RyZWFtTGV4ZXIsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAob3B0aW9ucyB8fCB7fSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dXAgbGV4ZXJcbiAgICAgICAgdGhpcy5sZXhlciA9IHRoaXMub3B0aW9ucy5sZXhlcjtcbiAgICAgICAgdGhpcy5sZXhlclN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFNldHVwIGEgdGFibGVcbiAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBDb2x1bW4oZ3JhbW1hciwgMCk7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGUgPSBbY29sdW1uXTtcblxuICAgICAgICAvLyBJIGNvdWxkIGJlIGV4cGVjdGluZyBhbnl0aGluZy5cbiAgICAgICAgY29sdW1uLndhbnRzW2dyYW1tYXIuc3RhcnRdID0gW107XG4gICAgICAgIGNvbHVtbi5wcmVkaWN0KGdyYW1tYXIuc3RhcnQpO1xuICAgICAgICAvLyBUT0RPIHdoYXQgaWYgc3RhcnQgcnVsZSBpcyBudWxsYWJsZT9cbiAgICAgICAgY29sdW1uLnByb2Nlc3MoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMDsgLy8gdG9rZW4gaW5kZXhcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSByZXNlcnZlZCB0b2tlbiBmb3IgaW5kaWNhdGluZyBhIHBhcnNlIGZhaWxcbiAgICBQYXJzZXIuZmFpbCA9IHt9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5mZWVkID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgdmFyIGxleGVyID0gdGhpcy5sZXhlcjtcbiAgICAgICAgbGV4ZXIucmVzZXQoY2h1bmssIHRoaXMubGV4ZXJTdGF0ZSk7XG5cbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5leHQgY29sdW1uIHNvIHRoYXQgdGhlIGVycm9yIHJlcG9ydGVyXG4gICAgICAgICAgICAgICAgLy8gY2FuIGRpc3BsYXkgdGhlIGNvcnJlY3RseSBwcmVkaWN0ZWQgc3RhdGVzLlxuICAgICAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uID0gbmV3IENvbHVtbih0aGlzLmdyYW1tYXIsIHRoaXMuY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGUucHVzaChuZXh0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHRoaXMucmVwb3J0TGV4ZXJFcnJvcihlKSk7XG4gICAgICAgICAgICAgICAgZXJyLm9mZnNldCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICBlcnIudG9rZW4gPSBlLnRva2VuO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFkZCBuZXcgc3RhdGVzIHRvIHRhYmxlW2N1cnJlbnQrMV1cbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRhYmxlW3RoaXMuY3VycmVudF07XG5cbiAgICAgICAgICAgIC8vIEdDIHVudXNlZCBzdGF0ZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFibGVbdGhpcy5jdXJyZW50IC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5jdXJyZW50ICsgMTtcbiAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uID0gbmV3IENvbHVtbih0aGlzLmdyYW1tYXIsIG4pO1xuICAgICAgICAgICAgdGhpcy50YWJsZS5wdXNoKG5leHRDb2x1bW4pO1xuXG4gICAgICAgICAgICAvLyBBZHZhbmNlIGFsbCB0b2tlbnMgdGhhdCBleHBlY3QgdGhlIHN5bWJvbFxuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0b2tlbi50ZXh0ICE9PSB1bmRlZmluZWQgPyB0b2tlbi50ZXh0IDogdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsZXhlci5jb25zdHJ1Y3RvciA9PT0gU3RyZWFtTGV4ZXIgPyB0b2tlbi52YWx1ZSA6IHRva2VuO1xuICAgICAgICAgICAgdmFyIHNjYW5uYWJsZSA9IGNvbHVtbi5zY2FubmFibGU7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gc2Nhbm5hYmxlLmxlbmd0aDsgdy0tOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzY2FubmFibGVbd107XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjb25zdW1lIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIC8vIGVpdGhlciByZWdleCBvciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdC50ZXN0ID8gZXhwZWN0LnRlc3QodmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LnR5cGUgPyBleHBlY3QudHlwZSA9PT0gdG9rZW4udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4cGVjdC5saXRlcmFsID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0YXRlLm5leHRTdGF0ZSh7ZGF0YTogdmFsdWUsIHRva2VuOiB0b2tlbiwgaXNUb2tlbjogdHJ1ZSwgcmVmZXJlbmNlOiBuIC0gMX0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29sdW1uLnN0YXRlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV4dCwgZm9yIGVhY2ggb2YgdGhlIHJ1bGVzLCB3ZSBlaXRoZXJcbiAgICAgICAgICAgIC8vIChhKSBjb21wbGV0ZSBpdCwgYW5kIHRyeSB0byBzZWUgaWYgdGhlIHJlZmVyZW5jZSByb3cgZXhwZWN0ZWQgdGhhdFxuICAgICAgICAgICAgLy8gICAgIHJ1bGVcbiAgICAgICAgICAgIC8vIChiKSBwcmVkaWN0IHRoZSBuZXh0IG5vbnRlcm1pbmFsIGl0IGV4cGVjdHMgYnkgYWRkaW5nIHRoYXRcbiAgICAgICAgICAgIC8vICAgICBub250ZXJtaW5hbCdzIHN0YXJ0IHN0YXRlXG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0aW9uLCB3ZSBhbHNvIGtlZXAgdHJhY2sgb2YgcnVsZXMgd2UgaGF2ZSBhbHJlYWR5XG4gICAgICAgICAgICAvLyBhZGRlZFxuXG4gICAgICAgICAgICBuZXh0Q29sdW1uLnByb2Nlc3MoKTtcblxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkLCB0aHJvdyBhbiBlcnJvcjpcbiAgICAgICAgICAgIGlmIChuZXh0Q29sdW1uLnN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzdGF0ZXMgYXQgYWxsISBUaGlzIGlzIG5vdCBnb29kLlxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IodGhpcy5yZXBvcnRFcnJvcih0b2tlbikpO1xuICAgICAgICAgICAgICAgIGVyci5vZmZzZXQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgZXJyLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYXliZSBzYXZlIGxleGVyIHN0YXRlXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICAgIGNvbHVtbi5sZXhlclN0YXRlID0gbGV4ZXIuc2F2ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSBsZXhlci5zYXZlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudGFsbHkga2VlcCB0cmFjayBvZiByZXN1bHRzXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuZmluaXNoKCk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcsIGZvciB3aGF0ZXZlciBpdCdzIHdvcnRoXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlcG9ydExleGVyRXJyb3IgPSBmdW5jdGlvbihsZXhlckVycm9yKSB7XG4gICAgICAgIHZhciB0b2tlbkRpc3BsYXksIGxleGVyTWVzc2FnZTtcbiAgICAgICAgLy8gUGxhbm5pbmcgdG8gYWRkIGEgdG9rZW4gcHJvcGVydHkgdG8gbW9vJ3MgdGhyb3duIGVycm9yXG4gICAgICAgIC8vIGV2ZW4gb24gZXJyb3JpbmcgdG9rZW5zIHRvIGJlIHVzZWQgaW4gZXJyb3IgZGlzcGxheSBiZWxvd1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXhlckVycm9yLnRva2VuO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuRGlzcGxheSA9IFwiaW5wdXQgXCIgKyBKU09OLnN0cmluZ2lmeSh0b2tlbi50ZXh0WzBdKSArIFwiIChsZXhlciBlcnJvcilcIjtcbiAgICAgICAgICAgIGxleGVyTWVzc2FnZSA9IHRoaXMubGV4ZXIuZm9ybWF0RXJyb3IodG9rZW4sIFwiU3ludGF4IGVycm9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5EaXNwbGF5ID0gXCJpbnB1dCAobGV4ZXIgZXJyb3IpXCI7XG4gICAgICAgICAgICBsZXhlck1lc3NhZ2UgPSBsZXhlckVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVwb3J0RXJyb3JDb21tb24obGV4ZXJNZXNzYWdlLCB0b2tlbkRpc3BsYXkpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIHRva2VuRGlzcGxheSA9ICh0b2tlbi50eXBlID8gdG9rZW4udHlwZSArIFwiIHRva2VuOiBcIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodG9rZW4udmFsdWUgIT09IHVuZGVmaW5lZCA/IHRva2VuLnZhbHVlIDogdG9rZW4pO1xuICAgICAgICB2YXIgbGV4ZXJNZXNzYWdlID0gdGhpcy5sZXhlci5mb3JtYXRFcnJvcih0b2tlbiwgXCJTeW50YXggZXJyb3JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcG9ydEVycm9yQ29tbW9uKGxleGVyTWVzc2FnZSwgdG9rZW5EaXNwbGF5KTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXBvcnRFcnJvckNvbW1vbiA9IGZ1bmN0aW9uKGxleGVyTWVzc2FnZSwgdG9rZW5EaXNwbGF5KSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICBsaW5lcy5wdXNoKGxleGVyTWVzc2FnZSk7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uSW5kZXggPSB0aGlzLnRhYmxlLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uID0gdGhpcy50YWJsZVtsYXN0Q29sdW1uSW5kZXhdO1xuICAgICAgICB2YXIgZXhwZWN0YW50U3RhdGVzID0gbGFzdENvbHVtbi5zdGF0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFN5bWJvbCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U3ltYm9sICYmIHR5cGVvZiBuZXh0U3ltYm9sICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGV4cGVjdGFudFN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJ1VuZXhwZWN0ZWQgJyArIHRva2VuRGlzcGxheSArICcuIEkgZGlkIG5vdCBleHBlY3QgYW55IG1vcmUgaW5wdXQuIEhlcmUgaXMgdGhlIHN0YXRlIG9mIG15IHBhcnNlIHRhYmxlOlxcbicpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5U3RhdGVTdGFjayhsYXN0Q29sdW1uLnN0YXRlcywgbGluZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXMucHVzaCgnVW5leHBlY3RlZCAnICsgdG9rZW5EaXNwbGF5ICsgJy4gSW5zdGVhZCwgSSB3YXMgZXhwZWN0aW5nIHRvIHNlZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcXG4nKTtcbiAgICAgICAgICAgIC8vIERpc3BsYXkgYSBcInN0YXRlIHN0YWNrXCIgZm9yIGVhY2ggZXhwZWN0YW50IHN0YXRlXG4gICAgICAgICAgICAvLyAtIHdoaWNoIHNob3dzIHlvdSBob3cgdGhpcyBzdGF0ZSBjYW1lIHRvIGJlLCBzdGVwIGJ5IHN0ZXAuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGRlcml2YXRpb24sIHdlIG9ubHkgZGlzcGxheSB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgdmFyIHN0YXRlU3RhY2tzID0gZXhwZWN0YW50U3RhdGVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZpcnN0U3RhdGVTdGFjayhzdGF0ZSwgW10pIHx8IFtzdGF0ZV07XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAvLyBEaXNwbGF5IGVhY2ggc3RhdGUgdGhhdCBpcyBleHBlY3RpbmcgYSB0ZXJtaW5hbCBzeW1ib2wgbmV4dC5cbiAgICAgICAgICAgIHN0YXRlU3RhY2tzLmZvckVhY2goZnVuY3Rpb24oc3RhdGVTdGFjaykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlU3RhY2tbMF07XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTeW1ib2wgPSBzdGF0ZS5ydWxlLnN5bWJvbHNbc3RhdGUuZG90XTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sRGlzcGxheSA9IHRoaXMuZ2V0U3ltYm9sRGlzcGxheShuZXh0U3ltYm9sKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCdBICcgKyBzeW1ib2xEaXNwbGF5ICsgJyBiYXNlZCBvbjonKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlTdGF0ZVN0YWNrKHN0YXRlU3RhY2ssIGxpbmVzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBcbiAgICBQYXJzZXIucHJvdG90eXBlLmRpc3BsYXlTdGF0ZVN0YWNrID0gZnVuY3Rpb24oc3RhdGVTdGFjaywgbGluZXMpIHtcbiAgICAgICAgdmFyIGxhc3REaXNwbGF5O1xuICAgICAgICB2YXIgc2FtZURpc3BsYXlDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGVTdGFjay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVTdGFja1tqXTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gc3RhdGUucnVsZS50b1N0cmluZyhzdGF0ZS5kb3QpO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IGxhc3REaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgc2FtZURpc3BsYXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZURpc3BsYXlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnICAgIF4gJyArIHNhbWVEaXNwbGF5Q291bnQgKyAnIG1vcmUgbGluZXMgaWRlbnRpY2FsIHRvIHRoaXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FtZURpc3BsYXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnICAgICcgKyBkaXNwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3REaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmdldFN5bWJvbERpc3BsYXkgPSBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIGdldFN5bWJvbExvbmdEaXNwbGF5KHN5bWJvbCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQnVpbGRzIGEgdGhlIGZpcnN0IHN0YXRlIHN0YWNrLiBZb3UgY2FuIHRoaW5rIG9mIGEgc3RhdGUgc3RhY2sgYXMgdGhlIGNhbGwgc3RhY2tcbiAgICBvZiB0aGUgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyIHdoaWNoIHRoZSBOZWFybGV5IHBhcnNlIGFsZ29yaXRobSBzaW11bGF0ZXMuXG4gICAgQSBzdGF0ZSBzdGFjayBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZSBvYmplY3RzLiBXaXRoaW4gYVxuICAgIHN0YXRlIHN0YWNrLCB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgYXJyYXkgd2lsbCBiZSB0aGUgc3RhcnRpbmdcbiAgICBzdGF0ZSwgd2l0aCBlYWNoIHN1Y2Nlc3NpdmUgaXRlbSBpbiB0aGUgYXJyYXkgZ29pbmcgZnVydGhlciBiYWNrIGludG8gaGlzdG9yeS5cblxuICAgIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgZ2l2ZW4gYSBzdGFydGluZyBzdGF0ZSBhbmQgYW4gZW1wdHkgYXJyYXkgcmVwcmVzZW50aW5nXG4gICAgdGhlIHZpc2l0ZWQgc3RhdGVzLCBhbmQgaXQgcmV0dXJucyBhbiBzaW5nbGUgc3RhdGUgc3RhY2suXG5cbiAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuYnVpbGRGaXJzdFN0YXRlU3RhY2sgPSBmdW5jdGlvbihzdGF0ZSwgdmlzaXRlZCkge1xuICAgICAgICBpZiAodmlzaXRlZC5pbmRleE9mKHN0YXRlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGN5Y2xlLCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgLy8gdG8gZWxpbWluYXRlIHRoaXMgcGF0aCBmcm9tIHRoZSByZXN1bHRzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGhvdyB0byBkaXNwbGF5IGl0IG1lYW5pbmdmdWxseVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLndhbnRlZEJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzdGF0ZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHN0YXRlLndhbnRlZEJ5WzBdO1xuICAgICAgICB2YXIgY2hpbGRWaXNpdGVkID0gW3N0YXRlXS5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IHRoaXMuYnVpbGRGaXJzdFN0YXRlU3RhY2socHJldlN0YXRlLCBjaGlsZFZpc2l0ZWQpO1xuICAgICAgICBpZiAoY2hpbGRSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhdGVdLmNvbmNhdChjaGlsZFJlc3VsdCk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50YWJsZVt0aGlzLmN1cnJlbnRdO1xuICAgICAgICBjb2x1bW4ubGV4ZXJTdGF0ZSA9IHRoaXMubGV4ZXJTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvbHVtbi5pbmRleDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudGFibGVbaW5kZXhdID0gY29sdW1uO1xuICAgICAgICB0aGlzLnRhYmxlLnNwbGljZShpbmRleCArIDEpO1xuICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSBjb2x1bW4ubGV4ZXJTdGF0ZTtcblxuICAgICAgICAvLyBJbmNyZW1lbnRhbGx5IGtlZXAgdHJhY2sgb2YgcmVzdWx0c1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSB0aGlzLmZpbmlzaCgpO1xuICAgIH07XG5cbiAgICAvLyBuYi4gZGVwcmVjYXRlZDogdXNlIHNhdmUvcmVzdG9yZSBpbnN0ZWFkIVxuICAgIFBhcnNlci5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0IG9wdGlvbiBga2VlcEhpc3RvcnlgIHRvIGVuYWJsZSByZXdpbmRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIC8vIG5iLiByZWNhbGwgY29sdW1uICh0YWJsZSkgaW5kaWNpZXMgZmFsbCBiZXR3ZWVuIHRva2VuIGluZGljaWVzLlxuICAgICAgICAvLyAgICAgICAgY29sIDAgICAtLSAgIHRva2VuIDAgICAtLSAgIGNvbCAxXG4gICAgICAgIHRoaXMucmVzdG9yZSh0aGlzLnRhYmxlW2luZGV4XSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcG9zc2libGUgcGFyc2luZ3NcbiAgICAgICAgdmFyIGNvbnNpZGVyYXRpb25zID0gW107XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ3JhbW1hci5zdGFydDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMudGFibGVbdGhpcy50YWJsZS5sZW5ndGggLSAxXVxuICAgICAgICBjb2x1bW4uc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGlmICh0LnJ1bGUubmFtZSA9PT0gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgJiYgdC5kb3QgPT09IHQucnVsZS5zeW1ib2xzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAmJiB0LnJlZmVyZW5jZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAmJiB0LmRhdGEgIT09IFBhcnNlci5mYWlsKSB7XG4gICAgICAgICAgICAgICAgY29uc2lkZXJhdGlvbnMucHVzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25zaWRlcmF0aW9ucy5tYXAoZnVuY3Rpb24oYykge3JldHVybiBjLmRhdGE7IH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xMb25nRGlzcGxheShzeW1ib2wpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ltYm9sO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3ltYm9sLmxpdGVyYWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoYXJhY3RlciBtYXRjaGluZyAnICsgc3ltYm9sO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wudHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2wudHlwZSArICcgdG9rZW4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wudGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndG9rZW4gbWF0Y2hpbmcgJyArIFN0cmluZyhzeW1ib2wudGVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzeW1ib2wgdHlwZTogJyArIHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xTaG9ydERpc3BsYXkoc3ltYm9sKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHN5bWJvbDtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHN5bWJvbC5saXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN5bWJvbC5saXRlcmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ltYm9sIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW1ib2wudHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJScgKyBzeW1ib2wudHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ltYm9sLnRlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwnICsgU3RyaW5nKHN5bWJvbC50ZXN0KSArICc+JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN5bWJvbCB0eXBlOiAnICsgc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIFBhcnNlcjogUGFyc2VyLFxuICAgICAgICBHcmFtbWFyOiBHcmFtbWFyLFxuICAgICAgICBSdWxlOiBSdWxlLFxuICAgIH07XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8515\n')}}]);